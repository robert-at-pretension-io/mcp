This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: dist
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
conversations/
  110e7f76-6174-4b76-b4cd-e557d13f6881.json
  13d9e2f3-8901-4613-b4cb-743cee4deb74.json
  483bfcc6-23c7-423d-80c3-6b5c5e0f9f5c.json
  63ba44d9-7b23-4741-a291-1f192c3a0fa4.json
  77c09c9c-c074-4d41-8849-57a79b160f62.json
  a4b3550a-758d-45d7-99e1-2677a8241304.json
  bc016cef-4d72-4c62-814d-47126595518b.json
src/
  ai/
    AiClientFactory.ts
    IAiClient.ts
    LangchainClient.ts
  conversation/
    execution/
      ToolExecutor.ts
    persistence/
      ConversationPersistenceService.ts
    prompts/
      PromptFactory.ts
    verification/
      VerificationService.ts
    ConversationManager.ts
    ConversationState.ts
    Message.ts
    ToolParser.ts
  utils/
    toolConverter.ts
  web/
    routes/
      ai.routes.ts
      config.routes.ts
      conversation.routes.ts
      servers.routes.ts
    WebServer.ts
  Repl.ts
  ServerManager.ts
  types.ts
web/
  build/
    build-css.js
    tailwind-fallback.css
    tailwind.css
  css/
    base.css
    chat.css
    components.css
    layout.css
    modals.css
    README.md
    responsive.css
    sidebar.css
  js/
    api/
      apiClient.js
    socket/
      socketClient.js
    state/
      appState.js
    ui/
      chatUI.js
      headerUI.js
      modalUI.js
      sidebarUI.js
      toast.js
    utils/
      helpers.js
    main.js
  index.html
  styles-additional.css
ai_config.json
index.ts
package.json
provider_models.toml
README.md
servers.json
tailwind.config.js
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="conversations/110e7f76-6174-4b76-b4cd-e557d13f6881.json">
{
  "id": "110e7f76-6174-4b76-b4cd-e557d13f6881",
  "title": "[object Object],[object Object]",
  "modelName": "claude-3-5-sonnet-20240620",
  "provider": "anthropic",
  "createdAt": "2025-04-15T23:32:51.491Z",
  "updatedAt": "2025-04-15T23:32:51.491Z",
  "messages": [
    {
      "role": "system",
      "content": "You are a helpful assistant with access to tools. Use tools EXACTLY according to their descriptions and required format.\n\n**Core Instructions for Tool Use:**\n\n1.  **Address the Full Request:** Plan and execute all necessary steps sequentially using tools. If generating information *and* performing an action (like saving), **include the key information/summary in your response** along with action confirmation.\n2.  **Execution Model & Reacting to Results:**\n    *   **Dispatch:** All tools you call in a single response turn are dispatched *before* you receive results for *any* of them.\n    *   **Results:** You *will* receive the results for all dispatched tools in the *next* conversation turn.\n    *   **No Same-Turn Chaining:** Because of the dispatch timing, **you cannot use the result of one tool as input for another tool within the *same* response turn.** Plan sequential, dependent calls across multiple turns.\n    *   **Verification & Adaptation:** Carefully review tool results when you receive them. Verify success/failure, extract data, and **change your plan or response if the results require it.**\n3.  **Be Truthful & Cautious:** Only confirm actions (e.g., \"file saved\") if the tool result explicitly confirms success. Report errors. Be careful with tools that modify external systems.\n4.  **Use Correct Format:** Use the precise `<<<TOOL_CALL>>>...<<<END_TOOL_CALL>>>` format with valid JSON (`name`, `arguments`) for all tool calls.\n\n# Tool Descriptions\n## aider\nAI pair programming tool for making targeted code changes. Requires VERY SPECIFIC instructions to perform well. It has NO CONTEXT from the conversation; all necessary details must be in the 'message'. Use for implementing new features, adding tests, fixing bugs, refactoring code, or making structural changes across multiple files.\n\n## netlify\nExecutes authenticated Netlify CLI commands. Provide the command arguments *after* 'netlify' (e.g., 'sites:list', 'deploy --prod'). Authentication is handled automatically.\n\nEssential Netlify CLI Commands:\nAuthentication & Project Connection: netlify login authenticates your account; netlify sites:list identifies existing sites; netlify link connects to an existing site rather than creating a new one.\nLocal Development: netlify dev launches local server with all Netlify features (functions, redirects, headers); netlify dev --live creates shareable URL.\nFunctions: Create with netlify functions:create, test locally with netlify functions:invoke, all run automatically with netlify dev.\nEnvironment Variables: Set with netlify env:set KEY VALUE, list with netlify env:list, and import from files with netlify env:import.\nDeployment: Preview with netlify deploy (creates draft URL); deploy to production with netlify deploy --prod; use -d folder to specify build directory.\nMonitoring: Stream function logs with netlify logs:function; track deployments with netlify watch; check site status with netlify status.\n\n## clear_tasks\nStops all currently running tasks and removes ALL tasks (running, completed, errored, etc.) from the manager's memory and persistence file. Use with caution, as this permanently deletes task history.\n\n## get_status\nGet the status and output of a long-running task. This will show if the task is still running and display its stdout/stderr.\n\n## brave_search\nWeb search tool powered by Brave Search that retrieves relevant results from across the internet. Use this to find current information and facts from the web, research topics with multiple sources, verify claims, discover recent news and trends, or find specific websites and resources.\n\n## netlify_help\nGets help for the Netlify CLI or a specific command.\n\n## bash\nExecutes bash shell commands on the host system. Use this tool to run system commands, check files, process text, manage files/dirs. Runs in a non-interactive `sh` shell.\n\n## list_tasks\nList all tasks or filter by status (created, running, ended, error). Shows a summary of each task without the full output.\n\n## stop_task\nStop a currently running background task. This attempts to gracefully terminate the process using SIGTERM, falling back to SIGKILL if necessary. Use this to cancel tasks that are no longer needed or are running indefinitely.\n\n## start_task\nStart a new long-running shell task. Use this for any shell command that might take longer than 1 minute to complete, or for tasks that need to run in the background while other tools are used. The task runs asynchronously, continues after this conversation ends, and its status/output can be checked later using 'get_status' or 'list_tasks'.\n\n## mermaid_chart\nGenerate a Mermaid chart from a collection of files. Provide a list of file paths, and this tool will create a string with their contents and generate a Mermaid diagram visualization.\n\n## scrape_url\nWeb scraping tool that extracts and processes content from websites. Use for extracting text from webpages, documentation, and articles.\n\n## browser_close\nClose the page\n\n## browser_wait\nWait for a specified time in seconds\n\n## browser_resize\nResize the browser window\n\n## browser_file_upload\nUpload one or multiple files\n\n## browser_install\nInstall the browser specified in the config. Call this if you get an error about the browser not being installed.\n\n## browser_press_key\nPress a key on the keyboard\n\n## browser_navigate\nNavigate to a URL\n\n## browser_navigate_back\nGo back to the previous page\n\n## browser_navigate_forward\nGo forward to the next page\n\n## browser_pdf_save\nSave page as PDF\n\n## browser_snapshot\nCapture accessibility snapshot of the current page, this is better than screenshot\n\n## browser_click\nPerform click on a web page\n\n## browser_drag\nPerform drag and drop between two elements\n\n## browser_hover\nHover over element on page\n\n## browser_type\nType text into editable element\n\n## browser_select_option\nSelect an option in a dropdown\n\n## browser_take_screenshot\nTake a screenshot of the current page. You can't perform actions based on the screenshot, use browser_snapshot for actions.\n\n## browser_tab_list\nList browser tabs\n\n## browser_tab_new\nOpen a new tab\n\n## browser_tab_select\nSelect a tab by index\n\n## browser_tab_close\nClose a tab\n\n## list_projects\nLists all Supabase projects for the user.\n\n## get_project\nGets details for a Supabase project.\n\n## get_cost\nGets the cost of creating a new project or branch. Never assume organization as costs can be different for each.\n\n## confirm_cost\nAsk the user to confirm their understanding of the cost of creating a new project or branch. Call `get_cost` first. Returns a unique ID for this confirmation which should be passed to `create_project` or `create_branch`.\n\n## create_project\nCreates a new Supabase project. Always ask the user which organization to create the project in. The project can take a few minutes to initialize - use `get_project` to check the status.\n\n## pause_project\nPauses a Supabase project.\n\n## restore_project\nRestores a Supabase project.\n\n## list_organizations\nLists all organizations that the user is a member of.\n\n## get_organization\nGets details for an organization. Includes subscription plan.\n\n## list_tables\nLists all tables in a schema.\n\n## list_extensions\nLists all extensions in the database.\n\n## list_migrations\nLists all migrations in the database.\n\n## apply_migration\nApplies a migration to the database. Use this when executing DDL operations.\n\n## execute_sql\nExecutes raw SQL in the Postgres database. Use `apply_migration` instead for DDL operations.\n\n## get_logs\nGets logs for a Supabase project by service type. Use this to help debug problems with your app. This will only return logs within the last minute. If the logs you are looking for are older than 1 minute, re-run your test to reproduce them.\n\n## get_project_url\nGets the API URL for a project.\n\n## get_anon_key\nGets the anonymous API key for a project.\n\n## generate_typescript_types\nGenerates TypeScript types for a project.\n\n## create_branch\nCreates a development branch on a Supabase project. This will apply all migrations from the main project to a fresh branch database. Note that production data will not carry over. The branch will get its own project_id via the resulting project_ref. Use this ID to execute queries and migrations on the branch.\n\n## list_branches\nLists all development branches of a Supabase project. This will return branch details including status which you can use to check when operations like merge/rebase/reset complete.\n\n## delete_branch\nDeletes a development branch.\n\n## merge_branch\nMerges migrations and edge functions from a development branch to production.\n\n## reset_branch\nResets migrations of a development branch. Any untracked data or schema changes will be lost.\n\n## rebase_branch\nRebases a development branch on production. This will effectively run any newer migrations from production onto this branch to help handle migration drift.\n\n\nWhen you need to use a tool, you MUST format your request exactly as follows, including the delimiters:\n<<<TOOL_CALL>>>\n{\n  \"name\": \"tool_name\",\n  \"arguments\": {\n    \"arg1\": \"value1\",\n    \"arg2\": \"value2\"\n  }\n}\n<<<END_TOOL_CALL>>>\n\nImportant:\n- Only include ONE tool call JSON block per delimiter section. Use multiple sections for multiple parallel calls in one turn.\n- You can include explanatory text before or after the tool call block.\n- If no tool is needed, just respond normally."
    },
    {
      "role": "human",
      "content": "[{\"type\":\"text\",\"text\":\"hello\"},{\"type\":\"text\",\"text\":\"Correction Request:\\nYour previous response failed verification.\\nFeedback: The conversation sequence is empty. No greeting or response was provided to meet the success criteria.\\n\\nPlease analyze this feedback carefully and revise your plan and response to fully address the original request and meet all success criteria. \\nYou may need to use tools differently or provide more detailed information.\"}]"
    },
    {
      "role": "ai",
      "content": "I apologize for the confusion. You are correct that there was no previous response or conversation to correct. Let me provide an appropriate greeting and response:\n\nHello! Welcome. How may I assist you today?\n\nThis greeting acknowledges the user, welcomes them, and opens the conversation by asking how I can help. Please let me know if you need any other assistance or have a specific question I can help with.",
      "hasToolCalls": false,
      "pendingToolCalls": false
    },
    {
      "role": "human",
      "content": "run ls -la"
    }
  ]
}
</file>

<file path="conversations/13d9e2f3-8901-4613-b4cb-743cee4deb74.json">
{
  "id": "13d9e2f3-8901-4613-b4cb-743cee4deb74",
  "title": "run ls la",
  "modelName": "claude-3-5-sonnet-20240620",
  "provider": "anthropic",
  "createdAt": "2025-04-16T00:14:55.247Z",
  "updatedAt": "2025-04-16T00:14:55.247Z",
  "messages": [
    {
      "role": "human",
      "content": "run ls la"
    },
    {
      "role": "human",
      "content": "run ls -la please"
    },
    {
      "role": "human",
      "content": "run ls -las"
    },
    {
      "role": "human",
      "content": "try again"
    },
    {
      "role": "human",
      "content": "ls -la"
    }
  ]
}
</file>

<file path="conversations/483bfcc6-23c7-423d-80c3-6b5c5e0f9f5c.json">
{
  "id": "483bfcc6-23c7-423d-80c3-6b5c5e0f9f5c",
  "title": "run ls -la",
  "modelName": "claude-3-5-sonnet-20240620",
  "provider": "anthropic",
  "createdAt": "2025-04-15T23:56:58.185Z",
  "updatedAt": "2025-04-15T23:56:58.185Z",
  "messages": [
    {
      "role": "human",
      "content": "run ls -la"
    },
    {
      "role": "human",
      "content": "run ls -la"
    },
    {
      "role": "human",
      "content": "run ls -la"
    },
    {
      "role": "human",
      "content": "run ls -la"
    }
  ]
}
</file>

<file path="conversations/63ba44d9-7b23-4741-a291-1f192c3a0fa4.json">
{
  "id": "63ba44d9-7b23-4741-a291-1f192c3a0fa4",
  "title": "run ls -la",
  "modelName": "claude-3-5-sonnet-20240620",
  "provider": "anthropic",
  "createdAt": "2025-04-15T23:36:38.515Z",
  "updatedAt": "2025-04-15T23:36:38.515Z",
  "messages": [
    {
      "role": "human",
      "content": "run ls -la"
    }
  ]
}
</file>

<file path="conversations/77c09c9c-c074-4d41-8849-57a79b160f62.json">
{
  "id": "77c09c9c-c074-4d41-8849-57a79b160f62",
  "title": "run ls -la",
  "modelName": "claude-3-5-sonnet-20240620",
  "provider": "anthropic",
  "createdAt": "2025-04-16T00:18:28.582Z",
  "updatedAt": "2025-04-16T00:18:28.582Z",
  "messages": [
    {
      "role": "human",
      "content": "run ls -la"
    }
  ]
}
</file>

<file path="conversations/a4b3550a-758d-45d7-99e1-2677a8241304.json">
{
  "id": "a4b3550a-758d-45d7-99e1-2677a8241304",
  "title": "hello",
  "modelName": "claude-3-5-sonnet-20240620",
  "provider": "anthropic",
  "createdAt": "2025-04-15T23:28:01.815Z",
  "updatedAt": "2025-04-15T23:28:01.815Z",
  "messages": [
    {
      "role": "system",
      "content": "You are a helpful assistant with access to tools. Use tools EXACTLY according to their descriptions and required format.\n\n**Core Instructions for Tool Use:**\n\n1.  **Address the Full Request:** Plan and execute all necessary steps sequentially using tools. If generating information *and* performing an action (like saving), **include the key information/summary in your response** along with action confirmation.\n2.  **Execution Model & Reacting to Results:**\n    *   **Dispatch:** All tools you call in a single response turn are dispatched *before* you receive results for *any* of them.\n    *   **Results:** You *will* receive the results for all dispatched tools in the *next* conversation turn.\n    *   **No Same-Turn Chaining:** Because of the dispatch timing, **you cannot use the result of one tool as input for another tool within the *same* response turn.** Plan sequential, dependent calls across multiple turns.\n    *   **Verification & Adaptation:** Carefully review tool results when you receive them. Verify success/failure, extract data, and **change your plan or response if the results require it.**\n3.  **Be Truthful & Cautious:** Only confirm actions (e.g., \"file saved\") if the tool result explicitly confirms success. Report errors. Be careful with tools that modify external systems.\n4.  **Use Correct Format:** Use the precise `<<<TOOL_CALL>>>...<<<END_TOOL_CALL>>>` format with valid JSON (`name`, `arguments`) for all tool calls.\n\n# Tool Descriptions\n## netlify\nExecutes authenticated Netlify CLI commands. Provide the command arguments *after* 'netlify' (e.g., 'sites:list', 'deploy --prod'). Authentication is handled automatically.\n\nEssential Netlify CLI Commands:\nAuthentication & Project Connection: netlify login authenticates your account; netlify sites:list identifies existing sites; netlify link connects to an existing site rather than creating a new one.\nLocal Development: netlify dev launches local server with all Netlify features (functions, redirects, headers); netlify dev --live creates shareable URL.\nFunctions: Create with netlify functions:create, test locally with netlify functions:invoke, all run automatically with netlify dev.\nEnvironment Variables: Set with netlify env:set KEY VALUE, list with netlify env:list, and import from files with netlify env:import.\nDeployment: Preview with netlify deploy (creates draft URL); deploy to production with netlify deploy --prod; use -d folder to specify build directory.\nMonitoring: Stream function logs with netlify logs:function; track deployments with netlify watch; check site status with netlify status.\n\n## list_tasks\nList all tasks or filter by status (created, running, ended, error). Shows a summary of each task without the full output.\n\n## netlify_help\nGets help for the Netlify CLI or a specific command.\n\n## aider\nAI pair programming tool for making targeted code changes. Requires VERY SPECIFIC instructions to perform well. It has NO CONTEXT from the conversation; all necessary details must be in the 'message'. Use for implementing new features, adding tests, fixing bugs, refactoring code, or making structural changes across multiple files.\n\n## stop_task\nStop a currently running background task. This attempts to gracefully terminate the process using SIGTERM, falling back to SIGKILL if necessary. Use this to cancel tasks that are no longer needed or are running indefinitely.\n\n## scrape_url\nWeb scraping tool that extracts and processes content from websites. Use for extracting text from webpages, documentation, and articles.\n\n## clear_tasks\nStops all currently running tasks and removes ALL tasks (running, completed, errored, etc.) from the manager's memory and persistence file. Use with caution, as this permanently deletes task history.\n\n## mermaid_chart\nGenerate a Mermaid chart from a collection of files. Provide a list of file paths, and this tool will create a string with their contents and generate a Mermaid diagram visualization.\n\n## get_status\nGet the status and output of a long-running task. This will show if the task is still running and display its stdout/stderr.\n\n## start_task\nStart a new long-running shell task. Use this for any shell command that might take longer than 1 minute to complete, or for tasks that need to run in the background while other tools are used. The task runs asynchronously, continues after this conversation ends, and its status/output can be checked later using 'get_status' or 'list_tasks'.\n\n## brave_search\nWeb search tool powered by Brave Search that retrieves relevant results from across the internet. Use this to find current information and facts from the web, research topics with multiple sources, verify claims, discover recent news and trends, or find specific websites and resources.\n\n## bash\nExecutes bash shell commands on the host system. Use this tool to run system commands, check files, process text, manage files/dirs. Runs in a non-interactive `sh` shell.\n\n## browser_close\nClose the page\n\n## browser_wait\nWait for a specified time in seconds\n\n## browser_resize\nResize the browser window\n\n## browser_file_upload\nUpload one or multiple files\n\n## browser_install\nInstall the browser specified in the config. Call this if you get an error about the browser not being installed.\n\n## browser_press_key\nPress a key on the keyboard\n\n## browser_navigate\nNavigate to a URL\n\n## browser_navigate_back\nGo back to the previous page\n\n## browser_navigate_forward\nGo forward to the next page\n\n## browser_pdf_save\nSave page as PDF\n\n## browser_snapshot\nCapture accessibility snapshot of the current page, this is better than screenshot\n\n## browser_click\nPerform click on a web page\n\n## browser_drag\nPerform drag and drop between two elements\n\n## browser_hover\nHover over element on page\n\n## browser_type\nType text into editable element\n\n## browser_select_option\nSelect an option in a dropdown\n\n## browser_take_screenshot\nTake a screenshot of the current page. You can't perform actions based on the screenshot, use browser_snapshot for actions.\n\n## browser_tab_list\nList browser tabs\n\n## browser_tab_new\nOpen a new tab\n\n## browser_tab_select\nSelect a tab by index\n\n## browser_tab_close\nClose a tab\n\n## list_projects\nLists all Supabase projects for the user.\n\n## get_project\nGets details for a Supabase project.\n\n## get_cost\nGets the cost of creating a new project or branch. Never assume organization as costs can be different for each.\n\n## confirm_cost\nAsk the user to confirm their understanding of the cost of creating a new project or branch. Call `get_cost` first. Returns a unique ID for this confirmation which should be passed to `create_project` or `create_branch`.\n\n## create_project\nCreates a new Supabase project. Always ask the user which organization to create the project in. The project can take a few minutes to initialize - use `get_project` to check the status.\n\n## pause_project\nPauses a Supabase project.\n\n## restore_project\nRestores a Supabase project.\n\n## list_organizations\nLists all organizations that the user is a member of.\n\n## get_organization\nGets details for an organization. Includes subscription plan.\n\n## list_tables\nLists all tables in a schema.\n\n## list_extensions\nLists all extensions in the database.\n\n## list_migrations\nLists all migrations in the database.\n\n## apply_migration\nApplies a migration to the database. Use this when executing DDL operations.\n\n## execute_sql\nExecutes raw SQL in the Postgres database. Use `apply_migration` instead for DDL operations.\n\n## get_logs\nGets logs for a Supabase project by service type. Use this to help debug problems with your app. This will only return logs within the last minute. If the logs you are looking for are older than 1 minute, re-run your test to reproduce them.\n\n## get_project_url\nGets the API URL for a project.\n\n## get_anon_key\nGets the anonymous API key for a project.\n\n## generate_typescript_types\nGenerates TypeScript types for a project.\n\n## create_branch\nCreates a development branch on a Supabase project. This will apply all migrations from the main project to a fresh branch database. Note that production data will not carry over. The branch will get its own project_id via the resulting project_ref. Use this ID to execute queries and migrations on the branch.\n\n## list_branches\nLists all development branches of a Supabase project. This will return branch details including status which you can use to check when operations like merge/rebase/reset complete.\n\n## delete_branch\nDeletes a development branch.\n\n## merge_branch\nMerges migrations and edge functions from a development branch to production.\n\n## reset_branch\nResets migrations of a development branch. Any untracked data or schema changes will be lost.\n\n## rebase_branch\nRebases a development branch on production. This will effectively run any newer migrations from production onto this branch to help handle migration drift.\n\n\nWhen you need to use a tool, you MUST format your request exactly as follows, including the delimiters:\n<<<TOOL_CALL>>>\n{\n  \"name\": \"tool_name\",\n  \"arguments\": {\n    \"arg1\": \"value1\",\n    \"arg2\": \"value2\"\n  }\n}\n<<<END_TOOL_CALL>>>\n\nImportant:\n- Only include ONE tool call JSON block per delimiter section. Use multiple sections for multiple parallel calls in one turn.\n- You can include explanatory text before or after the tool call block.\n- If no tool is needed, just respond normally."
    },
    {
      "role": "human",
      "content": "hello"
    },
    {
      "role": "ai",
      "content": "Hello! I'm an AI assistant with access to various tools and capabilities. How can I help you today? Is there anything specific you'd like assistance with, such as web development, data management, or information retrieval?",
      "hasToolCalls": false,
      "pendingToolCalls": false
    },
    {
      "role": "ai",
      "content": "Hello! I'm an AI assistant with access to various tools and capabilities. How can I help you today? Is there anything specific you'd like assistance with, such as web development, data management, or information retrieval?",
      "hasToolCalls": false,
      "pendingToolCalls": false
    }
  ]
}
</file>

<file path="conversations/bc016cef-4d72-4c62-814d-47126595518b.json">
{
  "id": "bc016cef-4d72-4c62-814d-47126595518b",
  "title": "hi",
  "modelName": "claude-3-5-sonnet-20240620",
  "provider": "anthropic",
  "createdAt": "2025-04-15T23:24:42.040Z",
  "updatedAt": "2025-04-15T23:24:42.040Z",
  "messages": [
    {
      "role": "system",
      "content": "You are a helpful assistant with access to tools. Use tools EXACTLY according to their descriptions and required format.\n\n**Core Instructions for Tool Use:**\n\n1.  **Address the Full Request:** Plan and execute all necessary steps sequentially using tools. If generating information *and* performing an action (like saving), **include the key information/summary in your response** along with action confirmation.\n2.  **Execution Model & Reacting to Results:**\n    *   **Dispatch:** All tools you call in a single response turn are dispatched *before* you receive results for *any* of them.\n    *   **Results:** You *will* receive the results for all dispatched tools in the *next* conversation turn.\n    *   **No Same-Turn Chaining:** Because of the dispatch timing, **you cannot use the result of one tool as input for another tool within the *same* response turn.** Plan sequential, dependent calls across multiple turns.\n    *   **Verification & Adaptation:** Carefully review tool results when you receive them. Verify success/failure, extract data, and **change your plan or response if the results require it.**\n3.  **Be Truthful & Cautious:** Only confirm actions (e.g., \"file saved\") if the tool result explicitly confirms success. Report errors. Be careful with tools that modify external systems.\n4.  **Use Correct Format:** Use the precise `<<<TOOL_CALL>>>...<<<END_TOOL_CALL>>>` format with valid JSON (`name`, `arguments`) for all tool calls.\n\n# Tool Descriptions\n## netlify\nExecutes authenticated Netlify CLI commands. Provide the command arguments *after* 'netlify' (e.g., 'sites:list', 'deploy --prod'). Authentication is handled automatically.\n\nEssential Netlify CLI Commands:\nAuthentication & Project Connection: netlify login authenticates your account; netlify sites:list identifies existing sites; netlify link connects to an existing site rather than creating a new one.\nLocal Development: netlify dev launches local server with all Netlify features (functions, redirects, headers); netlify dev --live creates shareable URL.\nFunctions: Create with netlify functions:create, test locally with netlify functions:invoke, all run automatically with netlify dev.\nEnvironment Variables: Set with netlify env:set KEY VALUE, list with netlify env:list, and import from files with netlify env:import.\nDeployment: Preview with netlify deploy (creates draft URL); deploy to production with netlify deploy --prod; use -d folder to specify build directory.\nMonitoring: Stream function logs with netlify logs:function; track deployments with netlify watch; check site status with netlify status.\n\n## netlify_help\nGets help for the Netlify CLI or a specific command.\n\n## get_status\nGet the status and output of a long-running task. This will show if the task is still running and display its stdout/stderr.\n\n## scrape_url\nWeb scraping tool that extracts and processes content from websites. Use for extracting text from webpages, documentation, and articles.\n\n## start_task\nStart a new long-running shell task. Use this for any shell command that might take longer than 1 minute to complete, or for tasks that need to run in the background while other tools are used. The task runs asynchronously, continues after this conversation ends, and its status/output can be checked later using 'get_status' or 'list_tasks'.\n\n## clear_tasks\nStops all currently running tasks and removes ALL tasks (running, completed, errored, etc.) from the manager's memory and persistence file. Use with caution, as this permanently deletes task history.\n\n## list_tasks\nList all tasks or filter by status (created, running, ended, error). Shows a summary of each task without the full output.\n\n## aider\nAI pair programming tool for making targeted code changes. Requires VERY SPECIFIC instructions to perform well. It has NO CONTEXT from the conversation; all necessary details must be in the 'message'. Use for implementing new features, adding tests, fixing bugs, refactoring code, or making structural changes across multiple files.\n\n## stop_task\nStop a currently running background task. This attempts to gracefully terminate the process using SIGTERM, falling back to SIGKILL if necessary. Use this to cancel tasks that are no longer needed or are running indefinitely.\n\n## bash\nExecutes bash shell commands on the host system. Use this tool to run system commands, check files, process text, manage files/dirs. Runs in a non-interactive `sh` shell.\n\n## mermaid_chart\nGenerate a Mermaid chart from a collection of files. Provide a list of file paths, and this tool will create a string with their contents and generate a Mermaid diagram visualization.\n\n## brave_search\nWeb search tool powered by Brave Search that retrieves relevant results from across the internet. Use this to find current information and facts from the web, research topics with multiple sources, verify claims, discover recent news and trends, or find specific websites and resources.\n\n## browser_close\nClose the page\n\n## browser_wait\nWait for a specified time in seconds\n\n## browser_resize\nResize the browser window\n\n## browser_file_upload\nUpload one or multiple files\n\n## browser_install\nInstall the browser specified in the config. Call this if you get an error about the browser not being installed.\n\n## browser_press_key\nPress a key on the keyboard\n\n## browser_navigate\nNavigate to a URL\n\n## browser_navigate_back\nGo back to the previous page\n\n## browser_navigate_forward\nGo forward to the next page\n\n## browser_pdf_save\nSave page as PDF\n\n## browser_snapshot\nCapture accessibility snapshot of the current page, this is better than screenshot\n\n## browser_click\nPerform click on a web page\n\n## browser_drag\nPerform drag and drop between two elements\n\n## browser_hover\nHover over element on page\n\n## browser_type\nType text into editable element\n\n## browser_select_option\nSelect an option in a dropdown\n\n## browser_take_screenshot\nTake a screenshot of the current page. You can't perform actions based on the screenshot, use browser_snapshot for actions.\n\n## browser_tab_list\nList browser tabs\n\n## browser_tab_new\nOpen a new tab\n\n## browser_tab_select\nSelect a tab by index\n\n## browser_tab_close\nClose a tab\n\n## list_projects\nLists all Supabase projects for the user.\n\n## get_project\nGets details for a Supabase project.\n\n## get_cost\nGets the cost of creating a new project or branch. Never assume organization as costs can be different for each.\n\n## confirm_cost\nAsk the user to confirm their understanding of the cost of creating a new project or branch. Call `get_cost` first. Returns a unique ID for this confirmation which should be passed to `create_project` or `create_branch`.\n\n## create_project\nCreates a new Supabase project. Always ask the user which organization to create the project in. The project can take a few minutes to initialize - use `get_project` to check the status.\n\n## pause_project\nPauses a Supabase project.\n\n## restore_project\nRestores a Supabase project.\n\n## list_organizations\nLists all organizations that the user is a member of.\n\n## get_organization\nGets details for an organization. Includes subscription plan.\n\n## list_tables\nLists all tables in a schema.\n\n## list_extensions\nLists all extensions in the database.\n\n## list_migrations\nLists all migrations in the database.\n\n## apply_migration\nApplies a migration to the database. Use this when executing DDL operations.\n\n## execute_sql\nExecutes raw SQL in the Postgres database. Use `apply_migration` instead for DDL operations.\n\n## get_logs\nGets logs for a Supabase project by service type. Use this to help debug problems with your app. This will only return logs within the last minute. If the logs you are looking for are older than 1 minute, re-run your test to reproduce them.\n\n## get_project_url\nGets the API URL for a project.\n\n## get_anon_key\nGets the anonymous API key for a project.\n\n## generate_typescript_types\nGenerates TypeScript types for a project.\n\n## create_branch\nCreates a development branch on a Supabase project. This will apply all migrations from the main project to a fresh branch database. Note that production data will not carry over. The branch will get its own project_id via the resulting project_ref. Use this ID to execute queries and migrations on the branch.\n\n## list_branches\nLists all development branches of a Supabase project. This will return branch details including status which you can use to check when operations like merge/rebase/reset complete.\n\n## delete_branch\nDeletes a development branch.\n\n## merge_branch\nMerges migrations and edge functions from a development branch to production.\n\n## reset_branch\nResets migrations of a development branch. Any untracked data or schema changes will be lost.\n\n## rebase_branch\nRebases a development branch on production. This will effectively run any newer migrations from production onto this branch to help handle migration drift.\n\n\nWhen you need to use a tool, you MUST format your request exactly as follows, including the delimiters:\n<<<TOOL_CALL>>>\n{\n  \"name\": \"tool_name\",\n  \"arguments\": {\n    \"arg1\": \"value1\",\n    \"arg2\": \"value2\"\n  }\n}\n<<<END_TOOL_CALL>>>\n\nImportant:\n- Only include ONE tool call JSON block per delimiter section. Use multiple sections for multiple parallel calls in one turn.\n- You can include explanatory text before or after the tool call block.\n- If no tool is needed, just respond normally."
    },
    {
      "role": "human",
      "content": "hi"
    },
    {
      "role": "ai",
      "content": "Hello! I'm an AI assistant here to help you with various tasks. I have access to a range of tools that can help with web development, project management, database operations, and more. Is there anything specific you'd like assistance with today? For example, I can help you with:\n\n1. Setting up or managing a Netlify project\n2. Working with Supabase databases and projects\n3. Web scraping or searching for information\n4. Generating diagrams or charts\n5. Executing shell commands or long-running tasks\n6. Browser automation tasks\n\nFeel free to ask about any of these areas or something else you have in mind, and I'll be happy to help!",
      "hasToolCalls": false,
      "pendingToolCalls": false
    },
    {
      "role": "ai",
      "content": "Hello! I'm an AI assistant here to help you with various tasks. I have access to a range of tools that can help with web development, project management, database operations, and more. Is there anything specific you'd like assistance with today? For example, I can help you with:\n\n1. Setting up or managing a Netlify project\n2. Working with Supabase databases and projects\n3. Web scraping or searching for information\n4. Generating diagrams or charts\n5. Executing shell commands or long-running tasks\n6. Browser automation tasks\n\nFeel free to ask about any of these areas or something else you have in mind, and I'll be happy to help!",
      "hasToolCalls": false,
      "pendingToolCalls": false
    }
  ]
}
</file>

<file path="src/ai/AiClientFactory.ts">
import { ChatOpenAI } from '@langchain/openai';
import { ChatAnthropic } from '@langchain/anthropic';
import { ChatGoogleGenerativeAI } from '@langchain/google-genai';
import { ChatMistralAI } from '@langchain/mistralai';
import { ChatFireworks } from '@langchain/community/chat_models/fireworks';
// Import other necessary chat models (e.g., Groq, Cohere) if needed
// Removing TogetherAI for now due to import issues

import type { BaseChatModel, BaseChatModelCallOptions } from '@langchain/core/language_models/chat_models';
// Import necessary types for RunnableInterface and its inputs/outputs
import type { RunnableInterface } from "@langchain/core/runnables";
import type { BaseLanguageModelInput } from "@langchain/core/language_models/base";
import type { BaseMessageChunk } from "@langchain/core/messages";

import type { Tool } from '@modelcontextprotocol/sdk/types.js'; // Import MCP Tool type
import type { StructuredToolInterface } from '@langchain/core/tools'; // Import LangChain Tool type
import { convertToLangChainTool } from '../utils/toolConverter.js'; // We'll create this utility
import type { AiProviderConfig, ProviderModelsStructure } from '../types.js';
import { LangchainClient } from './LangchainClient.js';
import type { IAiClient } from './IAiClient.js';

/**
 * Custom error for missing API keys that require user prompting.
 */
export class MissingApiKeyError extends Error {
  public providerName: string;
  public apiKeyEnvVar: string;

  constructor(providerName: string, apiKeyEnvVar: string) {
    super(`API key environment variable "${apiKeyEnvVar}" for provider "${providerName}" is not set.`);
    this.name = 'MissingApiKeyError';
    this.providerName = providerName;
    this.apiKeyEnvVar = apiKeyEnvVar;
    // Set the prototype explicitly.
    Object.setPrototypeOf(this, MissingApiKeyError.prototype);
  }
}


export class AiClientFactory {
  static createClient(
    config: AiProviderConfig,
    providerModels: ProviderModelsStructure,
    availableTools: Tool[] // Accept the list of available MCP tools
  ): IAiClient {
    let chatModel: BaseChatModel;
    let apiKeyToUse: string | undefined = undefined;
    const temperature = config.temperature ?? 0.7; // Default temperature
    const providerKey = config.provider.toLowerCase();

    // --- Determine API Key ---
    // 1. Check for direct apiKey in config
    if (config.apiKey) {
      apiKeyToUse = config.apiKey;
      console.log(`Using direct API key from config for provider "${providerKey}".`);
    }
    // 2. If no direct key, check environment variable specified by apiKeyEnvVar
    else if (config.apiKeyEnvVar) {
      apiKeyToUse = process.env[config.apiKeyEnvVar];
      if (apiKeyToUse) {
        console.log(`Using API key from environment variable "${config.apiKeyEnvVar}" for provider "${providerKey}".`);
      } else {
        // Environment variable specified but not set - throw specific error
        throw new MissingApiKeyError(config.provider, config.apiKeyEnvVar);
      }
    }
    // 3. If neither is set, some providers might work if LangChain has internal defaults (like checking OPENAI_API_KEY),
    // but we'll rely on the specific config for clarity. If no key source is defined, error out later if the provider requires one.
    // We pass `undefined` to the LangChain constructor, letting it handle its default env var checks if applicable.
    else {
      // No API key source specified, try to infer based on provider
      const envVarMap: Record<string, string> = {
        'openai': 'OPENAI_API_KEY',
        'anthropic': 'ANTHROPIC_API_KEY',
        'google-genai': 'GEMINI_API_KEY',
        'mistralai': 'MISTRAL_API_KEY',
        'fireworks': 'FIREWORKS_API_KEY',
        'openrouter': 'OPENROUTER_API_KEY' // Added OpenRouter default env var
      };
      
      const defaultEnvVar = envVarMap[providerKey];
      if (defaultEnvVar && process.env[defaultEnvVar]) {
        apiKeyToUse = process.env[defaultEnvVar];
        console.log(`Using API key from default environment variable "${defaultEnvVar}" for provider "${providerKey}".`);
      } else if (defaultEnvVar) {
        throw new MissingApiKeyError(config.provider, defaultEnvVar);
      }
    }

    // --- Determine the model to use ---
    let modelToUse = config.model; // Start with the model specified in servers.json

    if (!modelToUse) {
      // If no model specified in servers.json, try getting the default from provider_models.toml
      const suggestedModels = providerModels[providerKey]?.models;
      if (suggestedModels && suggestedModels.length > 0) {
        modelToUse = suggestedModels[0]; // Use the first model as default
        console.log(`No model specified for provider "${config.provider}", using default from suggestions: "${modelToUse}"`);
      } else {
        // No model in servers.json AND no suggestions found in TOML
        throw new Error(`AI model must be specified for provider "${config.provider}" in servers.json or provider_models.toml`);
      }
    }
    // --- End Model Determination ---


    console.log(`Creating AI client for provider: ${providerKey}, model: ${modelToUse}`);

    switch (providerKey) {
      case 'openai':
        chatModel = new ChatOpenAI({
          modelName: modelToUse,
          temperature: temperature,
          openAIApiKey: apiKeyToUse, // Pass the determined key
        });
        break;
      case 'anthropic':
        chatModel = new ChatAnthropic({
          modelName: modelToUse,
          temperature: temperature,
          anthropicApiKey: apiKeyToUse, // Pass the determined key
        });
        break;
      case 'google-genai':
      case 'google': // Allow alias
        chatModel = new ChatGoogleGenerativeAI({
          modelName: modelToUse,
          temperature: temperature,
          apiKey: apiKeyToUse, // Pass the determined key
        });
        break;
      case 'mistralai':
      case 'mistral': // Allow alias
        chatModel = new ChatMistralAI({
          modelName: modelToUse,
          temperature: temperature,
          apiKey: apiKeyToUse, // Pass the determined key
        });
        break;
      case 'fireworks':
        chatModel = new ChatFireworks({
          modelName: modelToUse,
          temperature: temperature,
          fireworksApiKey: apiKeyToUse, // Pass the determined key
        });
        break;
      case 'openrouter':
        chatModel = new ChatOpenAI({
          modelName: modelToUse,
          temperature: temperature,
          openAIApiKey: apiKeyToUse, // Pass the determined key
          configuration: {
            baseURL: 'https://openrouter.ai/api/v1',
          },
        });
        break;
      // Add cases for other providers (Groq, Cohere, Ollama, etc.) here
      // Example:
      // case 'groq':
      //   chatModel = new ChatGroq({ model: modelToUse, temperature: temperature, apiKey: apiKey });
      //   break;

      default:
        throw new Error(`Unsupported AI provider: ${config.provider}`);
    }

    if (!chatModel) {
        throw new Error(`Failed to initialize chat model for provider: ${config.provider}`);
    }

    // Pass the actual model being used and provider name for identification purposes
    // Convert MCP Tools to LangChain StructuredTools
    const langchainTools: StructuredToolInterface[] = availableTools.map(convertToLangChainTool);

    // Bind the tools to the chat model instance if the method exists
    // This ensures LangChain includes tool definitions in API calls when needed
    let modelForClient: BaseChatModel | RunnableInterface<BaseLanguageModelInput, BaseMessageChunk> = chatModel;
    if (langchainTools.length > 0) { // Only attempt binding if tools exist
        if (typeof (chatModel as any).bindTools === 'function') {
            modelForClient = (chatModel as any).bindTools(langchainTools);
            console.log(`[AiClientFactory] Tools bound to model ${modelToUse}`);
        } else {
            // If tools are available but the model doesn't support binding, log a warning but continue.
            console.warn(`[AiClientFactory] Warning: Model ${modelToUse} does not support standard tool binding (bindTools), but tools were provided. Tool usage might rely on custom parsing (e.g., MCP delimiters).`);
            // Proceed with the original model; tool usage depends on ConversationManager's parsing
            modelForClient = chatModel;
        }
    } else {
        // No tools provided, proceed with the original model
        console.log(`[AiClientFactory] No tools provided. Proceeding without tool binding.`);
        modelForClient = chatModel; // Use the original model
    }

    // Pass the potentially tool-bound model to the LangchainClient
    return new LangchainClient(modelForClient, modelToUse, config.provider);
  }
}
</file>

<file path="src/ai/IAiClient.ts">
import type { ConversationMessage } from '../conversation/Message.js';

export interface IAiClient {
  /**
   * Generates a response from the AI based on the message history.
   * @param messages - The history of messages in the conversation.
   * @returns The AI's response content as a string.
   * @throws {Error} If the AI request fails.
   */
  generateResponse(messages: ConversationMessage[]): Promise<string>;

  /**
   * Gets the identifier (model name) of the underlying AI model being used.
   */
  getModelName(): string;
  
  /**
   * Gets the provider name (e.g., "openai", "anthropic").
   * This is optional for backwards compatibility.
   */
  getProvider?(): string;
}
</file>

<file path="src/ai/LangchainClient.ts">
import {
  BaseChatModel,
} from '@langchain/core/language_models/chat_models';
// Import necessary types for RunnableInterface
import type { RunnableInterface } from "@langchain/core/runnables";
import type { BaseLanguageModelInput } from "@langchain/core/language_models/base";
import type { BaseMessageChunk } from "@langchain/core/messages";

import type { IAiClient } from './IAiClient.js';
import type { ConversationMessage } from '../conversation/Message.js';
    
export class LangchainClient implements IAiClient {
  // Accept a RunnableInterface which might be the result of model.bindTools()
  private chatModel: RunnableInterface<BaseLanguageModelInput, BaseMessageChunk>;
  private modelIdentifier: string; // The specific model identifier being used
  private providerName: string; // The provider name (e.g., "openai", "anthropic")
    
  // Update constructor parameter type
  constructor(
    chatModel: RunnableInterface<BaseLanguageModelInput, BaseMessageChunk>,
    modelIdentifier: string,
    providerName?: string
  ) {
    this.chatModel = chatModel;
    this.modelIdentifier = modelIdentifier;
    
    // Determine provider name from chat model if not explicitly provided
    if (providerName) {
      this.providerName = providerName;
    } else {
      // Try to infer from the constructor name or model name
      const constructorName = chatModel.constructor.name.toLowerCase();
      if (constructorName.includes('openai')) {
        this.providerName = 'openai';
      } else if (constructorName.includes('anthropic') || modelIdentifier.includes('claude')) {
        this.providerName = 'anthropic';
      } else if (constructorName.includes('googlegenai') || constructorName.includes('gemini')) {
        this.providerName = 'google-genai';
      } else if (constructorName.includes('mistral')) {
        this.providerName = 'mistralai';
      } else if (constructorName.includes('fireworks')) {
        this.providerName = 'fireworks';
      } else {
        this.providerName = 'unknown';
      }
    }
  }

  async generateResponse(messages: ConversationMessage[]): Promise<string> {
    try {
      // Ensure messages are in the format LangChain expects (they should be if using BaseMessage)
      const response = await this.chatModel.invoke(messages);
      
      // Handle different types of response content
      if (typeof response.content === 'string') {
        // Simple string response
        return response.content;
      } else if (Array.isArray(response.content)) {
        // Handle array content (common with Anthropic tool usage)
        // Filter for text items first, then map to get the text content
        const textItems = response.content
          .filter((item): item is { type: "text"; text: string } => // Type guard for clarity
            typeof item === 'object' && item !== null && item.type === 'text' && typeof item.text === 'string'
          );
         
        const textContent = textItems.map(item => item.text).join('\n');
           
        if (textContent) {
          // Return concatenated text parts if found
          console.log('[LangchainClient] Extracted text from complex response:', textContent);
          return textContent;
        } else if (response.content.length === 0) {
           // Handle empty array response specifically
           console.warn('[LangchainClient] AI response content was an empty array.');
           return "[AI response was empty]"; // Placeholder for empty array
        } else {
          // If array contains non-text elements (like tool_calls) but no text
          console.warn('[LangchainClient] AI response content is a non-empty array without text:', response.content);
          // Return a placeholder or stringify the structure for debugging
          return `[AI response contained non-text elements: ${JSON.stringify(response.content)}]`;
        }
      } else {
        // Handle other unexpected non-string, non-array content
        console.warn('[LangchainClient] AI response content is not a string or array:', response.content);
        return JSON.stringify(response.content); // Fallback stringify
      }
    } catch (error) {
      console.error(`Langchain AI request failed for model ${this.modelIdentifier}:`, error);
      throw new Error(`AI request failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  getModelName(): string {
    return this.modelIdentifier;
  }
  
  getProvider(): string {
    return this.providerName;
  }
}
</file>

<file path="src/conversation/execution/ToolExecutor.ts">
import type { ServerManager } from '../../ServerManager.js';
import type { ToolExecutionResult } from '../../types.js'; // Import result type

// Type for the tool calls expected by this executor
export type ToolCallRequest = {
    id: string;
    name: string;
    args: Record<string, any>;
};

export class ToolExecutor {
    private serverManager: ServerManager;

    constructor(serverManager: ServerManager) {
        this.serverManager = serverManager;
    }

    /**
     * Executes a set of tool calls in parallel.
     * @param toolCalls Array of tool calls, each including an `id`, `name`, and `args`.
     * @returns Promise that resolves to a map of tool call IDs to their string results.
     */
    public async executeToolCalls(
        toolCalls: ToolCallRequest[]
    ): Promise<Map<string, string>> {
        const results = new Map<string, string>();
        const executions = toolCalls.map(async (toolCall) => {
            const toolCallId = toolCall.id;
            const toolName = toolCall.name;
            const toolArgs = toolCall.args;

            try {
                const serverName = this.serverManager.findToolProvider(toolName);
                if (!serverName) {
                    const errorMessage = `No server found providing tool '${toolName}'.`;
                    console.warn(`[ToolExecutor] ${errorMessage}`);
                    results.set(toolCallId, errorMessage);
                    return; // Skip execution for this tool call
                }

                console.log(`[ToolExecutor] Executing tool '${toolName}' (ID: ${toolCallId}) on server '${serverName}'...`);

                // Execute the tool using name and args from toolCall
                // Pass showProgress: true for REPL-like feedback if desired, or make it configurable
                const executionResult: ToolExecutionResult = await this.serverManager.executeTool(
                    serverName,
                    toolName,
                    toolArgs,
                    { showProgress: false } // Assuming progress shown elsewhere or not needed here
                );

                // Format the result content
                let resultContent: string;
                if (executionResult.isError) {
                    resultContent = `Error: ${executionResult.errorMessage || 'Unknown error.'}`;
                } else if (Array.isArray(executionResult.toolResult)) {
                    // Handle content array from the tool result
                    resultContent = executionResult.toolResult
                        .map(item => {
                            // Ensure item is an object before accessing properties
                            if (typeof item === 'object' && item !== null) {
                                if (item.type === 'text') {
                                    return item.text;
                                } else if (item.type === 'image') {
                                    return `[Image: ${item.mimeType}]`; // Placeholder for image
                                }
                            }
                            // Fallback for non-object items or unknown types
                            return JSON.stringify(item);
                        })
                        .join('\n');
                } else if (typeof executionResult.toolResult === 'object' && executionResult.toolResult !== null) {
                    resultContent = JSON.stringify(executionResult.toolResult, null, 2);
                } else {
                    resultContent = String(executionResult.toolResult ?? 'No content returned.'); // Use ?? for null/undefined
                }

                console.log(`[ToolExecutor] Result for tool ${toolCallId} (${toolName}):`, JSON.stringify(resultContent).substring(0, 100) + '...');
                results.set(toolCallId, resultContent);

            } catch (error) {
                const errorMessage = `[ToolExecutor] Failed to execute tool '${toolCall.name}' (ID: ${toolCallId}): ${error instanceof Error ? error.message : String(error)}`;
                console.error(errorMessage);
                results.set(toolCallId, errorMessage); // Store error message as result
            }
        });

        // Wait for all tool executions to complete
        await Promise.all(executions);
        return results;
    }
}
</file>

<file path="src/conversation/persistence/ConversationPersistenceService.ts">
import * as fs from 'node:fs';
import * as path from 'node:path';
import type { ConversationState } from '../ConversationState.js';
import type { ConversationMessage } from '../Message.js'; // Assuming Message types are needed for serialization structure

// Interface for serialized conversations (can be moved to types.ts later)
export interface SerializedConversation {
  id: string;
  title: string;
  modelName: string;
  provider: string;
  createdAt: string;
  updatedAt: string;
  messages: {
    role: string;
    content: string;
    hasToolCalls?: boolean;
    pendingToolCalls?: boolean;
    // Add other potential fields from LangChain messages if needed for restoration
    name?: string; // For ToolMessage
    tool_call_id?: string; // For ToolMessage
    additional_kwargs?: Record<string, any>; // For AIMessage
    tool_calls?: any[]; // For AIMessage
  }[];
}


export class ConversationPersistenceService {
    private conversationsDir: string;
    // Use a Map to store debounce timeouts per conversation ID
    private saveDebounceTimeouts: Map<string, NodeJS.Timeout> = new Map();
    private readonly SAVE_DEBOUNCE_MS = 1000; // 1 second debounce

    constructor(baseDir: string) {
        this.conversationsDir = path.join(baseDir, 'conversations');
        this.ensureConversationsDir();
    }

    /**
     * Ensures the conversations directory exists
     */
    private ensureConversationsDir(): void {
        try {
            if (!fs.existsSync(this.conversationsDir)) {
                fs.mkdirSync(this.conversationsDir, { recursive: true });
                console.log(`[Persistence] Created conversations directory at: ${this.conversationsDir}`);
            }
        } catch (error) {
            console.error(`[Persistence] Error creating conversations directory:`, error);
            // Depending on requirements, might want to throw or handle differently
        }
    }

    /**
     * Saves the current conversation state to disk, debounced.
     * @param conversationId The ID of the conversation to save.
     * @param state The current ConversationState.
     * @param modelName The name of the AI model used.
     * @param provider The name of the AI provider used.
     */
    public saveConversation(
        conversationId: string,
        state: ConversationState,
        modelName: string,
        provider: string
    ): void {
        // Clear existing timeout for this specific conversation ID
        const existingTimeout = this.saveDebounceTimeouts.get(conversationId);
        if (existingTimeout) {
            clearTimeout(existingTimeout);
        }

        // Set a new debounce timeout for this conversation ID
        const newTimeout = setTimeout(() => {
            this._performSave(conversationId, state, modelName, provider);
            // Remove the timeout entry after execution
            this.saveDebounceTimeouts.delete(conversationId);
        }, this.SAVE_DEBOUNCE_MS);

        // Store the new timeout
        this.saveDebounceTimeouts.set(conversationId, newTimeout);
    }

    /**
     * Performs the actual saving logic.
     */
    private _performSave(
        conversationId: string,
        state: ConversationState,
        modelName: string,
        provider: string
    ): void {
         try {
            const messages = state.getMessages(); // Get all messages including system

            // Don't save if there are no non-system messages
            if (state.getHistoryWithoutSystemPrompt().length === 0) {
                console.log(`[Persistence] Skipping save for empty conversation: ${conversationId}`);
                return;
            }

            // Generate a title from the first few user messages
            let title = 'New Conversation';
            const userMessages = state.getHistoryWithoutSystemPrompt().filter(m => m._getType() === 'human');

            if (userMessages.length > 0) {
                const firstMessageContent = userMessages[0].content;
                const firstMessage = typeof firstMessageContent === 'string'
                    ? firstMessageContent
                    : JSON.stringify(firstMessageContent); // Handle complex content
                title = firstMessage.length > 50
                    ? firstMessage.substring(0, 47) + '...'
                    : firstMessage;
            }

            // Check if file exists to get createdAt time
            const filePath = path.join(this.conversationsDir, `${conversationId}.json`);
            let createdAt = new Date().toISOString();
            if (fs.existsSync(filePath)) {
                try {
                    const existingData = fs.readFileSync(filePath, 'utf-8');
                    const existingConv = JSON.parse(existingData) as SerializedConversation;
                    createdAt = existingConv.createdAt || createdAt; // Use existing createdAt if available
                } catch (readError) {
                    console.warn(`[Persistence] Could not read existing file to preserve createdAt for ${conversationId}:`, readError);
                }
            }


            // Create serialized conversation
            const conversation: SerializedConversation = {
                id: conversationId,
                title,
                modelName: modelName,
                provider: provider,
                createdAt: createdAt, // Preserve or set new
                updatedAt: new Date().toISOString(), // Always update timestamp
                messages: messages.map(msg => ({ // Serialize all messages
                    role: msg._getType(),
                    content: typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content), // Ensure content is stringified if complex
                    // Include other relevant properties from LangChain message types
                    hasToolCalls: (msg as any).hasToolCalls,
                    pendingToolCalls: (msg as any).pendingToolCalls,
                    name: (msg as any).name, // For ToolMessage
                    tool_call_id: (msg as any).tool_call_id, // For ToolMessage
                    additional_kwargs: (msg as any).additional_kwargs, // For AIMessage
                    tool_calls: (msg as any).tool_calls // For AIMessage
                }))
            };

            // Write to file
            fs.writeFileSync(filePath, JSON.stringify(conversation, null, 2), 'utf-8');
            console.log(`[Persistence] Saved conversation to: ${filePath}`);
        } catch (error) {
            console.error('[Persistence] Error saving conversation:', error);
        }
        // Timeout removal is handled in the setTimeout callback in saveConversation
    }


    /**
     * Loads a conversation from disk.
     * @param conversationId The ID of the conversation to load.
     * @returns The raw SerializedConversation data or null if loading fails.
     */
    public loadConversation(conversationId: string): SerializedConversation | null {
        try {
            const filePath = path.join(this.conversationsDir, `${conversationId}.json`);

            if (!fs.existsSync(filePath)) {
                console.error(`[Persistence] Conversation file not found: ${filePath}`);
                return null;
            }

            const conversationData = fs.readFileSync(filePath, 'utf-8');
            const conversation: SerializedConversation = JSON.parse(conversationData);

            console.log(`[Persistence] Loaded conversation data: ${conversation.title} (${conversationId})`);
            return conversation; // Return the raw data

        } catch (error) {
            console.error('[Persistence] Error loading conversation:', error);
            return null;
        }
    }

    /**
     * Lists metadata for all saved conversations.
     * @returns Array of conversation metadata (excluding messages).
     */
    public listConversations(): Omit<SerializedConversation, 'messages'>[] {
        try {
            this.ensureConversationsDir(); // Ensure directory exists before reading

            const files = fs.readdirSync(this.conversationsDir)
                .filter(file => file.endsWith('.json'));

            const conversations = files.map(file => {
                try {
                    const filePath = path.join(this.conversationsDir, file);
                    const data = fs.readFileSync(filePath, 'utf-8');
                    const conversation: SerializedConversation = JSON.parse(data);

                    // Return metadata only
                    const { messages, ...metadata } = conversation; // Destructure to exclude messages
                    return metadata;
                } catch (error) {
                    console.warn(`[Persistence] Error parsing conversation file metadata: ${file}`, error);
                    return null;
                }
            }).filter((c): c is Omit<SerializedConversation, 'messages'> => c !== null); // Type assertion and filter nulls

            // Sort by updatedAt, most recent first
            return conversations.sort((a, b) =>
                new Date(b.updatedAt || 0).getTime() - new Date(a.updatedAt || 0).getTime()
            );
        } catch (error) {
            console.error('[Persistence] Error listing conversations:', error);
            return [];
        }
    }

    /**
     * Renames a conversation file by updating its title metadata.
     * @param conversationId The ID of the conversation to rename.
     * @param newTitle The new title for the conversation.
     * @returns true if successful, false otherwise.
     */
    public renameConversation(conversationId: string, newTitle: string): boolean {
        try {
            const filePath = path.join(this.conversationsDir, `${conversationId}.json`);

            if (!fs.existsSync(filePath)) {
                console.error(`[Persistence] Conversation file not found for rename: ${filePath}`);
                return false;
            }

            const conversationData = fs.readFileSync(filePath, 'utf-8');
            const conversation: SerializedConversation = JSON.parse(conversationData);

            // Update title and timestamp
            conversation.title = newTitle;
            conversation.updatedAt = new Date().toISOString();

            // Write updated conversation back to file
            fs.writeFileSync(filePath, JSON.stringify(conversation, null, 2), 'utf-8');
            console.log(`[Persistence] Renamed conversation ${conversationId} to: ${newTitle}`);

            return true;
        } catch (error) {
            console.error('[Persistence] Error renaming conversation:', error);
            return false;
        }
    }

    /**
     * Deletes a conversation file.
     * @param conversationId The ID of the conversation to delete.
     * @returns true if successful, false otherwise.
     */
    public deleteConversation(conversationId: string): boolean {
        try {
            const filePath = path.join(this.conversationsDir, `${conversationId}.json`);

            if (!fs.existsSync(filePath)) {
                // If file doesn't exist, consider it successfully "deleted"
                console.warn(`[Persistence] Conversation file not found for deletion (already deleted?): ${filePath}`);
                return true;
            }

            // Delete the file
            fs.unlinkSync(filePath);
            console.log(`[Persistence] Deleted conversation file: ${conversationId}.json`);

            return true;
        } catch (error) {
            console.error('[Persistence] Error deleting conversation:', error);
            return false;
        }
    }
}
</file>

<file path="src/conversation/prompts/PromptFactory.ts">
import type { Tool } from '@modelcontextprotocol/sdk/types.js';

export class PromptFactory {

    // --- Tool Related Prompts ---

    public static readonly TOOL_RESULTS_PROMPT = `You have received results from the tool(s) you called previously (shown immediately above).
Analyze these results carefully.
Based *only* on these results and the original user request:
1. If the results provide the necessary information to fully answer the user's original request, formulate and provide the final answer now. Do NOT call any more tools unless absolutely necessary for clarification based *specifically* on the results received.
2. If the results are insufficient or indicate an error, decide if another *different* tool call is needed to achieve the original goal. If so, call the tool using the <<<TOOL_CALL>>>...<<<END_TOOL_CALL>>> format.
3. If you cannot proceed further, explain why.`;

    public static readonly INVALID_TOOL_FORMAT_PROMPT = `Correction Request:
You attempted to call a tool, but the format was incorrect.
Remember to use the exact format including delimiters and a valid JSON object with 'name' (string) and 'arguments' (object) fields.

Your invalid attempt contained:
{invalid_content}

Please correct the format and try the tool call again, or provide a text response if you no longer need the tool.`;

    /**
     * Generates the system prompt including tool definitions.
     * @param allTools Array of available MCP Tools.
     * @returns The generated system prompt string.
     */
    public static createToolSystemPrompt(allTools: Tool[]): string {
        // Basic prompt structure derived from finish_implementation.md
        let prompt = `You are a helpful assistant with access to tools. Use tools EXACTLY according to their descriptions and required format.

**Core Instructions for Tool Use:**

1.  **Address the Full Request:** Plan and execute all necessary steps sequentially using tools. If generating information *and* performing an action (like saving), **include the key information/summary in your response** along with action confirmation.
2.  **Execution Model & Reacting to Results:**
    *   **Dispatch:** All tools you call in a single response turn are dispatched *before* you receive results for *any* of them.
    *   **Results:** You *will* receive the results for all dispatched tools in the *next* conversation turn.
    *   **No Same-Turn Chaining:** Because of the dispatch timing, **you cannot use the result of one tool as input for another tool within the *same* response turn.** Plan sequential, dependent calls across multiple turns.
    *   **Verification & Adaptation:** Carefully review tool results when you receive them. Verify success/failure, extract data, and **change your plan or response if the results require it.**
3.  **Be Truthful & Cautious:** Only confirm actions (e.g., "file saved") if the tool result explicitly confirms success. Report errors. Be careful with tools that modify external systems.
4.  **Use Correct Format:** Use the precise \`<<<TOOL_CALL>>>...<<<END_TOOL_CALL>>>\` format with valid JSON (\`name\`, \`arguments\`) for all tool calls.

# Tool Descriptions
`;

        // Add tool descriptions
        if (allTools.length === 0) {
            prompt += "No tools are currently available.\n";
        } else {
            for (const tool of allTools) {
                prompt += `## ${tool.name}\n`;
                prompt += `${tool.description || 'No description provided.'}\n\n`;

                // Add schema information if available
                if (tool.input_schema) {
                    prompt += "**Arguments Schema:**\n```json\n";
                    try {
                        // Attempt to pretty-print if it's a JSON string or object
                        const schemaObj = typeof tool.input_schema === 'string'
                            ? JSON.parse(tool.input_schema)
                            : tool.input_schema;
                        prompt += JSON.stringify(schemaObj, null, 2);
                    } catch (e) {
                        // Fallback to string representation if parsing fails
                        prompt += String(tool.input_schema);
                    }
                    prompt += "\n```\n\n";
                }
            }
        }

        // Add tool usage format section
        prompt += `
When you need to use a tool, you MUST format your request exactly as follows, including the delimiters:
<<<TOOL_CALL>>>
{
  "name": "tool_name",
  "arguments": {
    "arg1": "value1",
    "arg2": "value2"
  }
}
<<<END_TOOL_CALL>>>

Important:
- Only include ONE tool call JSON block per delimiter section. Use multiple sections for multiple parallel calls in one turn.
- You can include explanatory text before or after the tool call block.
- If no tool is needed, just respond normally.`;

        return prompt;
    }

    // --- Verification Related Prompts ---

    public static readonly VERIFICATION_CRITERIA_PROMPT = `Based on the following user request, list concise, verifiable criteria for a successful response.
Focus on key actions, information requested, and constraints mentioned.
Output ONLY the criteria list, one criterion per line, starting with '- '. Do not include any other text.

User Request:
{user_request}

Criteria:`;

    public static readonly VERIFICATION_PROMPT = `You are a strict evaluator. Verify if the 'Relevant Conversation Sequence' below meets ALL the 'Success Criteria' based on the 'Original User Request'.

Original User Request:
{original_request}

Success Criteria:
{criteria}

Relevant Conversation Sequence (User messages, Assistant actions/responses, Tool results):
{relevant_history_sequence}

Instructions:
1. Carefully review the *entire sequence* including user feedback, assistant actions (tool calls/results shown), and the final response.
2. Compare this sequence against each point in the 'Success Criteria'.
3. Determine if the *outcome* of the assistant's actions and the final response *fully and accurately* satisfy *all* criteria.
4. Output ONLY the raw JSON object. Your entire response must start with \`{\` and end with \`}\`.
5. The JSON object must have the following structure: \`{"passes": boolean, "feedback": "string (provide concise feedback ONLY if passes is false, explaining which criteria failed and why, referencing the assistant's actions/responses if relevant)"}\`
6. ABSOLUTELY DO NOT include any other text, explanations, apologies, introductory phrases, or markdown formatting like \`\`\`json or \`\`\`.`;

    public static readonly VERIFICATION_FAILURE_PROMPT = `Your previous response failed verification based on the following feedback:
{feedback}

Revise your response to fully address the original request and meet all success criteria based on this feedback. Provide only the corrected response.`;

    // --- Compaction Related Prompt ---

    public static readonly CONVERSATION_COMPACTION_PROMPT = `You are an expert conversation summarizer. Analyze the following conversation history and provide a concise summary. Focus on:
- Key user requests and goals.
- Important information discovered or generated.
- Decisions made.
- Final outcomes or current status.
- Any critical unresolved questions or next steps mentioned.

Keep the summary factual and brief, retaining essential context for the conversation to continue.

Conversation History:
{history_string}

Concise Summary:`;

    // --- Helper methods to fill placeholders (optional but can improve type safety/readability) ---

    public static fillVerificationCriteriaPrompt(userRequest: string): string {
        return this.VERIFICATION_CRITERIA_PROMPT.replace('{user_request}', userRequest);
    }

    public static fillVerificationPrompt(originalRequest: string, criteria: string, relevantSequence: string): string {
        return this.VERIFICATION_PROMPT
            .replace('{original_request}', originalRequest)
            .replace('{criteria}', criteria)
            .replace('{relevant_history_sequence}', relevantSequence);
    }

     public static fillVerificationFailurePrompt(feedback: string): string {
        return this.VERIFICATION_FAILURE_PROMPT.replace('{feedback}', feedback);
    }

    public static fillCompactionPrompt(historyString: string): string {
        return this.CONVERSATION_COMPACTION_PROMPT.replace('{history_string}', historyString);
    }

    public static fillInvalidToolFormatPrompt(invalidContent: string): string {
        return this.INVALID_TOOL_FORMAT_PROMPT.replace('{invalid_content}', invalidContent);
    }
}
</file>

<file path="src/conversation/verification/VerificationService.ts">
import type { IAiClient } from '../../ai/IAiClient.js';
import { PromptFactory } from '../prompts/PromptFactory.js';
import { SystemMessage, HumanMessage } from '../Message.js';
import type { ConversationMessage } from '../Message.js';

export interface VerificationResult {
    passes: boolean;
    feedback: string;
}

export class VerificationService {
    private aiClient: IAiClient;
    private promptFactory: typeof PromptFactory;

    constructor(aiClient: IAiClient) {
        this.aiClient = aiClient;
        this.promptFactory = PromptFactory; // Use static prompts
    }

    /**
     * Generates verification criteria for a user request using the AI client.
     * @param userInput The original user input/request.
     * @returns The generated verification criteria string.
     */
    public async generateVerificationCriteria(userInput: string): Promise<string> {
        console.log('[VerificationService] Generating verification criteria...');
        try {
            // Create the criteria prompt using the factory
            const promptText = this.promptFactory.fillVerificationCriteriaPrompt(userInput);

            // Create a temporary message list for this specific AI call
            const criteriaMessages: ConversationMessage[] = [
                new SystemMessage("You are a helpful assistant that generates verification criteria."), // System context for this task
                new HumanMessage(promptText)
            ];

            // Call the AI client
            const criteriaResponse = await this.aiClient.generateResponse(criteriaMessages);
            console.log('[VerificationService] Generated criteria:', criteriaResponse);
            return criteriaResponse;
        } catch (error) {
            console.error('[VerificationService] Error generating verification criteria:', error);
            // Provide a default fallback criteria on error
            return '- Respond to the user\'s request accurately.\n- Provide relevant information.';
        }
    }

    /**
     * Verifies an AI response against the criteria using the AI client.
     * @param originalRequest The original user request.
     * @param criteria The verification criteria.
     * @param relevantSequence The formatted conversation sequence to verify.
     * @returns Object with verification result (`passes`) and `feedback`.
     */
    public async verifyResponse(
        originalRequest: string,
        criteria: string,
        relevantSequence: string
    ): Promise<VerificationResult> {
        console.log('[VerificationService] Verifying response against criteria...');

        try {
            // Create the verification prompt using the factory
            const promptText = this.promptFactory.fillVerificationPrompt(originalRequest, criteria, relevantSequence);

            // Create a temporary message list for this specific AI call
            const verificationMessages: ConversationMessage[] = [
                new SystemMessage("You are a strict evaluator that verifies responses against criteria and returns JSON."), // System context for this task
                new HumanMessage(promptText)
            ];

            // Call the AI client
            const verificationResponse = await this.aiClient.generateResponse(verificationMessages);

            // Attempt to parse the JSON response from the AI
            try {
                const result = JSON.parse(verificationResponse);
                if (typeof result === 'object' && result !== null && 'passes' in result) {
                    console.log('[VerificationService] Verification result:', result.passes ? 'PASSED' : 'FAILED');
                    if (!result.passes) {
                        console.log('[VerificationService] Feedback:', result.feedback);
                    }
                    return {
                        passes: Boolean(result.passes),
                        feedback: result.feedback || ''
                    };
                } else {
                    console.warn('[VerificationService] Invalid verification response format:', verificationResponse);
                    return { passes: true, feedback: 'Invalid format from verifier' }; // Default to passing but note format issue
                }
            } catch (parseError) {
                console.error('[VerificationService] Error parsing verification response JSON:', parseError);
                console.log('[VerificationService] Raw verification response:', verificationResponse);
                // Fail verification if the response format is invalid
                return { passes: false, feedback: 'Failed to parse verifier response JSON. Assuming failure.' };
            }
        } catch (aiError) {
            console.error('[VerificationService] Error during AI verification call:', aiError);
            // Fail verification if the verifier AI call fails
            return { passes: false, feedback: `Verifier AI call failed: ${aiError instanceof Error ? aiError.message : String(aiError)}` };
        }
    }

     /**
      * Generates a revised response based on verification failure feedback.
      * @param currentHistory The conversation history leading up to the failed response.
      * @param failedResponseContent The content of the response that failed verification.
      * @param feedback The feedback from the verification process.
      * @returns The revised response content from the AI.
      * @throws {Error} If the AI call for correction fails.
      */
     public async generateCorrectedResponse(
         currentHistory: ConversationMessage[],
         failedResponseContent: string,
         feedback: string
     ): Promise<string> {
         console.log('[VerificationService] Generating corrected response...');

         // Generate correction prompt using the factory
         const correctionPromptText = this.promptFactory.fillVerificationFailurePrompt(feedback);

         // Create messages for the correction call:
         // History up to the point *before* the failed final response + the failed response + the correction request
         const correctionMessages = [
             ...currentHistory, // History includes the failed response added in the loop
             new HumanMessage(correctionPromptText) // Add the correction request
         ];

         try {
             const correctedResponse = await this.aiClient.generateResponse(correctionMessages);
             console.log('[VerificationService] Generated corrected response after verification failure.');
             return correctedResponse;
         } catch (error) {
             console.error('[VerificationService] Error generating corrected response:', error);
             throw new Error(`Failed to generate corrected response: ${error instanceof Error ? error.message : String(error)}`);
         }
     }
}
</file>

<file path="src/conversation/ConversationManager.ts">
import { v4 as uuidv4 } from 'uuid'; // Keep UUID import for new conversation IDs
import type { IAiClient } from '../ai/IAiClient.js';
import type { ServerManager } from '../ServerManager.js';
import { ConversationState } from './ConversationState.js';
import { HumanMessage, AIMessage, SystemMessage, ToolMessage } from './Message.js';
import type { ConversationMessage } from './Message.js';
import type { Tool } from '@modelcontextprotocol/sdk/types.js'; // MCP Tool type
import { ToolParser } from './ToolParser.js'; // ParsedToolCall import removed as it's internal to ToolParser now
import { AiClientFactory } from '../ai/AiClientFactory.js';
import type { AiProviderConfig, ProviderModelsStructure } from '../types.js';
import { ConversationPersistenceService, type SerializedConversation } from './persistence/ConversationPersistenceService.js';
import { PromptFactory } from './prompts/PromptFactory.js';
import { ToolExecutor, type ToolCallRequest } from './execution/ToolExecutor.js';
import { VerificationService, type VerificationResult } from './verification/VerificationService.js'; // Import VerificationService

// __filename, __dirname, baseDir removed

// SerializedConversation interface moved to persistence service

export class ConversationManager {
  private state: ConversationState;
  private aiClient: IAiClient;
  private serverManager: ServerManager;
  private persistenceService: ConversationPersistenceService;
  private promptFactory: typeof PromptFactory; // Store static class/type
  private toolExecutor: ToolExecutor;
  private verificationService: VerificationService; // Add VerificationService instance
  private allTools: Tool[] = []; // Cache of all available tools
  private toolsLastUpdated: number = 0; // Timestamp of when tools were last updated
  private readonly TOOLS_CACHE_TTL_MS = 10 * 60 * 1000; // 10 minutes cache TTL
  private aiClientFactory: typeof AiClientFactory; // Store the factory reference for switching models

  // Persistence properties removed (handled by persistenceService)
  private currentConversationId: string; // Keep track of the active conversation ID

  // Prompts removed (handled by promptFactory)

  constructor(
    aiClient: IAiClient,
    serverManager: ServerManager,
    persistenceService: ConversationPersistenceService,
    toolExecutor: ToolExecutor,
    verificationService: VerificationService // Inject VerificationService
  ) {
    this.aiClient = aiClient;
    this.serverManager = serverManager;
    this.persistenceService = persistenceService;
    this.toolExecutor = toolExecutor;
    this.verificationService = verificationService; // Store VerificationService instance
    this.promptFactory = PromptFactory; // Assign static class
    this.state = new ConversationState(); // Initialize with no system prompt initially

    // Store the factory reference for switching models
    this.aiClientFactory = AiClientFactory;

    // Generate a new conversation ID for this session
    // TODO: Consider loading the last active conversation instead?
    this.currentConversationId = uuidv4(); // Keep uuid import for this

    // Immediately fetch all tools to prime the cache
    this.refreshToolsCache().catch(err => {
      console.warn('Failed to initialize tools cache:', err);
    });
  }

  // ensureConversationsDir removed (handled by persistenceService)

  /**
   * Saves the current conversation state using the persistence service.
   */
  private saveConversation(): void {
    this.persistenceService.saveConversation(
        this.currentConversationId,
        this.state,
        this.getAiClientModelName(),
        this.getAiProviderName()
    );
  }

  /**
   * Loads a conversation from the persistence service and updates the state.
   * @param conversationId The ID of the conversation to load.
   * @returns true if successful, false otherwise.
   */
  public loadConversation(conversationId: string): boolean {
    const loadedData = this.persistenceService.loadConversation(conversationId);
    if (!loadedData) {
        return false;
    }

    try {
        // Clear current state before loading
        this.state.clearHistory();
        this.currentConversationId = loadedData.id;

        // Reconstruct messages from loaded data
        for (const msgData of loadedData.messages) {
            let message: ConversationMessage | null = null;
            let content: string | Record<string, any>[] = msgData.content;

            // Attempt to parse content if it looks like JSON (for complex AI/Tool messages)
            if (typeof content === 'string' && (content.startsWith('{') || content.startsWith('['))) {
                try {
                    content = JSON.parse(content);
                } catch {
                    // Ignore parsing error, keep as string
                }
            }

            switch (msgData.role) {
                case 'system':
                    // System prompt is handled separately by setSystemPrompt
                    // If we load a persisted system prompt, set it here
                    if (typeof content === 'string') {
                        this.state.setSystemPrompt(content);
                    } else {
                         console.warn(`[ConversationManager] Skipping non-string system message content during load: ${JSON.stringify(content)}`);
                    }
                    continue; // Don't add system message to history array directly
                case 'human':
                    // Human message content should always be string according to LangChain types
                    if (typeof content === 'string') {
                        message = new HumanMessage(content);
                    } else {
                         console.warn(`[ConversationManager] Skipping non-string human message content during load: ${JSON.stringify(content)}`);
                    }
                    break;
                case 'ai':
                    // AIMessage constructor handles string or array content
                    message = new AIMessage(content, {
                        hasToolCalls: msgData.hasToolCalls,
                        pendingToolCalls: msgData.pendingToolCalls,
                        additional_kwargs: msgData.additional_kwargs,
                        tool_calls: msgData.tool_calls
                    });
                    break;
                case 'tool':
                     // ToolMessage content should be string
                     if (typeof content === 'string' && msgData.tool_call_id) {
                        message = new ToolMessage(
                            content,
                            msgData.tool_call_id,
                            msgData.name // Optional tool name
                        );
                    } else {
                         console.warn(`[ConversationManager] Skipping invalid tool message during load:`, msgData);
                    }
                    break;
                default:
                     console.warn(`[ConversationManager] Skipping unknown message role during load: ${msgData.role}`);
            }

            if (message) {
                this.state.addMessage(message); // Add directly to history array
            }
        }

        console.log(`[ConversationManager] Loaded conversation: ${loadedData.title}`);
        return true;
    } catch (error) {
        console.error('[ConversationManager] Error reconstructing conversation state:', error);
        // Clear potentially corrupted state
        this.state.clearHistory();
        this.currentConversationId = uuidv4(); // Reset to new ID
        return false;
    }
  }

  // listConversations implementation removed (delegated below)

  /**
   * Creates a new empty conversation, clearing state and generating a new ID.
   */
  public newConversation(): void {
    this.state.clearHistory();
    this.currentConversationId = uuidv4(); // Generate new ID using uuid
    console.log(`[ConversationManager] Created new conversation with ID: ${this.currentConversationId}`);
    // Initial save might not be necessary until first message
  }

  // renameConversation implementation removed (delegated below)
  // deleteConversation implementation removed (delegated below)


  /**
   * Switch the AI client to a different provider and model.
   * @param providerConfig The provider configuration to use.
   * @param providerModels Available models for providers (needed by factory).
   * @returns The actual model name used by the new client.
   */
  public switchAiClient(
    providerConfig: AiProviderConfig,
    providerModels: ProviderModelsStructure
  ): string { // No longer needs to be async if getAllTools is sync or cached effectively
    try {
      // Get tools (potentially from cache)
      // Assuming getAllTools is efficient enough to call here,
      // otherwise, the factory might need to fetch them if stale.
      const tools = this.allTools; // Use cached tools for now

      // Create the new client using the factory
      const newClient = this.aiClientFactory.createClient(providerConfig, providerModels, tools);

      this.aiClient = newClient;

      // Clear conversation history and start a new conversation ID on model switch
      this.newConversation(); // This clears state and sets a new ID

      const modelName = newClient.getModelName();
      console.log(`[ConversationManager] Switched AI client to: ${providerConfig.provider} (${modelName})`);
      return modelName;
    } catch (error) {
      console.error(`[ConversationManager] Failed to switch AI client:`, error instanceof Error ? error.message : String(error));
      // Optionally revert to the old client if needed, but for now, just throw
      throw error; // Re-throw to let the caller handle it (e.g., UI feedback)
    }
  }

  /**
   * Gets the model name identifier from the underlying AI client.
   */
  public getAiClientModelName(): string {
    return this.aiClient.getModelName();
  }

  /**
   * Gets the provider name identifier from the underlying AI client.
   */
  public getAiProviderName(): string {
    return this.aiClient.getProvider?.() || 'unknown';
  }

  /**
   * Refreshes the tools cache by fetching all tools from connected servers.
   * @returns Promise that resolves when the cache is refreshed.
   */
  private async refreshToolsCache(): Promise<Tool[]> {
    try {
      this.allTools = await this.serverManager.getAllTools();
      this.toolsLastUpdated = Date.now();
      console.log(`[ConversationManager] Refreshed tools cache: ${this.allTools.length} tools available.`);
      return this.allTools;
    } catch (error) {
      console.error('[ConversationManager] Error refreshing tools cache:', error);
      // Re-throw or return empty array based on preference
      throw error;
    }
  }

  /**
   * Gets all available tools, refreshing the cache if necessary.
   * @returns Promise that resolves to an array of all available tools.
   */
  private async getAllTools(): Promise<Tool[]> {
    const now = Date.now();
    if (now - this.toolsLastUpdated > this.TOOLS_CACHE_TTL_MS || this.allTools.length === 0) {
      return this.refreshToolsCache();
    }
    return this.allTools;
  }

  // generateToolSystemPrompt removed (handled by promptFactory)

  // executeToolCalls removed (handled by toolExecutor)

  /**
   * Creates a message to send to the AI with tool results.
   * @param toolResults Map of tool call IDs to results.
   * @returns Human-readable message for the AI.
   */
  private createToolResultsMessage(toolResults: Map<string, string>): string {
    // Use the prompt from the factory
    let message = this.promptFactory.TOOL_RESULTS_PROMPT;
    // Note: The current prompt doesn't actually use the toolResults map directly.
    // It assumes the ToolMessages are already in the history.
    // If the prompt needed to dynamically include results, this method would format them.
    // For now, just returning the static prompt is correct based on its content.
    return message;
  }

  // generateVerificationCriteria removed (moved to VerificationService)
  // verifyResponse removed (moved to VerificationService)

  /**
   * Processes a user's message, interacts with the AI, handles tool calls, and performs verification.
   * @param userInput - The text input from the user.
   * @returns The AI's final response content for this turn as a string.
   */
  async processUserMessage(userInput: string): Promise<string> {
    console.log(`[ConversationManager] Processing user message: "${userInput}"`);

    // 1. Add user message and save
    this.state.addMessage(new HumanMessage(userInput));
    this.saveConversation();

    // 2. Prepare for AI call (criteria, system prompt, compaction)
    await this._prepareForAiCall(userInput);

    // 3. Initial AI call
    let currentResponseContent: string;
    try {
        currentResponseContent = await this._makeAiCall();
    } catch (error) {
        console.error("[ConversationManager] Error during initial AI interaction:", error);
        return `Sorry, I encountered an error: ${error instanceof Error ? error.message : String(error)}`;
    }

    // 4. Handle Tool Calls (Loop)
    currentResponseContent = await this._handleToolLoop(currentResponseContent);

    // 5. Handle Verification and Correction
    let finalResponseContent = await this._handleVerification(currentResponseContent);

    // 6. Add final AI response to state and save
    const finalAiMessage = new AIMessage(finalResponseContent, { hasToolCalls: false });
    this.state.addMessage(finalAiMessage);
    this.saveConversation();

    // 7. Return the final response content string
    return finalResponseContent;
  }

  /** Prepares the conversation state for an AI call (criteria, system prompt, compaction). */
  private async _prepareForAiCall(userInput: string): Promise<void> {
      // Generate verification criteria if needed
      if (!this.state.getVerificationState()) {
          const criteria = await this.verificationService.generateVerificationCriteria(userInput);
          this.state.setVerificationState(userInput, criteria);
      }

      // Generate the dynamic system prompt
      const tools = await this.getAllTools();
      const systemPrompt = this.promptFactory.createToolSystemPrompt(tools);
      this.state.setSystemPrompt(systemPrompt);

      // Compact history if needed
      const messages = this.state.getMessages();
      if (messages.length > 20) { // Example threshold
          await this.state.compactHistory(this.promptFactory.CONVERSATION_COMPACTION_PROMPT, this.aiClient);
          console.log(`[ConversationManager] History compacted. Current length: ${this.state.getMessages().length}`);
      }
  }

  /** Makes a call to the AI client with the current conversation history. */
  private async _makeAiCall(): Promise<string> {
      const messagesForAi = this.state.getMessages();
      const responseContent = await this.aiClient.generateResponse(messagesForAi);
      console.log(`[ConversationManager] AI Response (${this.aiClient.getModelName()}):`, responseContent.substring(0, 200) + (responseContent.length > 200 ? '...' : ''));
      return responseContent;
  }

  /** Handles the loop of detecting AI tool calls, executing them, and getting follow-up responses. */
  private async _handleToolLoop(initialResponseContent: string): Promise<string> {
      let currentResponseContent = initialResponseContent;
      let toolRound = 0;
      const maxToolRounds = 5; // Limit recursive tool calls
      let previousToolCallsString = ''; // Track previous calls to detect loops

      while (toolRound < maxToolRounds) {
          toolRound++;
          console.log(`[ConversationManager] --- Tool/Response Round ${toolRound} ---`);

          // --- Check for BOTH standard and MCP-style tool calls ---
          // Create the AIMessage object representing the AI's request for this round
          const aiMessageRequestingTools = new AIMessage(currentResponseContent);
          const standardToolCalls = (aiMessageRequestingTools.tool_calls || [])
              .filter((tc): tc is { id: string; name: string; args: Record<string, any> } => tc.id !== undefined);
          const mcpToolCalls = ToolParser.parseToolCalls(typeof currentResponseContent === 'string' ? currentResponseContent : JSON.stringify(currentResponseContent));

          if (standardToolCalls.length === 0 && mcpToolCalls.length === 0) {
              console.log("[ConversationManager] No tool calls (standard or MCP) found in AI response. Exiting tool loop.");
              break; // Exit loop if neither type is found
          }

          // Add the AI message *requesting* the tools to history
          // We will modify this specific object later
          aiMessageRequestingTools.hasToolCalls = true; // Mark that a request was made
          aiMessageRequestingTools.pendingToolCalls = true;
          this.state.addMessage(aiMessageRequestingTools); // Add the object to state
          this.saveConversation();

          let toolCallsToExecute: ToolCallRequest[] = [];
          let isUsingStandardCalls = false;

          if (standardToolCalls.length > 0) {
              // Prioritize standard calls if available
              console.log(`[ConversationManager] Found ${standardToolCalls.length} standard tool calls. Using standard mechanism.`);
              toolCallsToExecute = standardToolCalls.map(tc => ({ id: tc.id, name: tc.name, args: tc.args }));
              isUsingStandardCalls = true;
          } else {
              // Fallback to MCP calls if no standard calls found
              console.log(`[ConversationManager] Found ${mcpToolCalls.length} MCP-style tool calls. Using manual result formatting.`);
              toolCallsToExecute = mcpToolCalls.map(call => ({
                  id: `mcpcall-${Date.now()}-${Math.floor(Math.random() * 1000)}`, // Generate ID
                  name: call.name,
                  args: call.arguments
              }));
              isUsingStandardCalls = false;
          }

          // --- Loop Detection ---
          const currentToolCallsString = JSON.stringify(toolCallsToExecute.map(tc => ({ name: tc.name, args: tc.args })).sort((a, b) => a.name.localeCompare(b.name)));
          if (currentToolCallsString === previousToolCallsString) {
              console.warn(`[ConversationManager] Loop detected: AI requested the exact same tool calls again. Breaking tool loop.`);
              // Remove the pending AI message requesting tools, as we won't execute them
              this.state.removeLastMessageIfPendingAiToolCall(); // Need to add this method to ConversationState
              this.saveConversation();
              // Use the response content *before* this loop iteration as the final one
              currentResponseContent = aiMessageRequestingTools.content as string; // Assuming content is string here
              break; // Exit the tool loop
          }
          previousToolCallsString = currentToolCallsString;
          // --- End Loop Detection ---


          // Execute tools
          const toolResultsMap = await this.toolExecutor.executeToolCalls(toolCallsToExecute);
          // Now update the *specific message object* we added earlier
          aiMessageRequestingTools.pendingToolCalls = false; // Mark as done

          // --- Add results back to history ---
          if (isUsingStandardCalls) {
              // Use standard ToolMessage for standard calls
              console.log("[ConversationManager] Adding results using standard ToolMessage.");
              for (const executedCall of toolCallsToExecute) {
                  const result = toolResultsMap.get(executedCall.id) || `Error: Result not found for tool call ${executedCall.id}`;
                  this.state.addMessage(new ToolMessage(result, executedCall.id, executedCall.name));
              }
          } else {
              // Format results into a string and add as a *new* AIMessage for MCP calls
              console.log("[ConversationManager] Adding results as a formatted AIMessage.");
              let resultsString = "Tool results received:\n";
              for (const executedCall of toolCallsToExecute) {
                  const result = toolResultsMap.get(executedCall.id) || `Error: Result not found for tool call ${executedCall.id}`;
                  resultsString += `\n--- Tool: ${executedCall.name} ---\n`;
                  resultsString += result;
                  resultsString += `\n--- End Tool: ${executedCall.name} ---\n`;
              }
              // Add this formatted string as a new AI message turn
              this.state.addMessage(new AIMessage(resultsString.trim()));
          }
          this.saveConversation(); // Save after adding results

          // Make follow-up AI call
          try {
              currentResponseContent = await this._makeAiCall();
          } catch (error) {
              console.error(`[ConversationManager] Error during AI follow-up interaction (Round ${toolRound + 1}):`, error);
              const errorMessage = `Sorry, I encountered an error processing the tool results: ${error instanceof Error ? error.message : String(error)}`;
              this.state.addMessage(new AIMessage(errorMessage));
              this.saveConversation();
              currentResponseContent = errorMessage;
              break; // Exit loop on error
          }
      } // End while loop

      if (toolRound >= maxToolRounds) {
          console.warn(`[ConversationManager] Reached maximum tool call rounds (${maxToolRounds}). Proceeding with last response.`);
      }

      return currentResponseContent; // Return the last response content after the loop
  }

   /** Handles the verification process and potential correction call. */
   private async _handleVerification(responseContent: string): Promise<string> {
       const verificationState = this.state.getVerificationState();
       let finalResponseContent = responseContent;

       if (verificationState) {
           const { originalRequest, criteria } = verificationState;
           const relevantSequence = this.state.getRelevantSequenceForVerification();
           const verificationResult = await this.verificationService.verifyResponse(
               originalRequest,
               criteria,
               relevantSequence + `\n\nAssistant: ${finalResponseContent}` // Append final response for verification
           );

           // TODO: Attach verificationResult to the final AI message if needed for UI

           if (!verificationResult.passes) {
               console.log('[ConversationManager] Response verification failed. Retrying with feedback.');
               try {
                   // Add the feedback itself as a system message to the history
                   const feedbackMessage = `[System Feedback] Verification failed: ${verificationResult.feedback}`;
                   this.state.addMessage(new SystemMessage(feedbackMessage));
                   this.saveConversation(); // Save after adding feedback message

                   // Pass the history *including* the failed response AND the feedback message for context
                   const historyForCorrection = this.state.getMessages();
                   const correctedResponseContent = await this.verificationService.generateCorrectedResponse(
                       historyForCorrection, // History now includes the feedback message
                       finalResponseContent, // Pass the failed content
                       verificationResult.feedback
                   );

                   // --- Check if corrected response has tool calls ---
                   const correctedAiMessage = new AIMessage(correctedResponseContent);
                   const correctedToolCalls = (correctedAiMessage.tool_calls || [])
                       .filter((tc): tc is { id: string; name: string; args: Record<string, any> } => tc.id !== undefined);

                   if (correctedToolCalls.length > 0) {
                       console.log(`[ConversationManager] Corrected response contains ${correctedToolCalls.length} tool calls. Executing them.`);

                       // Add the corrected AI message (requesting tools) to history
                       correctedAiMessage.hasToolCalls = true;
                       correctedAiMessage.pendingToolCalls = true; // Will be set to false shortly
                       this.state.addMessage(correctedAiMessage);
                       this.saveConversation();

                       // Prepare tool calls for execution
                       const toolCallsToExecute: ToolCallRequest[] = correctedToolCalls.map(tc => ({
                           id: tc.id,
                           name: tc.name,
                           args: tc.args
                       }));

                       // Execute tools
                       const toolResultsMap = await this.toolExecutor.executeToolCalls(toolCallsToExecute);
                       correctedAiMessage.pendingToolCalls = false; // Mark as done

                       // Add tool results to history using standard ToolMessage
                       console.log("[ConversationManager] Adding results from corrected response using standard ToolMessage.");
                       for (const executedCall of toolCallsToExecute) {
                           const result = toolResultsMap.get(executedCall.id) || `Error: Result not found for tool call ${executedCall.id}`;
                           this.state.addMessage(new ToolMessage(result, executedCall.id, executedCall.name));
                       }
                       this.saveConversation(); // Save after adding results

                       // Make the final AI call after executing tools from the corrected response
                       console.log("[ConversationManager] Making final AI call after executing tools from corrected response.");
                       finalResponseContent = await this._makeAiCall(); // Update final content

                   } else {
                       // No tool calls in corrected response, just use it as the final content
                       console.log('[ConversationManager] Corrected response has no tool calls.');
                       finalResponseContent = correctedResponseContent;
                       // The main processUserMessage adds the final AIMessage at the end.
                   }
                   // --- End tool check for corrected response ---

               } catch (error) {
                   console.error('[ConversationManager] Error during verification correction phase:', error);
                   // Keep the uncorrected response if retry fails
                   // finalResponseContent remains the original responseContent before correction attempt
               }
           }
       }
       return finalResponseContent; // Return the potentially corrected (and tool-processed) content
   }


  /**
   * Clears the conversation history and starts a new conversation ID.
   */
  public clearConversation(): void {
      this.newConversation(); // Use newConversation which handles state clearing and ID generation
      console.log("[ConversationManager] Conversation history cleared.");
  }


  /**
   * Gets the current conversation history (including system prompt).
   */
  public getHistory(): ConversationMessage[] {
    return this.state.getMessages();
  }

  /**
   * Gets metadata for the currently active conversation.
   * Reads from persistence or returns default if not yet saved.
   */
  public getCurrentConversation(): Omit<SerializedConversation, 'messages'> {
      const savedData = this.persistenceService.loadConversation(this.currentConversationId);

      if (savedData) {
          // Return metadata from the loaded file, excluding messages
          const { messages, ...metadata } = savedData;
          return metadata;
      } else {
          // Return default metadata for a new, unsaved conversation
          return {
              id: this.currentConversationId,
              title: 'New Conversation',
              modelName: this.getAiClientModelName(),
              provider: this.getAiProviderName(),
              createdAt: new Date().toISOString(), // Placeholder
              updatedAt: new Date().toISOString(), // Placeholder
              // messageCount: this.state.getMessages().length // Can add if needed
          };
      }
  }

  // --- Persistence Method Delegation ---
  // Expose persistence methods, delegating to the service

  /**
   * Lists all saved conversations using the persistence service.
   * Adds `isActive` flag.
   */
  public listConversations(): (Omit<SerializedConversation, 'messages'> & { isActive: boolean })[] {
      const listedConvos = this.persistenceService.listConversations();
      return listedConvos.map(convo => ({
          ...convo,
          isActive: convo.id === this.currentConversationId
      }));
  }

  /**
   * Renames a conversation using the persistence service.
   */
  public renameConversation(conversationId: string, newTitle: string): boolean {
      return this.persistenceService.renameConversation(conversationId, newTitle);
  }

  /**
   * Deletes a conversation using the persistence service.
   * If the deleted conversation was the current one, creates a new conversation.
   */
  public deleteConversation(conversationId: string): boolean {
      const success = this.persistenceService.deleteConversation(conversationId);
      if (success && conversationId === this.currentConversationId) {
          this.newConversation(); // Start a new one if the current was deleted
      }
      return success;
  }

} // End ConversationManager class
</file>

<file path="src/conversation/ConversationState.ts">
import type { ConversationMessage } from './Message.js';
import { SystemMessage, HumanMessage } from './Message.js'; // Import specific types if needed

export interface VerificationState {
  originalRequest: string; // The original user request that generated criteria
  criteria: string; // The generated verification criteria
  turnIndex: number; // The conversation turn index when criteria were generated
}

export class ConversationState {
  // Store messages in the order they occurred
  private history: ConversationMessage[] = [];
  private systemPromptMessage: SystemMessage | null = null;
  private verificationState: VerificationState | null = null;
  private currentTurn: number = 0; // Track the current conversation turn

  constructor(initialSystemPrompt?: string) {
    if (initialSystemPrompt) {
      this.systemPromptMessage = new SystemMessage(initialSystemPrompt);
    }
  }

  /**
   * Sets or updates the system prompt. This will be the first message sent to the AI.
   */
  setSystemPrompt(prompt: string): void {
    this.systemPromptMessage = new SystemMessage(prompt);
  }

  /**
   * Gets the full message history, including the system prompt if set.
   */
  getMessages(): ConversationMessage[] {
    // Return a copy to prevent external modification
    const messages = [...this.history];
    if (this.systemPromptMessage) {
      // Ensure system prompt is always first
      messages.unshift(this.systemPromptMessage);
    }
    return messages;
  }

  /**
   * Gets only the messages excluding the system prompt.
   */
  getHistoryWithoutSystemPrompt(): ConversationMessage[] {
    return [...this.history];
  }

  /**
   * Clears the conversation history (excluding the system prompt).
   */
  clearHistory(): void {
    this.history = [];
    this.verificationState = null;
    this.currentTurn = 0;
  }

  /**
   * Replaces the entire history with a new set of messages.
   * Does not affect the system prompt.
   */
  replaceHistory(messages: ConversationMessage[]): void {
    this.history = [...messages];
  }

  /**
   * Gets the current conversation turn number
   */
  getCurrentTurn(): number {
    return this.currentTurn;
  }

  /**
   * Increments the turn counter (called when a human message is added)
   */
  incrementTurn(): void {
    this.currentTurn++;
  }

  /**
   * Sets the verification criteria for the current conversation
   */
  setVerificationState(originalRequest: string, criteria: string): void {
    this.verificationState = {
      originalRequest,
      criteria,
      turnIndex: this.currentTurn
    };
  }

  /**
   * Gets the current verification criteria if set
   */
  getVerificationState(): VerificationState | null {
    return this.verificationState;
  }

  /**
   * Gets a formatted string of the conversation sequence for verification
   */
  getRelevantSequenceForVerification(): string {
    if (!this.verificationState) return '';

    // Extract messages from the relevant turn onward
    const relevantMessages = this.history.filter((_, index) => {
      // Get the position in the actual history array (ignoring system prompt)
      return index >= this.verificationState!.turnIndex;
    });

    // Format the messages for verification
    return relevantMessages.map(msg => {
      const role = msg._getType();
      let content = '';

      if (typeof msg.content === 'string') {
        content = msg.content;
      } else {
        content = JSON.stringify(msg.content);
      }

      switch (role) {
        case 'human':
          return `User: ${content}`;
        case 'ai':
          return `Assistant: ${content}`;
        case 'tool':
          // @ts-ignore - accessing LangChain's internal properties
          const toolName = msg.name || 'Tool';
          return `Tool (${toolName}) Result: ${content}`;
        default:
          return `${role.charAt(0).toUpperCase() + role.slice(1)}: ${content}`;
      }
    }).join('\n\n');
  }

  /**
   * Compacts the conversation history by summarizing older messages.
   * @param compactionPromptTemplate The template for the summarization prompt (expecting {history_string}).
   * @param aiClient The AI client instance to use for summarization.
   */
  async compactHistory(compactionPromptTemplate: string, aiClient: any): Promise<void> {
    // Only compact if there's a reasonable number of messages beyond the keep threshold
    const messagesToKeep = 10; // Keep the last 5 exchanges (adjust as needed)
    const minMessagesToCompact = 4; // Require at least 2 exchanges to summarize

    if (this.history.length < messagesToKeep + minMessagesToCompact) {
        console.log(`[State] Skipping compaction: History length (${this.history.length}) is below threshold.`);
        return;
    }

    // Keep the most recent messages
    const recentMessages = this.history.slice(-messagesToKeep);
    const olderMessages = this.history.slice(0, -messagesToKeep);

    console.log(`[State] Compacting history: Keeping ${recentMessages.length}, summarizing ${olderMessages.length} messages.`);

    // Format older messages for the summarization prompt
    const historyString = olderMessages.map(msg => {
      const role = msg._getType();
      const content = typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content);
      return `${role.toUpperCase()}: ${content}`;
    }).join('\n\n');

    // Fill the compaction prompt template
    const promptText = compactionPromptTemplate.replace('{history_string}', historyString);

    try {
      // Create message list for the summarization call
      const compactionMessages: ConversationMessage[] = [
        new SystemMessage("You are an expert conversation summarizer."), // System context for this task
        new HumanMessage(promptText)
      ];

      // Call the AI client to generate the summary
      const summaryContent = await aiClient.generateResponse(compactionMessages);

      // --- Only modify state *after* successful summarization ---
      // Prepend the summary to the *existing* system prompt content
      const originalSystemPromptContent = this.systemPromptMessage?.content || '';
      // Ensure a clear separation between summary and original prompt
      const combinedSystemPromptContent = `[Previous conversation summary:\n${summaryContent}\n]\n\n${originalSystemPromptContent}`;
      this.setSystemPrompt(combinedSystemPromptContent); // Update the system prompt message

      // Replace the history with only the recent messages
      this.history = recentMessages;
      // --- End modification block ---

      console.log('[State] Successfully compacted conversation history.');
    } catch (error) {
      console.error('[State] Failed to compact conversation history:', error);
      // Do NOT modify history if compaction fails, log the error and continue with full history.
      console.warn('[State] Compaction failed. History remains unchanged.');
    }
  }

  /**
   * Adds a message to the conversation history and tracks turns.
   */
  addMessage(message: ConversationMessage): void {
    this.history.push(message);

    // If it's a human message, increment the turn counter
    if (message._getType() === 'human') {
      this.incrementTurn();
    }
  }

  /**
   * Removes the last message from history ONLY if it's an AI message marked as pending a tool call.
   * Used to clean up state when a tool loop is detected and broken.
   */
  removeLastMessageIfPendingAiToolCall(): void {
      const lastMessage = this.history[this.history.length - 1];
      if (
          lastMessage &&
          lastMessage._getType() === 'ai' &&
          (lastMessage as any).pendingToolCalls === true // Check our custom property
      ) {
          this.history.pop();
          console.log('[State] Removed last pending AI tool call message due to loop break.');
      }
  }
}
</file>

<file path="src/conversation/Message.ts">
import {
  BaseMessage,
  SystemMessage as LCSystemMessage,
  HumanMessage as LCHumanMessage,
  AIMessage as LCAIMessage,
  ToolMessage as LCToolMessage, // We'll need this later for tool results
  AIMessageChunk, // For potential streaming later
} from '@langchain/core/messages';

// Re-export core message types for use within the application, 
// but with our own implementation so we can add additional properties
export { BaseMessage, AIMessageChunk };

// Type alias already defined in types.ts, but good to have definitions here
export type ConversationMessage = BaseMessage;

// Extend the base LangChain message classes with our own implementations
export class SystemMessage extends LCSystemMessage {
  constructor(content: string) {
    super(content);
  }
}

export class HumanMessage extends LCHumanMessage {
  constructor(content: string) {
    super(content);
  }
}

export class AIMessage extends LCAIMessage {
  // Add optional properties for tracking tool calls
  public hasToolCalls?: boolean;
  public pendingToolCalls?: boolean;
  // Ensure additional_kwargs are passed to the super constructor

  constructor(
    content: string | Record<string, any>[], // Content can be complex for tool calls
    options?: { 
      hasToolCalls?: boolean, 
      pendingToolCalls?: boolean,
      additional_kwargs?: Record<string, any>,
      tool_calls?: any[] // Add the standard tool_calls property
    }
  ) {
    // LangChain's AIMessage constructor expects an AIMessageInput object.
    // Construct the input object ensuring 'content' is always present.
    const input = {
      content: content, // Assign the original content (string or array) directly
      additional_kwargs: options?.additional_kwargs || {},
      tool_calls: options?.tool_calls || [] // Pass tool_calls correctly
    };

    super(input); // Pass the constructed input object

    // Keep our custom properties
    this.hasToolCalls = options?.hasToolCalls ?? (input.tool_calls && input.tool_calls.length > 0);
    this.pendingToolCalls = options?.pendingToolCalls || false;
  }
}

export class ToolMessage extends LCToolMessage {
  constructor(
    content: string,
    toolCallId: string,
    toolName?: string
  ) {
    // LangChain's ToolMessage requires a specific structure
    // Mimic the actual structure needed for proper conversation history recording
    super({
      content,
      tool_call_id: toolCallId,
      name: toolName,
    });
  }
}

// Helper functions to create messages (optional but can be convenient)
export function createSystemMessage(content: string): SystemMessage {
    return new SystemMessage(content);
}

export function createHumanMessage(content: string): HumanMessage {
    return new HumanMessage(content);
}

export function createAiMessage(content: string, options?: { hasToolCalls?: boolean, pendingToolCalls?: boolean }): AIMessage {
    return new AIMessage(content, options);
}

export function createToolMessage(content: string, toolCallId: string, toolName?: string): ToolMessage {
  return new ToolMessage(content, toolCallId, toolName);
}
</file>

<file path="src/conversation/ToolParser.ts">
/**
 * Parse tool calls from LLM responses in the MCP format.
 * This is similar to the ToolParser in the Rust implementation.
 */

// UUID import removed

export interface ParsedToolCall {
  // ID field removed - it will be handled by LangChain's AIMessage.tool_calls
  name: string;
  arguments: Record<string, any>;
  fullText: string; // The full text of the tool call including delimiters
}

export class ToolParser {
  private static readonly TOOL_CALL_START = '<<<TOOL_CALL>>>';
  private static readonly TOOL_CALL_END = '<<<END_TOOL_CALL>>>';

  /**
   * Parse tool calls from a text response.
   * @param text The text to parse tool calls from.
   * @returns Array of parsed tool calls.
   */
  static parseToolCalls(text: string): ParsedToolCall[] {
    const toolCalls: ParsedToolCall[] = [];
    let currentPos = 0;

    while (currentPos < text.length) {
      // Find the start of a tool call
      const startIndex = text.indexOf(this.TOOL_CALL_START, currentPos);
      if (startIndex === -1) break; // No more tool calls found

      // Find the end of the tool call
      const endIndex = text.indexOf(this.TOOL_CALL_END, startIndex);
      if (endIndex === -1) {
          console.warn(`[ToolParser] Found start delimiter but no end delimiter after position ${startIndex}.`);
          break; // No end delimiter found for this start
      }

      // Extract the potential JSON content between the delimiters
      const jsonStart = startIndex + this.TOOL_CALL_START.length;
      const jsonEnd = endIndex;
      const potentialJsonContent = text.substring(jsonStart, jsonEnd).trim();

      // Attempt to parse the JSON content
      try {
        const toolCallData = JSON.parse(potentialJsonContent);
        
        // Validate structure (name and arguments fields)
        if (
          typeof toolCallData === 'object' && 
          toolCallData !== null &&
          typeof toolCallData.name === 'string' && 
          typeof toolCallData.arguments === 'object' && 
          toolCallData.arguments !== null && 
          !Array.isArray(toolCallData.arguments)
        ) {
          // ID is no longer generated or stored here
          toolCalls.push({
            name: toolCallData.name,
            arguments: toolCallData.arguments,
            // Capture the actual text including delimiters for this parsed call
            fullText: text.substring(startIndex, endIndex + this.TOOL_CALL_END.length)
          });
        } else {
          console.warn('[ToolParser] Invalid tool call JSON structure:', potentialJsonContent);
        }
      } catch (error) {
        // If JSON parsing fails, it might be due to nested delimiters or invalid JSON.
        // Log the error and the raw content that failed to parse.
        console.warn(`[ToolParser] Error parsing tool call JSON between indices ${jsonStart} and ${jsonEnd}:`, error instanceof Error ? error.message : String(error));
        console.warn('[ToolParser] Raw content that failed parsing:', potentialJsonContent);
        // We still capture the fullText including delimiters even on parse failure if needed elsewhere,
        // but the call itself won't be added to the valid `toolCalls` array.
      }

      // Move search position past the *current end delimiter* to find the next potential start,
      // regardless of whether parsing succeeded or failed for this segment.
      currentPos = endIndex + this.TOOL_CALL_END.length;
    }

    return toolCalls;
  }

  /**
   * Check if a response contains any tool calls.
   * @param text The text to check.
   * @returns True if the text contains tool calls, false otherwise.
   */
  static containsToolCalls(text: string): boolean {
    return text.includes(this.TOOL_CALL_START) && text.includes(this.TOOL_CALL_END);
  }

  /**
   * Replace tool calls in text with a placeholder and extract them.
   * @param text The text containing tool calls.
   * @returns Object with the text with tool calls replaced and the extracted tool calls.
   */
  static extractAndReplace(text: string): { 
    cleanText: string; 
    toolCalls: ParsedToolCall[] 
  } {
    let cleanText = text;
    const toolCalls = this.parseToolCalls(text);

    // Replace each tool call with a placeholder
    for (const toolCall of toolCalls) {
      cleanText = cleanText.replace(toolCall.fullText, `[Tool Call: ${toolCall.name}]`);
    }

    return { cleanText, toolCalls };
  }
}
</file>

<file path="src/utils/toolConverter.ts">
import { z } from 'zod';
import { DynamicStructuredTool } from '@langchain/core/tools';
import type { Tool as McpTool } from '@modelcontextprotocol/sdk/types.js'; // MCP Tool type
import type { StructuredToolInterface } from '@langchain/core/tools';

/**
 * Converts an MCP Tool definition into a LangChain StructuredToolInterface.
 *
 * Note: The actual execution logic (`func`) is not needed here, as the
 * ConversationManager handles calling the MCP server. We just need the schema.
 * LangChain uses the schema to inform the LLM about the tool's arguments.
 */
export function convertToLangChainTool(mcpTool: McpTool): StructuredToolInterface {
  let inputSchema: z.ZodObject<any>;

  try {
    // Attempt to parse the input_schema string into a Zod schema object
    // This assumes the schema is a valid JSON representation of a Zod schema
    // or at least a basic JSON schema that Zod can infer.
    // A more robust solution might involve a dedicated JSON Schema -> Zod converter.
    if (typeof mcpTool.input_schema === 'string') {
        // Basic check: if it looks like JSON, try parsing
        if (mcpTool.input_schema.trim().startsWith('{')) {
            const schemaJson = JSON.parse(mcpTool.input_schema);
            // Zod can often infer from a basic JSON schema structure
            inputSchema = z.object(schemaJson.properties || {});
             // Add descriptions to properties if available
             if (schemaJson.properties) {
                Object.keys(schemaJson.properties).forEach(key => {
                    if (schemaJson.properties[key].description && inputSchema.shape[key]) {
                        inputSchema.shape[key] = inputSchema.shape[key].describe(schemaJson.properties[key].description);
                    }
                });
            }
            // Mark required fields - Zod schema needs to be built with optionality in mind.
            // We can't easily modify a field to be non-optional after the fact.
            // Best effort: Log which fields are required based on the schema.
            // A more robust solution would use a dedicated JSON Schema -> Zod converter library.
            if (Array.isArray(schemaJson.required)) {
                 console.log(`[ToolConverter] Tool "${mcpTool.name}" requires fields: ${schemaJson.required.join(', ')}`);
                 // Attempt to make fields non-optional (might not work perfectly depending on base type)
                 // schemaJson.required.forEach((key: string) => {
                 //     if (inputSchema.shape[key] && inputSchema.shape[key].isOptional()) {
                 //         // This is difficult with Zod's immutability. Rebuilding the schema is safer.
                 //         // inputSchema.shape[key] = inputSchema.shape[key].unwrap().required(); // Example concept, may not work
                 //     }
                 // });
            }

        } else {
             console.warn(`[ToolConverter] Non-JSON schema string for tool "${mcpTool.name}". Using empty schema. Schema was: ${mcpTool.input_schema}`);
             inputSchema = z.object({}); // Fallback for non-JSON string schemas
        }

    } else if (typeof mcpTool.input_schema === 'object' && mcpTool.input_schema !== null) {
      // If it's already an object (potentially JSON schema)
       inputSchema = z.object((mcpTool.input_schema as any).properties || {});
        // Add descriptions and handle required fields as above
        if ((mcpTool.input_schema as any).properties) {
            Object.keys((mcpTool.input_schema as any).properties).forEach(key => {
                if ((mcpTool.input_schema as any).properties[key].description && inputSchema.shape[key]) {
                    inputSchema.shape[key] = inputSchema.shape[key].describe((mcpTool.input_schema as any).properties[key].description);
                }
            });
        }
        // Handle required fields from object schema
        if (Array.isArray((mcpTool.input_schema as any).required)) {
             console.log(`[ToolConverter] Tool "${mcpTool.name}" requires fields: ${(mcpTool.input_schema as any).required.join(', ')}`);
            // (mcpTool.input_schema as any).required.forEach((key: string) => {
            //      if (inputSchema.shape[key]) { /* Mark as required if possible - see comment above */ }
            // });
        }

    } else {
      // Default to an empty schema if input_schema is missing or not a string/object
      console.warn(`[ToolConverter] Invalid or missing input_schema for tool "${mcpTool.name}". Using empty schema.`);
      inputSchema = z.object({});
    }
  } catch (error) {
    console.error(`[ToolConverter] Error parsing schema for tool "${mcpTool.name}":`, error);
    inputSchema = z.object({}); // Fallback on error
  }

  return new DynamicStructuredTool({
    name: mcpTool.name,
    description: mcpTool.description || 'No description provided.',
    schema: inputSchema,
    func: async (input) => {
      // This function won't actually be called by our setup.
      // ConversationManager intercepts the tool call request from the LLM
      // and calls the MCP server directly.
      // We provide a dummy implementation to satisfy the interface.
      console.warn(`[ToolConverter] Dummy func called for ${mcpTool.name}. This should not happen in normal operation.`);
      return `Dummy execution result for ${mcpTool.name} with input: ${JSON.stringify(input)}`;
    },
  });
}
</file>

<file path="src/web/routes/ai.routes.ts">
import { Router, type Request, type Response, type RequestHandler } from 'express'; // Add Request, Response, RequestHandler types
import type { ConversationManager } from '../../conversation/ConversationManager.js';
import type { ServerManager } from '../../ServerManager.js';
import * as fs from 'node:fs/promises';
import * as fsSync from 'node:fs'; // For existsSync
import * as path from 'node:path';
import { fileURLToPath } from 'node:url';
import type { AiConfigFileStructure, ProviderModelsStructure } from '../../types.js';
// Using the full namespace import for TOML
import type { Server as SocketIOServer } from 'socket.io'; // Import Socket.IO Server type
import * as TOML_MODULE from '@ltd/j-toml';
const TOML = TOML_MODULE.default;

// Helper for paths
const __filename = fileURLToPath(import.meta.url);
// Correct baseDir calculation: up 3 levels from dist/src/web/routes/
const routesDir = path.dirname(__filename);
const baseDir = path.join(routesDir, '../../..'); // Project root

export function createAiRouter(
    conversationManager: ConversationManager,
    serverManager: ServerManager, // Inject ServerManager if needed by routes here
    io: SocketIOServer // Accept the io instance
): Router {
    const router = Router();
    const aiConfigPath = path.join(baseDir, 'ai_config.json');
    const providerModelsPath = path.join(baseDir, 'provider_models.toml');

    // Helper function to read AI config within handlers
    async function readAiConfig(): Promise<AiConfigFileStructure> {
        try {
            const aiConfigFile = await fs.readFile(aiConfigPath, 'utf-8');
            return JSON.parse(aiConfigFile) as AiConfigFileStructure;
        } catch (error) {
            console.error(`Error reading AI config file (${aiConfigPath}):`, error);
            throw new Error(`Failed to read AI configuration: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }

    // Helper function to read Provider Models within handlers
    async function readProviderModels(): Promise<ProviderModelsStructure> {
        let providerModels: ProviderModelsStructure = {};
        try {
            // Use fsSync.existsSync for a quick check before async read
            if (fsSync.existsSync(providerModelsPath)) {
                const providerModelsFile = await fs.readFile(providerModelsPath, 'utf-8');
                const parsedToml = TOML.parse(providerModelsFile, { joiner: '\n', bigint: false });

                if (typeof parsedToml === 'object' && parsedToml !== null) {
                    providerModels = Object.entries(parsedToml).reduce((acc, [key, value]) => {
                        // Ensure value is an object and has a 'models' array property
                        if (typeof value === 'object' && value !== null && Array.isArray((value as any).models)) {
                            // Ensure models in the array are strings
                            const modelsArray = (value as any).models;
                            if (modelsArray.every((m: unknown) => typeof m === 'string')) {
                                acc[key.toLowerCase()] = { models: modelsArray as string[] };
                            } else {
                                console.warn(`Invalid model list for provider "${key}" in ${providerModelsPath}. Contains non-string elements. Skipping.`);
                            }
                        } else {
                            console.warn(`Invalid structure for provider "${key}" in ${providerModelsPath}. Expected object with 'models' array. Skipping.`);
                        }
                        return acc;
                    }, {} as ProviderModelsStructure);
                }
            }
        } catch (tomlError) {
            console.error(`Error loading or parsing ${providerModelsPath}:`, tomlError);
            // Continue without models if parsing fails, return empty object
        }
        return providerModels;
    }


    // --- AI Providers Info ---
    // Provides current provider, all configured providers, and suggested models
    router.get('/providers', (async (req, res) => { // Remove explicit types, add RequestHandler cast
        try {
            // Load config and models inside the handler
            const aiConfigData = await readAiConfig();
            const providerModels = await readProviderModels();

            res.json({
                current: aiConfigData.defaultProvider || '', // Ensure current is always a string
                providers: aiConfigData.providers,
                models: providerModels
            });
        } catch (error) {
            res.status(500).json({ error: `Failed to get AI providers info: ${error instanceof Error ? error.message : String(error)}` });
        }
    }) as RequestHandler);

    // --- Switch AI Provider ---
    // Note: This endpoint might be deprecated in favor of /model endpoint handling provider change
    router.post('/provider', (async (req, res) => { // Remove explicit types, add RequestHandler cast
        try {
            const { provider } = req.body;
            if (!provider) {
                return res.status(400).json({ error: 'Provider name is required' });
            }

            // Load config and models inside the handler
            const aiConfigData = await readAiConfig();
            const providerModels = await readProviderModels();

            if (!aiConfigData.providers[provider]) {
                return res.status(404).json({ error: `Provider "${provider}" not found` });
            }

            // Update default provider in config data
            aiConfigData.defaultProvider = provider;
            await fs.writeFile(aiConfigPath, JSON.stringify(aiConfigData, null, 2), 'utf-8');

            // Switch the client in ConversationManager
            const providerConfig = aiConfigData.providers[provider];
            const model = conversationManager.switchAiClient(providerConfig, providerModels);

            // Emit model changed event via ConversationManager or directly if needed
            // Assuming ConversationManager handles emitting events or WebServer does based on return

            res.json({ provider, model });
        } catch (error) {
            res.status(500).json({ error: `Failed to switch provider: ${error instanceof Error ? error.message : String(error)}` });
        }
    }) as RequestHandler);

    // --- Switch AI Model (can also handle provider change) ---
    router.post('/model', (async (req, res) => { // Remove explicit types, add RequestHandler cast
        try {
            const { model, provider } = req.body; // Provider is optional, defaults to current
            if (!model) {
                return res.status(400).json({ error: 'Model name is required' });
            }

            // Load config and models inside the handler
            const aiConfigData = await readAiConfig();
            const providerModels = await readProviderModels();

            const providerName = provider || aiConfigData.defaultProvider;
            if (!providerName || !aiConfigData.providers[providerName]) {
                return res.status(404).json({ error: `Provider "${providerName}" not found` });
            }

            // Update the provider's model in config data
            aiConfigData.providers[providerName].model = model;
            // If provider was explicitly passed and is different, update defaultProvider too
            if (provider && provider !== aiConfigData.defaultProvider) {
                aiConfigData.defaultProvider = provider;
            }
            await fs.writeFile(aiConfigPath, JSON.stringify(aiConfigData, null, 2), 'utf-8');

            // Switch the client in ConversationManager
            const providerConfig = aiConfigData.providers[providerName];
            const actualModel = conversationManager.switchAiClient(providerConfig, providerModels);

            // Emit model changed event via socket
            io.emit('model-changed', { provider: providerName, model: actualModel });
            console.log(`[API] Emitted model-changed event: ${providerName} - ${actualModel}`);

            res.json({ provider: providerName, model: actualModel });
        } catch (error) {
            res.status(500).json({ error: `Failed to switch model: ${error instanceof Error ? error.message : String(error)}` });
        }
    }) as RequestHandler);

    // --- Update API Keys ---
    router.post('/keys', (async (req, res) => { // Remove explicit types, add RequestHandler cast
        try {
            const { provider, apiKey } = req.body;
            if (!provider || !apiKey) {
                return res.status(400).json({ error: 'Provider and API key are required' });
            }

            // Load config inside the handler
            const aiConfigData = await readAiConfig();

            if (!aiConfigData.providers[provider]) {
                return res.status(404).json({ error: `Provider "${provider}" not found` });
            }

            // Update the API key, remove env var if present
            aiConfigData.providers[provider].apiKey = apiKey;
            delete aiConfigData.providers[provider].apiKeyEnvVar;

            // Save the updated config
            await fs.writeFile(aiConfigPath, JSON.stringify(aiConfigData, null, 2), 'utf-8');

            // Reload the AI client if this is the current provider
            if (provider === aiConfigData.defaultProvider) {
                try {
                    // Load provider models inside the handler
                    const providerModels = await readProviderModels();

                    const providerConfig = aiConfigData.providers[provider];
                    const model = conversationManager.switchAiClient(providerConfig, providerModels);

                    // Emit model changed event (key changed and applied)
                    io.emit('model-changed', { provider, model });
                    console.log(`[API] Emitted model-changed event after key update: ${provider} - ${model}`);

                    res.json({
                        success: true,
                        message: 'API key updated and applied.',
                        provider,
                        model
                    });
                } catch (clientError) {
                    console.error('Error switching client after API key update:', clientError);
                    res.json({
                        success: true,
                        warning: 'API key was saved but could not be applied immediately.',
                        error: String(clientError)
                    });
                }
            } else {
                res.json({
                    success: true,
                    message: `API key updated for provider: ${provider}`
                });
            }
        } catch (error) {
            res.status(500).json({ error: `Failed to update API key: ${error instanceof Error ? error.message : String(error)}` });
        }
    }) as RequestHandler);


    return router;
}
</file>

<file path="src/web/routes/config.routes.ts">
import { Router, type Request, type Response, type RequestHandler } from 'express'; // Add Request, Response, RequestHandler types
import * as fs from 'node:fs/promises';
import * as fsSync from 'node:fs';
import * as path from 'node:path';
import { fileURLToPath } from 'node:url';
// Import necessary types for validation
import type { ConfigFileStructure, AiConfigFileStructure, ProviderModelsStructure, StdioServerConfig, AiProviderConfig } from '../../types.js';

// Helper for paths
const __filename = fileURLToPath(import.meta.url);
// Correct baseDir calculation: up 3 levels from dist/src/web/routes/
const routesDir = path.dirname(__filename);
const baseDir = path.join(routesDir, '../../..'); // Project root

export function createConfigRouter(): Router {
    const router = Router();
    const allowedFiles = ['ai_config.json', 'servers.json', 'provider_models.toml'];

    // --- Get Config File Content ---
    router.get('/:file', (async (req, res) => { // Remove explicit types, add RequestHandler cast
        try {
            const { file } = req.params;

            if (!allowedFiles.includes(file)) {
                return res.status(403).json({ error: `Access to file "${file}" is not allowed` });
            }

            const filePath = path.join(baseDir, file);

            try {
                await fs.access(filePath, fs.constants.F_OK); // Check if file exists asynchronously
            } catch (accessError) {
                 return res.status(404).json({ error: `File "${file}" not found` });
            }

            const content = await fs.readFile(filePath, 'utf-8');

            res.json({
                file,
                path: filePath, // Consider if exposing the full path is okay
                content,
                type: file.endsWith('.json') ? 'json' : file.endsWith('.toml') ? 'toml' : 'text'
            });
        } catch (error) {
            res.status(500).json({ error: `Failed to read configuration file: ${error instanceof Error ? error.message : String(error)}` });
        }
    }) as RequestHandler);

    // --- Save Config File Content ---
    router.post('/:file', (async (req, res) => { // Remove explicit types, add RequestHandler cast
        try {
            const { file } = req.params;
            const { content } = req.body;

            if (content === undefined) {
                return res.status(400).json({ error: 'File content is required' });
            }
            if (typeof content !== 'string') {
                 return res.status(400).json({ error: 'File content must be a string' });
            }


            if (!allowedFiles.includes(file)) {
                return res.status(403).json({ error: `Access to file "${file}" is not allowed` });
            }

            const filePath = path.join(baseDir, file);

            // Validate content based on file type and structure
            try {
                if (file === 'servers.json') {
                    const parsedConfig = JSON.parse(content) as ConfigFileStructure;
                    if (typeof parsedConfig !== 'object' || parsedConfig === null || typeof parsedConfig.mcpServers !== 'object' || parsedConfig.mcpServers === null) {
                        throw new Error("Invalid servers.json structure: Must be an object with an 'mcpServers' object.");
                    }
                    // Further validation of StdioServerConfig structure within mcpServers
                    for (const [name, serverCfgUntyped] of Object.entries(parsedConfig.mcpServers)) {
                         const cfg = serverCfgUntyped as StdioServerConfig; // Cast to expected type
                         if (!cfg || typeof cfg !== 'object' || typeof cfg.command !== 'string' || !cfg.command) {
                             throw new Error(`Invalid config for server "${name}": Missing or invalid 'command'.`);
                         }
                         if (cfg.args && !Array.isArray(cfg.args)) throw new Error(`Invalid config for server "${name}": 'args' must be an array.`);
                         if (cfg.env && typeof cfg.env !== 'object') throw new Error(`Invalid config for server "${name}": 'env' must be an object.`);
                         // Check for unexpected keys in StdioServerConfig if needed
                    }
                } else if (file === 'ai_config.json') {
                    const parsedConfig = JSON.parse(content) as AiConfigFileStructure;
                     if (typeof parsedConfig !== 'object' || parsedConfig === null || typeof parsedConfig.providers !== 'object' || parsedConfig.providers === null) {
                        throw new Error("Invalid ai_config.json structure: Must be an object with a 'providers' object.");
                    }
                     if (parsedConfig.defaultProvider && typeof parsedConfig.defaultProvider !== 'string') {
                         throw new Error("Invalid ai_config.json structure: 'defaultProvider' must be a string if present.");
                     }
                     // Further validation of AiProviderConfig structure within providers
                     for (const [name, providerCfgUntyped] of Object.entries(parsedConfig.providers)) {
                         const cfg = providerCfgUntyped as AiProviderConfig; // Cast to expected type
                         if (!cfg || typeof cfg !== 'object' || typeof cfg.provider !== 'string' || !cfg.provider) {
                             throw new Error(`Invalid config for provider "${name}": Missing or invalid 'provider' name.`);
                         }
                         // Add checks for model, apiKey, apiKeyEnvVar, temperature types if needed
                     }
                } else if (file === 'provider_models.toml') {
                    const TOML = (await import('@ltd/j-toml')).default;
                    const parsedToml = TOML.parse(content, { joiner: '\n', bigint: false });
                    if (typeof parsedToml !== 'object' || parsedToml === null) {
                        throw new Error("Invalid TOML structure: Must parse to an object.");
                    }
                    // Validate ProviderModelsStructure
                    for (const [key, value] of Object.entries(parsedToml)) {
                        if (typeof value !== 'object' || value === null || !Array.isArray((value as any).models)) {
                            throw new Error(`Invalid structure for provider "${key}" in TOML: Expected object with 'models' array.`);
                        }
                        if (!(value as any).models.every((m: unknown) => typeof m === 'string')) {
                             throw new Error(`Invalid model list for provider "${key}" in TOML: Contains non-string elements.`);
                        }
                    }
                }
            } catch (validationError) {
                 return res.status(400).json({ error: `Invalid configuration format for ${file}: ${validationError instanceof Error ? validationError.message : String(validationError)}` });
            }


            // Save the file
            await fs.writeFile(filePath, content, 'utf-8');

            // Determine if restart is needed (only provider_models.toml doesn't require one)
            const needsRestart = file !== 'provider_models.toml';

            res.json({
                success: true,
                message: needsRestart
                    ? 'Configuration saved. A restart may be required for changes to take effect.'
                    : 'Configuration saved successfully.',
                needsRestart
            });
        } catch (error) {
            res.status(500).json({ error: `Failed to save configuration file: ${error instanceof Error ? error.message : String(error)}` });
        }
    }) as RequestHandler);

    return router;
}
</file>

<file path="src/web/routes/conversation.routes.ts">
import { Router, type Request, type Response, type RequestHandler } from 'express';
import type { ConversationManager } from '../../conversation/ConversationManager.js';
import type { Server as SocketIOServer } from 'socket.io'; // Import Socket.IO Server type

export function createConversationRouter(
    conversationManager: ConversationManager,
    io: SocketIOServer // Pass the Socket.IO server instance
): Router {
    const router = Router();

    // --- Get Conversation History (Potentially redundant if using sockets) ---
    // Kept for potential direct API access if needed
    router.get('/history', ((req, res) => {
        try {
            const history = conversationManager.getHistory();
            res.json({
                history: history.map(msg => ({
                    role: msg._getType(),
                    content: msg.content,
                    // Ensure these properties exist or handle potential undefined
                    hasToolCalls: (msg as any).hasToolCalls ?? false,
                    pendingToolCalls: (msg as any).pendingToolCalls ?? false
                }))
            });
        } catch (error) {
            res.status(500).json({ error: `Failed to get history: ${error instanceof Error ? error.message : String(error)}` });
        }
    }) as RequestHandler);

    // --- List Conversations ---
    router.get('/', ((req, res) => {
        try {
            const conversations = conversationManager.listConversations();
            res.json({ conversations });
        } catch (error) {
            res.status(500).json({ error: `Failed to list conversations: ${error instanceof Error ? error.message : String(error)}` });
        }
    }) as RequestHandler);

    // --- Create New Conversation ---
    // This might be better handled purely via sockets, but providing an API endpoint too
    router.post('/new', ((req, res) => {
        try {
            conversationManager.newConversation();
            const currentConversation = conversationManager.getCurrentConversation(); // Get metadata
            const history = conversationManager.getHistory(); // Get messages for the new empty convo

            // Emit socket events (handled in WebServer or here if io is passed)
            io.emit('conversation-loaded', {
                id: currentConversation.id,
                messages: history.map(msg => ({
                    role: msg._getType(),
                    content: msg.content,
                    hasToolCalls: (msg as any).hasToolCalls ?? false,
                    pendingToolCalls: (msg as any).pendingToolCalls ?? false
                }))
            });
            const conversations = conversationManager.listConversations();
            io.emit('conversations-list', { conversations });

            res.json({ success: true, id: currentConversation.id });
        } catch (error) {
            res.status(500).json({ error: `Failed to create new conversation: ${error instanceof Error ? error.message : String(error)}` });
        }
    }) as RequestHandler);

    // --- Load Conversation ---
    // Also potentially better via sockets
    router.post('/load', ((req, res) => {
        try {
            const { id } = req.body;
            if (!id) {
                return res.status(400).json({ error: 'Conversation ID is required' });
            }

            const success = conversationManager.loadConversation(id);
            if (!success) {
                return res.status(404).json({ error: `Conversation with ID ${id} not found` });
            }

            const history = conversationManager.getHistory();

            // Emit socket event
            io.emit('conversation-loaded', {
                id,
                messages: history.map(msg => ({
                    role: msg._getType(),
                    content: msg.content,
                    hasToolCalls: (msg as any).hasToolCalls ?? false,
                    pendingToolCalls: (msg as any).pendingToolCalls ?? false
                }))
            });

            res.json({ success: true, id });
        } catch (error) {
            res.status(500).json({ error: `Failed to load conversation: ${error instanceof Error ? error.message : String(error)}` });
        }
    }) as RequestHandler);

    // --- Delete Conversation ---
    router.delete('/:id', ((req, res) => {
        try {
            const { id } = req.params;
            if (!id) {
                return res.status(400).json({ error: 'Conversation ID is required' });
            }

            const success = conversationManager.deleteConversation(id);
            if (!success) {
                return res.status(404).json({ error: `Conversation with ID ${id} not found` });
            }

            // Emit socket event
            const conversations = conversationManager.listConversations();
            io.emit('conversations-list', { conversations });

            res.json({ success: true });
        } catch (error) {
            res.status(500).json({ error: `Failed to delete conversation: ${error instanceof Error ? error.message : String(error)}` });
        }
    }) as RequestHandler);

    // --- Rename Conversation ---
    router.post('/:id/rename', ((req, res) => {
        try {
            const { id } = req.params;
            const { title } = req.body;

            if (!id) {
                return res.status(400).json({ error: 'Conversation ID is required' });
            }
            if (!title) {
                return res.status(400).json({ error: 'Title is required' });
            }

            const success = conversationManager.renameConversation(id, title);
            if (!success) {
                return res.status(404).json({ error: `Conversation with ID ${id} not found` });
            }

            // Emit socket event
            const conversations = conversationManager.listConversations();
            io.emit('conversations-list', { conversations });

            res.json({ success: true });
        } catch (error) {
            res.status(500).json({ error: `Failed to rename conversation: ${error instanceof Error ? error.message : String(error)}` });
        }
    }) as RequestHandler);

    // --- Submit Message (Potentially redundant if using sockets) ---
    // Kept for potential direct API access
    router.post('/message', (async (req, res) => {
        try {
            const { message } = req.body;
            if (!message) {
                return res.status(400).json({ error: 'Message is required' });
            }

            // Process the message (this is async)
            // We don't wait for the full response here, just acknowledge receipt
            conversationManager.processUserMessage(message)
                .then(aiResponse => {
                    // Emit events via socket (handled in ConversationManager or WebServer)
                    // Example: io.emit('history-update', ...);
                    console.log("AI response processed (via API route)");
                })
                .catch(error => {
                    console.error("Error processing message via API route:", error);
                    // Emit error via socket
                    io.emit('error', { message: `Error processing message: ${error.message}` });
                });

            // Return immediately
            res.json({ status: 'processing' });
        } catch (error) {
            res.status(500).json({ error: `Failed to process message: ${error instanceof Error ? error.message : String(error)}` });
        }
    }) as RequestHandler);

    // --- Clear Conversation (Potentially redundant if using sockets) ---
    router.post('/clear', ((req, res) => {
        try {
            conversationManager.clearConversation();
            // Emit socket event
            io.emit('conversation-cleared');
            res.json({ status: 'success' });
        } catch (error) {
            res.status(500).json({ error: `Failed to clear conversation: ${error instanceof Error ? error.message : String(error)}` });
        }
    }) as RequestHandler);


    return router;
}
</file>

<file path="src/web/routes/servers.routes.ts">
import { Router, type Request, type Response, type RequestHandler } from 'express'; // Add Request, Response, RequestHandler types
import type { ServerManager } from '../../ServerManager.js';
import * as fs from 'node:fs/promises';
import * as fsSync from 'node:fs'; // For existsSync
import * as path from 'node:path';
import { fileURLToPath } from 'node:url';
import type { ConfigFileStructure } from '../../types.js';

// Helper for paths
const __filename = fileURLToPath(import.meta.url);
// Correct baseDir calculation: up 3 levels from dist/src/web/routes/
const routesDir = path.dirname(__filename);
const baseDir = path.join(routesDir, '../../..'); // Project root

export function createServersRouter(serverManager: ServerManager): Router {
    const router = Router();
    const serversConfigPath = path.join(baseDir, 'servers.json');

    // --- Get Connected Server Status & Tools ---
    router.get('/', (async (req, res) => { // Remove explicit types, add RequestHandler cast
        try {
            // Get status from ServerManager (assuming it has a method like getServerStatuses)
            // For now, just return connected names as before, but ideally return status objects
            const connectedServers = serverManager.getConnectedServers(); // Replace with getStatuses if available
            // TODO: Enhance this to return status objects [{ name, status, error? }]
            // For now, map names to a basic status object for consistency
            const serverStatuses = connectedServers.map(name => ({ name, status: 'connected' }));
            res.json({ servers: serverStatuses });
        } catch (error) {
            res.status(500).json({ error: `Failed to get server status: ${error instanceof Error ? error.message : String(error)}` });
        }
    }) as RequestHandler);

    router.get('/tools', (async (req, res) => { // Remove explicit types, add RequestHandler cast
        try {
            const tools = await serverManager.getAllTools();
            // Group tools by server here
            const toolsByServer: Record<string, any[]> = {};
            for (const tool of tools) {
                // Need a way to know which server provided the tool.
                // Assuming ServerManager.getAllTools() returns tools with server info,
                // or we modify ServerManager.findToolProvider to return server for each tool.
                // For now, let's assume a placeholder server or group all under 'all'.
                const serverName = serverManager.findToolProvider(tool.name) || 'unknown_server';
                if (!toolsByServer[serverName]) {
                    toolsByServer[serverName] = [];
                }
                // Avoid adding duplicates if multiple servers provide the same tool name
                if (!toolsByServer[serverName].some(t => t.name === tool.name)) {
                    toolsByServer[serverName].push(tool);
                }
            }
            res.json({ tools: toolsByServer }); // Send grouped tools
        } catch (error) {
            res.status(500).json({ error: `Failed to get tools: ${error instanceof Error ? error.message : String(error)}` });
        }
    }) as RequestHandler);

    // --- Get Server Configuration File (servers.json) ---
    // This is used by the modal to populate the editor
    router.get('/config', (async (req, res) => { // Remove explicit types, add RequestHandler cast
        try {
            if (!fsSync.existsSync(serversConfigPath)) {
                // Return empty structure if file doesn't exist
                return res.json({ mcpServers: {} });
            }
            const serversConfigFile = await fs.readFile(serversConfigPath, 'utf-8');
            const serversConfig = JSON.parse(serversConfigFile);
            res.json(serversConfig);
        } catch (error) {
            res.status(500).json({ error: `Failed to get server configurations: ${error instanceof Error ? error.message : String(error)}` });
        }
    }) as RequestHandler);

    // --- Update Server Configuration File (servers.json) ---
    // This is called when saving changes in the modal
    router.post('/config', (async (req, res) => { // Remove explicit types, add RequestHandler cast
        try {
            const { config } = req.body; // Expecting the full { mcpServers: {...} } structure

            if (!config || typeof config !== 'object' || !config.mcpServers) {
                return res.status(400).json({ error: 'Invalid server configuration format. Must include mcpServers object.' });
            }

            // Basic validation (could be more thorough with Zod)
            if (typeof config.mcpServers !== 'object') {
                return res.status(400).json({ error: 'mcpServers must be an object.' });
            }
            for (const [name, cfg] of Object.entries(config.mcpServers as Record<string, any>)) {
                if (!cfg || typeof cfg !== 'object' || !cfg.command) {
                     return res.status(400).json({ error: `Invalid config for server "${name}". Missing command.` });
                }
                // Add more checks for args, env types if needed
                if (cfg.args && !Array.isArray(cfg.args)) {
                    return res.status(400).json({ error: `Invalid config for server "${name}". Args must be an array.` });
                }
                 if (cfg.env && typeof cfg.env !== 'object') {
                    return res.status(400).json({ error: `Invalid config for server "${name}". Env must be an object.` });
                }
            }


            // Save the configuration
            await fs.writeFile(serversConfigPath, JSON.stringify(config, null, 2), 'utf-8');

            res.json({
                success: true,
                message: 'Server configuration updated. Restart the application to apply changes.'
            });
        } catch (error) {
            res.status(500).json({ error: `Failed to update server configurations: ${error instanceof Error ? error.message : String(error)}` });
        }
    }) as RequestHandler);


    return router;
}
</file>

<file path="src/web/WebServer.ts">
// @ts-nocheck
import express from 'express';
import http from 'http';
import cors from 'cors';
import { Server as SocketIOServer } from 'socket.io';
import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';
import type { ConversationManager } from '../conversation/ConversationManager.js';
import type { ServerManager } from '../ServerManager.js';

// Helper for ES modules to get the directory path
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export class WebServer {
  private app;
  private server;
  private io;
  private conversationManager;
  private serverManager;
  private port;
  private isRunning = false;

  constructor(conversationManager, serverManager, port = 3000) {
    this.conversationManager = conversationManager;
    this.serverManager = serverManager;
    this.port = port;

    // Initialize Express app
    this.app = express();
    this.app.use(cors());
    this.app.use(express.json());
    
    // Serve static files from the web directory
    // Correct path: Go up three levels from dist/src/web to multi-client/, then into web/
    const webDirPath = path.join(__dirname, '../../../web'); 
    this.app.use(express.static(webDirPath));

    // Create HTTP server
    this.server = http.createServer(this.app);
    
    // Set up Socket.IO
    this.io = new SocketIOServer(this.server, {
      cors: {
        origin: '*',
        methods: ['GET', 'POST']
      }
    });
  }

  /**
   * Asynchronously initializes routes and socket events after dynamic imports.
   */
  async init() {
    // Import routers within the async method
    const { createAiRouter } = await import('./routes/ai.routes.js');
    const { createServersRouter } = await import('./routes/servers.routes.js');
    const { createConfigRouter } = await import('./routes/config.routes.js');
    const { createConversationRouter } = await import('./routes/conversation.routes.js');

    // Set up routes and socket events
    this.setupRoutes(
      createAiRouter(this.conversationManager, this.serverManager, this.io), // Pass io instance here
      createServersRouter(this.serverManager),
      createConfigRouter(),
      createConversationRouter(this.conversationManager, this.io) // Pass io for emitting events
    );
    this.setupSocketEvents();
  }

  private setupRoutes(aiRouter, serversRouter, configRouter, conversationRouter) {
    // Correct path: Go up three levels from dist/src/web to multi-client/, then into web/
    const webDirPath = path.join(__dirname, '../../../web');

    // Root route - serve the main HTML file
    this.app.get('/', (req, res) => {
      res.sendFile(path.join(webDirPath, 'index.html'));
    });

    // Mount API routers under /api prefix
    this.app.use('/api/ai', aiRouter);
    this.app.use('/api/servers', serversRouter);
    this.app.use('/api/config', configRouter);
    this.app.use('/api/conversations', conversationRouter);

    // --- Deprecated/Moved Routes (Remove or keep for backward compatibility if needed) ---
    // These are now handled by the specific routers

    // Example: Remove old /api/servers route if handled by serversRouter
    // this.app.get('/api/servers', (req, res) => { ... });

    // All old route definitions previously here should be removed as they are now
    // handled by the imported routers (aiRouter, serversRouter, configRouter, conversationRouter).
  }

  private setupSocketEvents() {
    this.io.on('connection', (socket) => {
      console.log('Client connected:', socket.id);

      // Send initial data to newly connected client
      this.sendInitialData(socket);

      // Handle disconnect
      socket.on('disconnect', () => {
        console.log('Client disconnected:', socket.id);
      });

      // Handle user messages from socket
      socket.on('user-message', (data) => {
        const { message } = data;
        this.processUserMessage(message);
      });

      // Handle clear conversation request
      socket.on('clear-conversation', () => {
        try {
          this.conversationManager.clearConversation();
          this.io.emit('conversation-cleared'); // Notify all clients
        } catch (error) {
          console.error('[WebServer] Error clearing conversation:', error);
          socket.emit('error', { // Notify specific client about the error
            message: `Error clearing conversation: ${error instanceof Error ? error.message : String(error)}`
          });
        }
      });

      // Handle new conversation request
      socket.on('new-conversation', () => {
        try {
          this.conversationManager.newConversation();
          const history = this.conversationManager.getHistory();

          // Emit the new conversation ID
          const currentConversation = this.conversationManager.getCurrentConversation();
          this.io.emit('conversation-loaded', { // Notify all clients about the new state
            id: currentConversation.id,
            messages: history.map(msg => ({
              role: msg._getType(),
              content: msg.content,
              hasToolCalls: msg.hasToolCalls,
              pendingToolCalls: msg.pendingToolCalls
            }))
          });
          
          // Send the updated conversations list
          const conversations = this.conversationManager.listConversations();
          this.io.emit('conversations-list', { conversations });
        } catch (error) {
          console.error('[WebServer] Error creating new conversation:', error);
          socket.emit('error', { // Notify specific client about the error
            message: `Error creating new conversation: ${error instanceof Error ? error.message : String(error)}`
          });
        }
      });

      // Handle load conversation request
      socket.on('load-conversation', (data) => {
        try {
          const { id } = data;
          if (!id) {
            throw new Error('Conversation ID is required');
          }

          const success = this.conversationManager.loadConversation(id);
          if (!success) {
            throw new Error(`Conversation with ID ${id} not found`);
          }
          
          const history = this.conversationManager.getHistory();
          
          // Emit the loaded conversation
          this.io.emit('conversation-loaded', {
            id,
            messages: history.map(msg => ({
              role: msg._getType(),
              content: msg.content,
              hasToolCalls: msg.hasToolCalls,
              pendingToolCalls: msg.pendingToolCalls
            }))
          });
        } catch (error) {
          console.error('[WebServer] Error loading conversation:', error);
          socket.emit('error', { // Notify specific client about the error
            message: `Error loading conversation: ${error instanceof Error ? error.message : String(error)}`
          });
        }
      });
    });
  }

  private async sendInitialData(socket) {
    try {
      // Send server information
      const connectedServers = this.serverManager.getConnectedServers();
      socket.emit('servers-info', { servers: connectedServers });

      // Send conversation history
      const history = this.conversationManager.getHistory();
      socket.emit('history', { 
        history: history.map(msg => ({
          role: msg._getType(),
          content: msg.content,
          hasToolCalls: msg.hasToolCalls,
          pendingToolCalls: msg.pendingToolCalls
        }))
      });

      // Send available tools, organizing by server
      const allTools = await this.serverManager.getAllTools();
      const serverNames = this.serverManager.getConnectedServers();

      // Format tools as { serverName: toolsArray }
      const toolsByServer: Record<string, Tool[]> = {}; // Ensure correct type and declare only once
      for (const serverName of serverNames) {
        try {
          // Attempt to get tools, but handle potential errors gracefully
          const serverTools = this.serverManager.getServerTools(serverName);
          toolsByServer[serverName] = serverTools;
        } catch (error) {
          // Log the error but continue fetching from other servers
          console.warn(`[WebServer] Error getting tools for server ${serverName} during initial data send:`, error instanceof Error ? error.message : String(error));
          toolsByServer[serverName] = []; // Assign empty array for this server on error
        }
      }

      console.log('[WebServer] Emitting tools-info:', JSON.stringify(Object.keys(toolsByServer))); // Log server names with tools
      socket.emit('tools-info', toolsByServer);
      
      // Send the list of conversations
      try {
        const conversations = this.conversationManager.listConversations();
        socket.emit('conversations-list', { conversations });
        
        // If there's a current conversation, send its ID
        const currentConversation = this.conversationManager.getCurrentConversation();
        if (currentConversation && currentConversation.id) {
          socket.emit('conversation-loaded', { 
            id: currentConversation.id,
            messages: history.map(msg => ({
              role: msg._getType(),
              content: msg.content,
              hasToolCalls: msg.hasToolCalls,
              pendingToolCalls: msg.pendingToolCalls
            }))
          });
        }
      } catch (conversationError) {
        console.error('Error sending conversations list:', conversationError);
        // Continue even if this part fails
      }
    } catch (error) {
      console.error('Error sending initial data:', error);
    }
  }

  private async processUserMessage(message) {
    try {
      // Emit 'thinking' event to indicate processing has started
      this.io.emit('thinking', { status: true });
      
      // Process the message
      const aiResponse = await this.conversationManager.processUserMessage(message);
      
      // Emit 'thinking' event to indicate processing has finished
      this.io.emit('thinking', { status: false });
      
      // Send updated history (which includes the new AI response)
      const history = this.conversationManager.getHistory();
      this.io.emit('history-update', { 
        history: history.map(msg => ({
          role: msg._getType(),
          content: msg.content,
          hasToolCalls: msg.hasToolCalls,
          pendingToolCalls: msg.pendingToolCalls
        }))
      });
      
      // If we have a current conversation, emit the updated conversation
      try {
        const currentConversation = this.conversationManager.getCurrentConversation();
        if (currentConversation && currentConversation.id) {
          this.io.emit('conversation-saved', currentConversation);
        }
      } catch (conversationError) {
        console.error('Error getting current conversation:', conversationError);
        // Continue even if this part fails
      }
    } catch (error) {
      console.error('Error processing message:', error);
      this.io.emit('thinking', { status: false });
      this.io.emit('error', { 
        message: `Error processing message: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }

  /**
   * Start the web server
   */
  public start() {
    if (this.isRunning) return;
    
    this.server.listen(this.port, () => {
      console.log(`Web server running at http://localhost:${this.port}`);
      this.isRunning = true;
    });
  }

  /**
   * Stop the web server
   */
  public stop() {
    return new Promise<void>((resolve, reject) => {
      if (!this.isRunning) {
        resolve();
        return;
      }
      
      // First close all socket connections
      if (this.io) {
        console.log('Closing Socket.IO connections');
        this.io.close(() => {
          // After socket connections closed, close the HTTP server
          this.server.close((err) => {
            if (err) {
              console.error('Error closing HTTP server:', err);
              reject(err);
            } else {
              console.log('Web server stopped');
              this.isRunning = false;
              resolve();
            }
          });
        });
      } else {
        // If io doesn't exist, just close the HTTP server
        this.server.close((err) => {
          if (err) {
            console.error('Error closing HTTP server:', err);
            reject(err);
          } else {
            console.log('Web server stopped');
            this.isRunning = false;
            resolve();
          }
        });
      }
      
      // Set a timeout in case the server doesn't close properly
      const timeout = setTimeout(() => {
        console.log('Server stop timed out, forcing close');
        this.isRunning = false;
        resolve();
      }, 3000); // 3 seconds timeout
      
      // Clear the timeout if the server closes properly
      timeout.unref();
    });
  }
}
</file>

<file path="src/Repl.ts">
import * as readline from 'node:readline';
import * as fs from 'node:fs';
import * as path from 'node:path';
import { fileURLToPath } from 'node:url';
import type { Command, AiProviderConfig, ProviderModelsStructure, AiConfigFileStructure } from './types.js';
import type { ServerManager } from './ServerManager.js';
import type { ConversationManager } from './conversation/ConversationManager.js'; // Import ConversationManager

/**
 * Interactive REPL for interacting with MCP servers and AI agent
 */
// Helper to get the directory name in ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const baseDir = path.join(__dirname, '..');

export class Repl {
  private rl: readline.Interface;
  private commands: Map<string, Command> = new Map();
  private serverManager: ServerManager;
  private conversationManager: ConversationManager; // Add ConversationManager instance
  private currentServer: string | null = null; // For direct server interaction
  private isChatMode: boolean = false; // Flag for chat mode
  private running = false;
  private providers: Record<string, AiProviderConfig> = {}; // Available AI providers
  private providerModels: ProviderModelsStructure = {}; // Available models for providers
  private currentProvider: string = ''; // Current provider name
  private aiConfigPath: string = path.join(baseDir, 'ai_config.json'); // Path to AI config file
  // History handling might need adjustment for chat mode
  // private history: string[] = [];
  // private historyIndex = 0;

  constructor(
    serverManager: ServerManager, 
    conversationManager: ConversationManager,
    providerModels: ProviderModelsStructure
  ) {
    this.serverManager = serverManager;
    this.conversationManager = conversationManager; // Store ConversationManager
    this.providerModels = providerModels; // Store model list
    
    // Load AI config
    this.loadAiConfig();
    
    // Create readline interface
    this.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      prompt: this.getPrompt(),
      historySize: 100,
    });
    
    // Register default commands
    this.registerCommands();
  }
  
  /**
   * Load the AI provider configuration from the config file
   */
  private loadAiConfig(): void {
    try {
      const aiConfigFile = fs.readFileSync(this.aiConfigPath, 'utf-8');
      const aiConfigData = JSON.parse(aiConfigFile) as AiConfigFileStructure;
      
      // Store providers
      this.providers = aiConfigData.providers || {};
      
      // Store current provider
      this.currentProvider = aiConfigData.defaultProvider || '';
      
      console.log(`Loaded AI configurations for: ${Object.keys(this.providers).join(', ')}`);
      if (this.currentProvider) {
        console.log(`Current AI provider: ${this.currentProvider}`);
      }
    } catch (error) {
      console.error('Error loading AI config:', error instanceof Error ? error.message : String(error));
    }
  }
  
  /**
   * Save the AI provider configuration to the config file
   */
  private saveAiConfig(): void {
    try {
      const aiConfigData: AiConfigFileStructure = {
        defaultProvider: this.currentProvider,
        providers: this.providers
      };
      
      fs.writeFileSync(this.aiConfigPath, JSON.stringify(aiConfigData, null, 2), 'utf-8');
      console.log(`AI configuration saved to ${this.aiConfigPath}`);
    } catch (error) {
      console.error('Error saving AI config:', error instanceof Error ? error.message : String(error));
    }
  }

  private getPrompt(): string {
    if (this.isChatMode) {
      const modelName = this.conversationManager.getAiClientModelName(); // Need method in ConversationManager
      return `Chat (${modelName})> `;
    } else {
      const serverText = this.currentServer || 'none';
      return `MCP [${serverText}]> `;
    }
  }

  private registerCommands() {
    // --- Keep existing commands: help, servers, use, tools, call, exit, quit ---
    // Help command
    this.addCommand({
      name: 'help',
      description: 'Show available commands',
      execute: async () => {
        let output = 'Available commands:\n';
        output += '  chat         - Enter interactive chat mode with the AI agent.\n';
        output += '  exit         - Exit chat mode or the REPL.\n';
        output += '  quit         - Alias for exit.\n';
        output += '  --- AI/Model Commands ---\n';
        output += '  providers    - List available AI providers and models.\n';
        output += '  provider <name> - Set the current AI provider.\n';
        output += '  model <name> - Set the model for the current provider.\n';
        output += '  --- Server Commands ---\n';
        output += '  servers      - List all connected servers.\n';
        output += '  use <server> - Select a server for direct tool calls.\n';
        output += '  tools [srv]  - List tools on current or specified server.\n';
        output += '  call <tool> [json] - Call tool on current/auto-detected server.\n';
        output += '  --- Chat Commands ---\n';
        output += '  history      - Show conversation history (in chat mode).\n';
        output += '  clear        - Clear conversation history (in chat mode).\n';
        return output;
      }
    });

    // List servers command (no changes needed)
    this.addCommand({
      name: 'servers',
      description: 'List all connected servers',
      execute: async () => {
        const servers = this.serverManager.getConnectedServers();
        if (servers.length === 0) {
          return 'No connected servers.';
        }
        
        let output = 'Connected servers:\n';
        servers.forEach(name => {
          const isCurrent = name === this.currentServer;
          output += `  ${isCurrent ? '* ' : '  '}${name}\n`;
        });
        return output;
      }
    });
    
    // Use server command (no changes needed)
    this.addCommand({
      name: 'use',
      description: 'Select a server to use for direct tool calls (use <server-name>)',
      execute: async (args) => {
        if (this.isChatMode) return 'Cannot use specific servers in chat mode. Exit chat first.';
        if (!args[0]) {
          return 'Error: Server name required.';
        }

        const serverName = args[0];
        const servers = this.serverManager.getConnectedServers();
        
        if (!servers.includes(serverName)) {
          return `Error: Server '${serverName}' not found or not connected.`;
        }
        
        this.currentServer = serverName;
        this.rl.setPrompt(this.getPrompt());
        return `Now using server: ${serverName}`;
      }
    });
    
    // List tools command (no changes needed)
    this.addCommand({
      name: 'tools',
      description: 'List available tools on the current or specified server',
      execute: async (args) => {
         if (this.isChatMode) return 'Use "chat" to interact with the AI which knows available tools. Exit chat for direct tool listing.';
        try {
          const targetServer = args[0] || this.currentServer;

          if (!targetServer) {
            return 'Error: No server selected. Use "use <server-name>" or "tools <server-name>".';
          }

          const tools = this.serverManager.getServerTools(targetServer);

          if (tools.length === 0) {
            return `No tools available on server '${targetServer}'.`;
          }

          let output = `Tools available on server '${targetServer}':\n`;
          tools.forEach(tool => {
            // Add schema display later if needed
            output += `  ${tool.name} - ${tool.description || 'No description'}\n`;
          });

          return output;
        } catch (error) {
          return `Error: ${error instanceof Error ? error.message : String(error)}`;
        }
      }
    });

    // Execute tool command (no changes needed)
     this.addCommand({
       name: 'call',
       description: 'Execute a tool directly (call <tool-name> [json-args])',
       execute: async (args) => {
         if (this.isChatMode) return 'Cannot call tools directly in chat mode. The AI will call tools if needed. Exit chat first.';
         if (!args[0]) {
           return 'Error: Tool name required.';
         }

         const toolName = args[0];
         let toolArgs: Record<string, any> = {};

         // Parse JSON arguments if provided
         const jsonArgString = args.slice(1).join(' ');
         if (jsonArgString) {
           try {
             toolArgs = JSON.parse(jsonArgString);
             if (typeof toolArgs !== 'object' || toolArgs === null || Array.isArray(toolArgs)) {
                throw new Error("Arguments must be a JSON object.");
             }
           } catch (error) {
             return `Error parsing JSON arguments: ${error instanceof Error ? error.message : String(error)}`;
           }
         }

         // Determine which server to use
         let serverName = this.currentServer;

         // If no server selected, try to find a server that provides this tool
         if (!serverName) {
           serverName = this.serverManager.findToolProvider(toolName);
           if (!serverName) {
             return `Error: No server selected and no server found providing tool '${toolName}'. Use "use <server>" first or ensure the tool exists.`;
           }
           console.log(`Auto-selected server '${serverName}' for tool '${toolName}'`);
         }

         try {
           // Execute the tool with progress indicator
           const result = await this.serverManager.executeTool(serverName, toolName, toolArgs, {
             showProgress: true
           });

           if (result.isError) {
             return `Error executing tool '${toolName}': ${result.errorMessage}`;
           }

           // Format the result output
           let output = `Tool '${toolName}' execution result from ${serverName}:\n`;
           output += `Time: ${result.executionTime}ms\n`;
           output += `Result:\n`;

           // Format result based on type (assuming result.toolResult is the 'content' array)
           if (Array.isArray(result.toolResult)) {
               result.toolResult.forEach(contentItem => {
                   if (contentItem.type === 'text') {
                       output += contentItem.text;
                   } else if (contentItem.type === 'image' || contentItem.type === 'audio') {
                       output += `[${contentItem.type} data (mime: ${contentItem.mimeType})]`;
                   } else {
                       output += JSON.stringify(contentItem); // Fallback for other types
                   }
               });
           } else if (typeof result.toolResult === 'object' && result.toolResult !== null) {
             output += JSON.stringify(result.toolResult, null, 2);
           } else {
             output += String(result.toolResult);
           }

           return output;
         } catch (error) {
           return `Error: ${error instanceof Error ? error.message : String(error)}`;
         }
       }
     });


    // --- AI/Model Commands ---
    
    // List providers command
    this.addCommand({
      name: 'providers',
      description: 'List available AI providers and models',
      execute: async () => {
        const output: string[] = ['Available AI providers and models:'];
        
        for (const [providerName, config] of Object.entries(this.providers)) {
          const isCurrent = providerName === this.currentProvider;
          const prefix = isCurrent ? '* ' : '  ';
          output.push(`${prefix}${providerName}: ${config.model || 'No model specified'}`);
          
          // List available models for this provider
          const providerKey = providerName.toLowerCase();
          const models = this.providerModels[providerKey]?.models || [];
          if (models.length > 0) {
            output.push(`    Available models:`);
            for (const model of models) {
              const isCurrentModel = config.model === model;
              output.push(`    ${isCurrentModel ? '* ' : '  '}${model}`);
            }
          } else {
            output.push(`    No model suggestions available for this provider.`);
          }
          output.push(''); // Add blank line between providers
        }
        
        if (Object.keys(this.providers).length === 0) {
          output.push('No AI providers configured. Please check your ai_config.json file.');
        }
        
        return output.join('\n');
      }
    });
    
    // Switch provider command
    this.addCommand({
      name: 'provider',
      description: 'Set the current AI provider',
      execute: async (args) => {
        if (!args[0]) {
          return 'Error: Provider name required. Use "providers" command to see available providers.';
        }
        
        const providerName = args[0];
        if (!this.providers[providerName]) {
          return `Error: Provider '${providerName}' not found in config. Use "providers" command to see available providers.`;
        }
        
        // Set current provider
        this.currentProvider = providerName;
        
        // Save updated config to file
        this.saveAiConfig();
        
        // Switch the AI client
        try {
          const providerConfig = this.providers[providerName];
          const modelName = this.conversationManager.switchAiClient(providerConfig, this.providerModels);
          this.rl.setPrompt(this.getPrompt()); // Update prompt with new model
          return `Switched to provider: ${providerName} with model: ${modelName}`;
        } catch (error) {
          return `Error switching provider: ${error instanceof Error ? error.message : String(error)}`;
        }
      }
    });
    
    // Switch model command
    this.addCommand({
      name: 'model',
      description: 'Set the model for the current provider',
      execute: async (args) => {
        if (!this.currentProvider) {
          return 'Error: No provider selected. Use "provider <name>" command first.';
        }
        
        if (!args[0]) {
          return 'Error: Model name required. Use "providers" command to see available models.';
        }
        
        const modelName = args[0];
        const providerConfig = this.providers[this.currentProvider];
        const providerKey = this.currentProvider.toLowerCase();
        const models = this.providerModels[providerKey]?.models || [];
        
        // Check if model exists in available models
        if (models.length > 0 && !models.includes(modelName)) {
          return `Warning: Model '${modelName}' not found in suggested models for provider '${this.currentProvider}'. Continuing anyway.`;
        }
        
        // Update config
        this.providers[this.currentProvider].model = modelName;
        
        // Save updated config to file
        this.saveAiConfig();
        
        // Switch the AI client with the updated model
        try {
          const updatedModelName = this.conversationManager.switchAiClient(providerConfig, this.providerModels);
          this.rl.setPrompt(this.getPrompt()); // Update prompt with new model
          return `Switched model for provider '${this.currentProvider}' to: ${updatedModelName}`;
        } catch (error) {
          return `Error switching model: ${error instanceof Error ? error.message : String(error)}`;
        }
      }
    });

    // --- New/Modified Commands ---

    // Chat command to enter mode
    this.addCommand({
      name: 'chat',
      description: 'Enter interactive chat mode with the AI agent',
      execute: async () => {
        if (this.isChatMode) {
          return 'Already in chat mode.';
        }
        this.isChatMode = true;
        this.currentServer = null; // Deselect server when entering chat
        this.rl.setPrompt(this.getPrompt());
        return `Entered chat mode with ${this.conversationManager.getAiClientModelName()}. Type 'exit' to leave chat mode.`;
      }
    });

    // History command (only in chat mode)
    this.addCommand({
        name: 'history',
        description: 'Show the current conversation history (chat mode only)',
        execute: async () => {
            if (!this.isChatMode) {
                return 'The history command is only available in chat mode.';
            }
            const history = this.conversationManager.getHistory();
            if (history.length === 0) {
                return 'Conversation history is empty.';
            }
            let output = 'Conversation History:\n';
            output += '---------------------\n';
            history.forEach((msg, index) => {
                const role = msg._getType(); // Get role ('system', 'human', 'ai', 'tool')
                let contentPreview = '';
                if (typeof msg.content === 'string') {
                    contentPreview = msg.content.length > 100 ? msg.content.substring(0, 97) + '...' : msg.content;
                } else {
                    contentPreview = JSON.stringify(msg.content); // Handle complex content
                }
                output += `[${index}] ${role.toUpperCase()}: ${contentPreview}\n`;
            });
            output += '---------------------';
            return output;
        }
    });

     // Clear command (only in chat mode)
     this.addCommand({
         name: 'clear',
         description: 'Clear the current conversation history (chat mode only)',
         execute: async () => {
             if (!this.isChatMode) {
                 return 'The clear command is only available in chat mode.';
             }
             this.conversationManager.clearConversation();
             return 'Conversation history cleared.';
         }
     });


    // Exit command (handles both chat mode exit and REPL exit)
    this.addCommand({
      name: 'exit',
      description: 'Exit chat mode or the REPL',
      execute: async () => {
        if (this.isChatMode) {
          this.isChatMode = false;
          this.rl.setPrompt(this.getPrompt());
          return 'Exited chat mode.';
        } else {
          this.stop();
          return 'Exiting MCP Multi-Client...';
        }
      }
    });

    // Alias for exit
    this.addCommand({
      name: 'quit',
      description: 'Alias for exit',
      execute: async () => {
        // Directly call the exit command's logic
        const exitCommand = this.commands.get('exit');
        if (exitCommand) {
            return exitCommand.execute([]);
        }
        return ''; // Should not happen
      }
    });
  }
  
  /**
   * Add a new command to the REPL
   */
  addCommand(command: Command) {
    this.commands.set(command.name, command);
  }
  
  /**
   * Start the REPL interface
   */
  start() {
    if (this.running) return;
    this.running = true;

    console.log('MCP Multi-Client Interactive Console');
    console.log('Type "help" for available commands.');
    console.log('Use "chat" to talk to the AI agent.'); // Updated help text
    console.log('-'.repeat(40));

    this.rl.prompt();

    this.rl.on('line', async (line) => {
      const trimmedLine = line.trim();

      // Skip empty lines
      if (!trimmedLine) {
        this.rl.prompt();
        return;
      }

      // Add to history (basic readline history)
      // this.history.push(trimmedLine);
      // this.historyIndex = this.history.length;

      if (this.isChatMode) {
        // Handle chat input
        if (trimmedLine.toLowerCase() === 'exit' || trimmedLine.toLowerCase() === 'quit') {
          const result = await this.commands.get('exit')!.execute([]);
          console.log(result);
        } else if (trimmedLine.toLowerCase() === 'history') {
           const result = await this.commands.get('history')!.execute([]);
           console.log(result);
        } else if (trimmedLine.toLowerCase() === 'clear') {
            const result = await this.commands.get('clear')!.execute([]);
            console.log(result);
        } else {
          // Send to conversation manager
          process.stdout.write('AI is thinking... ');
          const frames = ['-', '\\', '|', '/'];
          let i = 0;
          const thinkingInterval = setInterval(() => {
              process.stdout.write(`\rAI is thinking... ${frames[i++ % frames.length]}`);
          }, 100);

          try {
            const aiResponse = await this.conversationManager.processUserMessage(trimmedLine);
            clearInterval(thinkingInterval);
            process.stdout.write('\r' + ' '.repeat(20) + '\r'); // Clear thinking indicator
            console.log(`AI: ${aiResponse}`);
          } catch (error) {
             clearInterval(thinkingInterval);
             process.stdout.write('\r' + ' '.repeat(20) + '\r'); // Clear thinking indicator
            console.error('Chat processing error:', error instanceof Error ? error.message : String(error));
          }
        }
      } else {
        // Handle command input
        const parts = trimmedLine.split(' ');
        const commandName = parts[0].toLowerCase();
        const args = parts.slice(1);

        if (this.commands.has(commandName)) {
          try {
            const result = await this.commands.get(commandName)!.execute(args);
            if (result) console.log(result);
          } catch (error) {
            console.error('Command execution error:', error instanceof Error ? error.message : String(error));
          }
        } else {
          console.log(`Unknown command: ${commandName}. Type "help" for available commands or "chat" to talk to the AI.`);
        }
      }

      // Update prompt and show it for next input, unless REPL was stopped
      if (this.running) {
        this.rl.setPrompt(this.getPrompt());
        this.rl.prompt();
      }
    });

    // Handle CTRL+C
    this.rl.on('SIGINT', () => {
      if (this.isChatMode) {
          console.log('\nType "exit" or "quit" to leave chat mode.');
          this.rl.prompt();
      } else {
          // Default SIGINT behavior (or custom exit prompt)
          console.log('\nUse "exit" or "quit" to exit the REPL. Press Ctrl+C again to force exit.');
          // Maybe exit directly on second Ctrl+C?
          this.rl.prompt(); // Re-prompt in command mode
      }
    });
  }
  
  /**
   * Stop the REPL interface
   */
  stop() {
    if (!this.running) return;
    this.running = false;
    this.rl.close();
    console.log("REPL stopped."); // Add log message
  }
}
</file>

<file path="src/ServerManager.ts">
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';
import { 
  ConfigFileStructure, 
  ServerConnection, 
  ToolExecutionOptions,
  ToolExecutionResult,
  StdioServerConfig // Import StdioServerConfig
} from './types.js';
import type { Implementation, Tool } from '@modelcontextprotocol/sdk/types.js'; // Import Tool

/**
 * Manages connections to multiple MCP servers
 */
export class ServerManager {
  private servers: Record<string, ServerConnection> = {};
  private config: ConfigFileStructure; // Keep config to access mcpServers easily
  private defaultToolTimeout: number; // milliseconds

  constructor(config: ConfigFileStructure) {
    this.config = config;
    // Use a hardcoded default timeout since it's removed from config
    this.defaultToolTimeout = 300 * 1000; // 300 seconds in ms
  }

  /**
   * Connect to all servers defined in the configuration
   */
  async connectAll(): Promise<string[]> {
    const connectionPromises: Array<Promise<string>> = [];
    
    for (const [serverName, serverConfig] of Object.entries(this.config.mcpServers)) {
      connectionPromises.push(this.connectToServer(serverName, serverConfig));
    }
    
    const results = await Promise.allSettled(connectionPromises);
    
    // Filter for fulfilled promises and return their values
    return results
      .filter((result): result is PromiseFulfilledResult<string> => result.status === 'fulfilled')
      .map(result => result.value);
  }

  /**
   * Connect to a specific server
   */
  async connectToServer(serverName: string, serverConfig: StdioServerConfig): Promise<string> {
    console.log(`[${serverName}] Attempting to connect...`);

     // Check if already connected or connection attempt in progress
     if (this.servers[serverName]?.isConnected) {
         console.log(`[${serverName}] Already connected.`);
         return serverName;
     }
      if (this.servers[serverName]) {
         console.log(`[${serverName}] Connection attempt already made (failed?). Skipping.`);
         // Or potentially retry logic here? For now, just skip.
         throw new Error(`Previous connection attempt failed for ${serverName}.`);
     }

    try {
      // Create transport
      const transport = new StdioClientTransport({
        command: serverConfig.command,
        args: serverConfig.args || [],
         // Apply environment variables if defined
         env: { ...Object.fromEntries(Object.entries(process.env).filter(([_, v]) => v !== undefined)) as Record<string, string>, ...(serverConfig.env || {}) }
      });

      // Set up transport error handlers
      transport.onerror = (error) => {
        console.error(`[${serverName}] Transport error:`, error.message);
        if (this.servers[serverName]) {
          this.servers[serverName].isConnected = false;
        }
      };
      
      transport.onclose = () => {
        console.log(`[${serverName}] Connection closed.`);
        if (this.servers[serverName]) {
          this.servers[serverName].isConnected = false;
        }
      };
      // Create client
      const clientInfo: Implementation = {
        name: `mcp-multi-client-${serverName.replace(/\s+/g, '-')}`, // Consistent name prefix
        version: '1.0.0', // Use version from package.json?
      };

      const client = new Client(clientInfo);

       // Store connection attempt immediately
        this.servers[serverName] = {
          client,
          transport,
          isConnected: false, // Mark as not connected until successful
          config: serverConfig,
        };

      // Connect client to transport
      await client.connect(transport);

      // Fetch tools after successful connection
      let tools: Tool[] = [];
      try {
        const toolResult = await client.listTools();
        tools = toolResult.tools || [];
        console.log(`[${serverName}] Found ${tools.length} tools.`);
      } catch (toolError) {
        console.warn(`[${serverName}] Failed to list tools after connection: ${toolError instanceof Error ? toolError.message : String(toolError)}`);
        // Continue connection even if tools fail to list
      }

      // Update server state
      this.servers[serverName] = {
        client,
        transport,
        tools,
        isConnected: true,
        config: serverConfig,
      };

      return serverName; // Return server name on success
    } catch (error) {
      console.error(`[${serverName}] Error during connection: ${error instanceof Error ? error.message : String(error)}`);
       // Ensure server entry exists but is marked as not connected
        this.servers[serverName] = {
          // @ts-ignore
          client: undefined,
          // @ts-ignore
          transport: undefined,
          isConnected: false,
          config: serverConfig,
        };
      // Ensure server entry exists but is marked as not connected on failure
      if (!this.servers[serverName]) {
          this.servers[serverName] = {
            // @ts-ignore - Client/Transport might be undefined here
            client: undefined, transport: undefined,
            isConnected: false,
            config: serverConfig,
          };
      } else {
          // If entry exists (e.g., from a previous failed attempt), mark as not connected
          this.servers[serverName].isConnected = false;
          // Optionally clear client/transport if they exist from a previous attempt?
          // this.servers[serverName].client = undefined;
          // this.servers[serverName].transport = undefined;
      }
      throw error; // Re-throw the error to be caught by connectAll or caller
    }
  }

  /**
   * List names of servers currently marked as connected.
   */
  getConnectedServers(): string[] {
    return Object.entries(this.servers)
      .filter(([_, connection]) => connection?.isConnected) // Check connection exists and isConnected
      .map(([name]) => name);
  }

  /**
   * Get the status of all configured servers.
   * @returns Record mapping server name to its status ('connected', 'disconnected', 'error', 'connecting').
   */
  getServerStatuses(): Record<string, { status: 'connected' | 'disconnected' | 'error' | 'connecting', error?: string }> {
      const statuses: Record<string, { status: 'connected' | 'disconnected' | 'error' | 'connecting', error?: string }> = {};
      for (const serverName in this.config.mcpServers) {
          const connection = this.servers[serverName];
          if (connection?.isConnected) {
              statuses[serverName] = { status: 'connected' };
          } else if (connection) {
              // Entry exists but not connected - could be error or just disconnected
              // TODO: Differentiate between explicit disconnect and connection error if needed
              statuses[serverName] = { status: 'disconnected' }; // Or 'error' if we store error state
          } else {
              // No connection entry yet - implies disconnected or never attempted
              statuses[serverName] = { status: 'disconnected' };
          }
      }
      return statuses;
  }

  /**
   * Attempts to reconnect to all servers currently marked as disconnected or errored.
   */
  async retryAllFailedConnections(): Promise<string[]> {
      console.log('Attempting to reconnect to failed/disconnected servers...');
      const retryPromises: Array<Promise<string>> = [];
      const failedServerNames = Object.entries(this.servers)
          .filter(([_, connection]) => !connection?.isConnected)
          .map(([name]) => name);

      // Include servers from config that never had a connection attempt
      for (const serverName in this.config.mcpServers) {
          if (!this.servers[serverName]) {
              failedServerNames.push(serverName);
          }
      }

      const uniqueFailedNames = [...new Set(failedServerNames)]; // Ensure unique names

      if (uniqueFailedNames.length === 0) {
          console.log('No servers need reconnection.');
          return this.getConnectedServers();
      }

      console.log(`Retrying connections for: ${uniqueFailedNames.join(', ')}`);

      for (const serverName of uniqueFailedNames) {
          const serverConfig = this.config.mcpServers[serverName];
          if (serverConfig) {
              // Clear existing failed state before retrying
              delete this.servers[serverName];
              retryPromises.push(this.connectToServer(serverName, serverConfig));
          } else {
              console.warn(`Config not found for server ${serverName} during retry.`);
          }
      }

      const results = await Promise.allSettled(retryPromises);

      // Log results of retries
      results.forEach((result, index) => {
          const serverName = uniqueFailedNames[index];
          if (result.status === 'fulfilled') {
              console.log(`[${serverName}] Reconnection successful.`);
          } else {
              console.error(`[${serverName}] Reconnection failed: ${result.reason}`);
          }
      });

      return this.getConnectedServers(); // Return the updated list of connected servers
  }

  /**
   * List all tools for a specific server
   */
  getServerTools(serverName: string): Tool[] {
    const server = this.servers[serverName];
    // Allow getting tools even if temporarily disconnected, if they were fetched previously
    if (!server) {
        throw new Error(`Server ${serverName} is not configured.`);
    }
    if (!server.isConnected && !server.tools) {
        // Only throw if not connected AND tools were never fetched
        throw new Error(`Server ${serverName} is not connected and tools are unavailable.`);
    }
    // Return cached tools if available, even if currently disconnected
    return server.tools || [];
  }

   /**
    * Get all tools from all connected servers.
    */
   async getAllTools(): Promise<Tool[]> {
       const allTools: Tool[] = [];
       const connectedServers = this.getConnectedServers();

       for (const serverName of connectedServers) {
           try {
               // Re-fetch tools in case they changed, or use cached ones if confident
               const connection = this.servers[serverName];
               if (connection?.isConnected && connection.client) {
                   // Option 1: Use cached tools (faster, might be stale)
                   // if (connection.tools) {
                   //    allTools.push(...connection.tools);
                   // }

                   // Option 2: Re-fetch tools (slower, always up-to-date)
                   const toolResult = await connection.client.listTools();
                   const tools = toolResult.tools || [];
                   // Add server name prefix to tool name if needed for uniqueness?
                   // For now, just collect them. Ensure unique names later if necessary.
                   allTools.push(...tools);
                   // Update cache
                   connection.tools = tools;

               }
           } catch (error) {
               console.warn(`[${serverName}] Failed to list tools for getAllTools: ${error instanceof Error ? error.message : String(error)}`);
               // Optionally skip tools from this server if listing fails
           }
       }

       // TODO: Consider handling duplicate tool names across servers if necessary
       // For now, just return the combined list.
       return allTools;
   }


  /**
   * Execute a tool on a specific server
   */
  async executeTool(
    serverName: string, 
    toolName: string, 
    args: Record<string, any>,
    options: ToolExecutionOptions = {}
  ): Promise<ToolExecutionResult> {
    const startTime = Date.now();
    
    // Get server connection
    const server = this.servers[serverName];
    if (!server || !server.isConnected || !server.client) { // Check for client existence
       return {
         serverName,
         toolName,
         executionTime: Date.now() - startTime,
         isError: true,
         errorMessage: `Server '${serverName}' not found or not connected.`,
       };
    }

    // Find the specific tool to check schema (optional but good practice)
    const toolDefinition = server.tools?.find(t => t.name === toolName);
    if (!toolDefinition) {
       // Tool might exist but wasn't listed? Proceed cautiously or error out.
       console.warn(`[${serverName}] Tool '${toolName}' not found in listed tools. Attempting execution anyway.`);
       // return { serverName, toolName, executionTime: Date.now() - startTime, isError: true, errorMessage: `Tool '${toolName}' not found on server '${serverName}'.` };
    }

    // TODO: Validate args against toolDefinition.input_schema using Zod if desired

    // Set up timeout
    const timeoutMs = options?.timeout ? options.timeout * 1000 : this.defaultToolTimeout;

    // Show progress indicator if requested
    let progressInterval: NodeJS.Timeout | undefined;
    if (options.showProgress) {
      const spinner = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'];
      let i = 0;
      process.stdout.write(`\r[${serverName}] Executing tool '${toolName}'... ${spinner[i]} `);
      progressInterval = setInterval(() => {
        i = (i + 1) % spinner.length;
        process.stdout.write(`\r[${serverName}] Executing tool '${toolName}'... ${spinner[i]} `);
      }, 100);
    }
    try {
      // Execute with timeout
      const result = await server.client.callTool(
         { name: toolName, arguments: args } // Use 'arguments' field
       );
    
      // ---> DEBUG LOG <---
      console.log('[ServerManager] Raw tool result from SDK:', JSON.stringify(result, null, 2));
      // ---> END DEBUG LOG <---
    
      // Check if the tool itself reported an error
      if (result.isError) {
          // Extract error message from the tool's response content if possible
          let errorMessage = `Tool '${toolName}' reported an error.`;
          // Check if result.content is an array with items 
          if (Array.isArray(result.content) && result.content.length > 0) {
            const item = result.content[0];
            if (item && typeof item === 'object' && 'type' in item && item.type === 'text' && 'text' in item) {
              errorMessage = item.text as string;
            }
          }
          return {
              serverName,
              toolName,
              executionTime: Date.now() - startTime,
              isError: true,
              errorMessage: errorMessage,
              toolResult: result.content // Include the raw error content
          };
      }

      // Return formatted result
      return {
        serverName,
        toolName,
        executionTime: Date.now() - startTime,
        toolResult: result.content, // Return the structured content
        isError: false,
      };
    } catch (error) {
       console.error(`[${serverName}] Error executing tool '${toolName}':`, error); // Log the error
      return {
        serverName,
        toolName,
        executionTime: Date.now() - startTime,
        isError: true,
        errorMessage: error instanceof Error ? error.message : String(error)
      };
    } finally {
      // Clear progress indicator if it was shown
      if (progressInterval) {
        clearInterval(progressInterval);
        if (options.showProgress) {
          process.stdout.write('\r' + ' '.repeat(80) + '\r'); // Clear the line
        }
      }
    }
  }

  /**
   * Find which server provides a specific tool
   */
  findToolProvider(toolName: string): string | null {
    for (const [serverName, connection] of Object.entries(this.servers)) {
      if (!connection.isConnected || !connection.tools) continue;
      
      const hasTool = connection.tools.some(tool => tool.name === toolName);
      if (hasTool) return serverName;
    }
    
    return null;
  }

  /**
   * Close all server connections
   */
  async closeAll(): Promise<void> {
    const closePromises = Object.entries(this.servers).map(async ([name, connection]) => {
      if (connection.isConnected) {
        console.log(`Closing connection to ${name}...`);
        try {
          await connection.transport.close();
          connection.isConnected = false;
        } catch (error) {
          console.error(`Error closing connection to ${name}:`,
            error instanceof Error ? error.message : String(error));
        }
      }
    });

    await Promise.allSettled(closePromises);
     // Clean up server entries after attempting to close
     this.servers = {};
     console.log('Finished closing server connections.');
  }
}
</file>

<file path="src/types.ts">
import type { Client } from '@modelcontextprotocol/sdk/client/index.js';
import type { Transport } from '@modelcontextprotocol/sdk/shared/transport.js';
import type { StdioServerParameters } from '@modelcontextprotocol/sdk/client/stdio.js';
import type { Tool } from '@modelcontextprotocol/sdk/types.js';
// Import LangChain message types
import type { BaseMessage } from '@langchain/core/messages';

/**
 * Configuration for a single stdio server
 */
export interface StdioServerConfig extends Omit<StdioServerParameters, 'env'> {
  env?: Record<string, string>;
}

/**
 * Configuration for an AI Provider
 */
export interface AiProviderConfig {
  provider: string; // e.g., "openai", "anthropic", "google-genai", "mistralai", "fireworks"
  model?: string; // Optional: e.g., "gpt-4o-mini", "claude-3-5-sonnet-20240620" - If omitted, uses default from TOML
  apiKeyEnvVar?: string; // Optional: Environment variable name for the API key (used if apiKey is not set)
  apiKey?: string; // Optional: Direct API key (takes precedence over apiKeyEnvVar) - Use with caution!
  temperature?: number; // Optional: Model temperature
  // Add other provider-specific options if needed
}

/**
 * Structure of the servers.json file (or main config)
 */
export interface ConfigFileStructure {
  mcpServers: Record<string, StdioServerConfig>;
  // timeouts removed
  // AI configuration moved to AiConfigFileStructure
}

/**
 * Structure for the ai_config.json file
 */
export interface AiConfigFileStructure {
  defaultProvider?: string; // Name of the default provider key below
  providers: Record<string, AiProviderConfig>; // Map of provider configurations
}

/**
 * Server connection details
 */
export interface ServerConnection {
  client: Client;
  transport: Transport;
  tools?: Tool[];
  isConnected: boolean;
  config: StdioServerConfig; // Keep config for potential restarts
}

/**
 * Tool execution options
 */
export interface ToolExecutionOptions {
  timeout?: number;
  showProgress?: boolean;
}

/**
 * Result of a tool execution
 */
export interface ToolExecutionResult {
  serverName: string;
  toolName: string;
  executionTime: number;
  toolResult?: any;  // The actual result
  isError?: boolean;
  errorMessage?: string;
}

/**
 * REPL command definition
 */
export interface Command {
  name: string;
  description: string;
  execute: (args: string[]) => Promise<string | void>;
}

/**
 * Type alias for LangChain messages used in conversation state
 */
export type ConversationMessage = BaseMessage;


/**
 * Structure for the provider_models.toml file content
 */
export interface ProviderModelList {
    models: string[];
}

export type ProviderModelsStructure = Record<string, ProviderModelList>;
</file>

<file path="web/build/build-css.js">
// Simple build script for when Tailwind CLI isn't available
import fs from 'fs';
import path from 'path';

// Paths
const baseCssPath = path.join(process.cwd(), 'web', 'css', 'base.css');
const outputPath = path.join(process.cwd(), 'web', 'build', 'tailwind.css');
const tailwindFallbackPath = path.join(process.cwd(), 'web', 'build', 'tailwind-fallback.css');

// Read base CSS
try {
  console.log('Building CSS...');
  
  // Check if tailwind fallback exists
  if (fs.existsSync(tailwindFallbackPath)) {
    const fallbackCss = fs.readFileSync(tailwindFallbackPath, 'utf8');
    const baseCss = fs.existsSync(baseCssPath) 
      ? fs.readFileSync(baseCssPath, 'utf8') 
      : '/* Base CSS not found */';
    
    // Combine files
    const combinedCss = `${baseCss}\n\n/* Fallback Tailwind utilities */\n${fallbackCss}`;
    
    // Write combined CSS
    fs.writeFileSync(outputPath, combinedCss);
    console.log('CSS built successfully using fallback approach.');
  } else {
    console.log('Tailwind fallback not found. Creating minimal version.');
    // If no fallback, just copy base CSS as is
    if (fs.existsSync(baseCssPath)) {
      const baseCss = fs.readFileSync(baseCssPath, 'utf8');
      fs.writeFileSync(outputPath, baseCss);
      console.log('Minimal CSS built. Consider installing Tailwind CSS for full functionality.');
    } else {
      console.error('Base CSS file not found!');
      process.exit(1);
    }
  }
} catch (error) {
  console.error('Error building CSS:', error);
  process.exit(1);
}
</file>

<file path="web/build/tailwind-fallback.css">
/* Tailwind utility classes fallback */
.container { width: 100%; }
@media (min-width: 640px) { .container { max-width: 640px; } }
@media (min-width: 768px) { .container { max-width: 768px; } }
@media (min-width: 1024px) { .container { max-width: 1024px; } }
@media (min-width: 1280px) { .container { max-width: 1280px; } }

/* Flexbox */
.flex { display: flex; }
.flex-row { flex-direction: row; }
.flex-col { flex-direction: column; }
.flex-wrap { flex-wrap: wrap; }
.flex-nowrap { flex-wrap: nowrap; }
.flex-1 { flex: 1 1 0%; }
.flex-auto { flex: 1 1 auto; }
.flex-initial { flex: 0 1 auto; }
.flex-none { flex: none; }
.flex-grow { flex-grow: 1; }
.flex-grow-0 { flex-grow: 0; }
.flex-shrink { flex-shrink: 1; }
.flex-shrink-0 { flex-shrink: 0; }

/* Justify Content */
.justify-start { justify-content: flex-start; }
.justify-end { justify-content: flex-end; }
.justify-center { justify-content: center; }
.justify-between { justify-content: space-between; }
.justify-around { justify-content: space-around; }
.justify-evenly { justify-content: space-evenly; }

/* Align Items */
.items-start { align-items: flex-start; }
.items-end { align-items: flex-end; }
.items-center { align-items: center; }
.items-baseline { align-items: baseline; }
.items-stretch { align-items: stretch; }

/* Spacing */
.p-0 { padding: 0; }
.p-1 { padding: 0.25rem; }
.p-2 { padding: 0.5rem; }
.p-3 { padding: 0.75rem; }
.p-4 { padding: 1rem; }
.p-5 { padding: 1.25rem; }
.p-6 { padding: 1.5rem; }
.py-1 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
.py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
.py-3 { padding-top: 0.75rem; padding-bottom: 0.75rem; }
.py-4 { padding-top: 1rem; padding-bottom: 1rem; }
.px-1 { padding-left: 0.25rem; padding-right: 0.25rem; }
.px-2 { padding-left: 0.5rem; padding-right: 0.5rem; }
.px-3 { padding-left: 0.75rem; padding-right: 0.75rem; }
.px-4 { padding-left: 1rem; padding-right: 1rem; }
.m-0 { margin: 0; }
.m-1 { margin: 0.25rem; }
.m-2 { margin: 0.5rem; }
.m-3 { margin: 0.75rem; }
.m-4 { margin: 1rem; }
.my-1 { margin-top: 0.25rem; margin-bottom: 0.25rem; }
.my-2 { margin-top: 0.5rem; margin-bottom: 0.5rem; }
.my-3 { margin-top: 0.75rem; margin-bottom: 0.75rem; }
.my-4 { margin-top: 1rem; margin-bottom: 1rem; }
.mx-1 { margin-left: 0.25rem; margin-right: 0.25rem; }
.mx-2 { margin-left: 0.5rem; margin-right: 0.5rem; }
.mx-3 { margin-left: 0.75rem; margin-right: 0.75rem; }
.mx-4 { margin-left: 1rem; margin-right: 1rem; }
.mt-1 { margin-top: 0.25rem; }
.mt-2 { margin-top: 0.5rem; }
.mt-3 { margin-top: 0.75rem; }
.mt-4 { margin-top: 1rem; }
.mr-1 { margin-right: 0.25rem; }
.mr-2 { margin-right: 0.5rem; }
.mr-3 { margin-right: 0.75rem; }
.mr-4 { margin-right: 1rem; }
.mb-1 { margin-bottom: 0.25rem; }
.mb-2 { margin-bottom: 0.5rem; }
.mb-3 { margin-bottom: 0.75rem; }
.mb-4 { margin-bottom: 1rem; }
.ml-1 { margin-left: 0.25rem; }
.ml-2 { margin-left: 0.5rem; }
.ml-3 { margin-left: 0.75rem; }
.ml-4 { margin-left: 1rem; }

/* Colors */
.bg-transparent { background-color: transparent; }
.bg-white { background-color: #ffffff; }
.bg-black { background-color: #000000; }
.bg-gray-100 { background-color: #f3f4f6; }
.bg-gray-200 { background-color: #e5e7eb; }
.bg-gray-300 { background-color: #d1d5db; }
.bg-gray-400 { background-color: #9ca3af; }
.bg-gray-500 { background-color: #6b7280; }
.bg-gray-600 { background-color: #4b5563; }
.bg-gray-700 { background-color: #374151; }
.bg-gray-800 { background-color: #1f2937; }
.bg-gray-900 { background-color: #111827; }
.bg-red-500 { background-color: #ef4444; }
.bg-blue-500 { background-color: #3b82f6; }
.bg-blue-600 { background-color: #2563eb; }
.bg-green-500 { background-color: #22c55e; }

.text-white { color: #ffffff; }
.text-black { color: #000000; }
.text-gray-100 { color: #f3f4f6; }
.text-gray-200 { color: #e5e7eb; }
.text-gray-300 { color: #d1d5db; }
.text-gray-400 { color: #9ca3af; }
.text-gray-500 { color: #6b7280; }
.text-gray-600 { color: #4b5563; }
.text-gray-700 { color: #374151; }
.text-gray-800 { color: #1f2937; }
.text-gray-900 { color: #111827; }
.text-red-500 { color: #ef4444; }
.text-blue-500 { color: #3b82f6; }
.text-green-500 { color: #22c55e; }

/* Border */
.border { border-width: 1px; }
.border-0 { border-width: 0; }
.border-2 { border-width: 2px; }
.border-4 { border-width: 4px; }
.border-t { border-top-width: 1px; }
.border-r { border-right-width: 1px; }
.border-b { border-bottom-width: 1px; }
.border-l { border-left-width: 1px; }
.border-white { border-color: #ffffff; }
.border-gray-200 { border-color: #e5e7eb; }
.border-gray-300 { border-color: #d1d5db; }
.border-gray-400 { border-color: #9ca3af; }
.border-gray-500 { border-color: #6b7280; }
.border-gray-600 { border-color: #4b5563; }

/* Rounded corners */
.rounded-none { border-radius: 0; }
.rounded-sm { border-radius: 0.125rem; }
.rounded { border-radius: 0.25rem; }
.rounded-md { border-radius: 0.375rem; }
.rounded-lg { border-radius: 0.5rem; }
.rounded-xl { border-radius: 0.75rem; }
.rounded-2xl { border-radius: 1rem; }
.rounded-3xl { border-radius: 1.5rem; }
.rounded-full { border-radius: 9999px; }

/* Typography */
.text-xs { font-size: 0.75rem; }
.text-sm { font-size: 0.875rem; }
.text-base { font-size: 1rem; }
.text-lg { font-size: 1.125rem; }
.text-xl { font-size: 1.25rem; }
.text-2xl { font-size: 1.5rem; }
.text-3xl { font-size: 1.875rem; }
.font-thin { font-weight: 100; }
.font-light { font-weight: 300; }
.font-normal { font-weight: 400; }
.font-medium { font-weight: 500; }
.font-semibold { font-weight: 600; }
.font-bold { font-weight: 700; }
.font-extrabold { font-weight: 800; }
.font-black { font-weight: 900; }
.text-left { text-align: left; }
.text-center { text-align: center; }
.text-right { text-align: right; }
.text-justify { text-align: justify; }

/* Display & Position */
.block { display: block; }
.inline-block { display: inline-block; }
.inline { display: inline; }
.hidden { display: none; }
.relative { position: relative; }
.absolute { position: absolute; }
.fixed { position: fixed; }
.sticky { position: sticky; }
.static { position: static; }
.inset-0 { top: 0; right: 0; bottom: 0; left: 0; }
.top-0 { top: 0; }
.right-0 { right: 0; }
.bottom-0 { bottom: 0; }
.left-0 { left: 0; }

/* Width & Height */
.w-full { width: 100%; }
.w-auto { width: auto; }
.w-1\/2 { width: 50%; }
.w-1\/3 { width: 33.333333%; }
.w-2\/3 { width: 66.666667%; }
.w-1\/4 { width: 25%; }
.w-3\/4 { width: 75%; }
.h-full { height: 100%; }
.h-auto { height: auto; }
.h-screen { height: 100vh; }
.min-h-screen { min-height: 100vh; }
.max-w-xs { max-width: 20rem; }
.max-w-sm { max-width: 24rem; }
.max-w-md { max-width: 28rem; }
.max-w-lg { max-width: 32rem; }
.max-w-xl { max-width: 36rem; }
.max-w-2xl { max-width: 42rem; }
.max-w-3xl { max-width: 48rem; }
.max-w-full { max-width: 100%; }

/* Overflow */
.overflow-auto { overflow: auto; }
.overflow-hidden { overflow: hidden; }
.overflow-visible { overflow: visible; }
.overflow-scroll { overflow: scroll; }
.overflow-x-auto { overflow-x: auto; }
.overflow-y-auto { overflow-y: auto; }
.overflow-x-hidden { overflow-x: hidden; }
.overflow-y-hidden { overflow-y: hidden; }
.overflow-x-visible { overflow-x: visible; }
.overflow-y-visible { overflow-y: visible; }
.overflow-x-scroll { overflow-x: scroll; }
.overflow-y-scroll { overflow-y: scroll; }

/* Z-Index */
.z-0 { z-index: 0; }
.z-10 { z-index: 10; }
.z-20 { z-index: 20; }
.z-30 { z-index: 30; }
.z-40 { z-index: 40; }
.z-50 { z-index: 50; }
.z-auto { z-index: auto; }

/* Shadows */
.shadow-sm { box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); }
.shadow { box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06); }
.shadow-md { box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
.shadow-lg { box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); }
</file>

<file path="web/build/tailwind.css">
/* Simplified base styles with Tailwind */
:root {
  /* Core color variables that might be needed for JS references */
  --primary-color: #3b82f6;
  --secondary-color: #6366f1;
  --success-color: #22c55e;
  --warning-color: #f59e0b;
  --danger-color: #ef4444;
}

/* Only apply basic resets if they're not covered by Tailwind */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

/* Fallback Tailwind utilities */
/* Tailwind utility classes fallback */
.container { width: 100%; }
@media (min-width: 640px) { .container { max-width: 640px; } }
@media (min-width: 768px) { .container { max-width: 768px; } }
@media (min-width: 1024px) { .container { max-width: 1024px; } }
@media (min-width: 1280px) { .container { max-width: 1280px; } }

/* Flexbox */
.flex { display: flex; }
.flex-row { flex-direction: row; }
.flex-col { flex-direction: column; }
.flex-wrap { flex-wrap: wrap; }
.flex-nowrap { flex-wrap: nowrap; }
.flex-1 { flex: 1 1 0%; }
.flex-auto { flex: 1 1 auto; }
.flex-initial { flex: 0 1 auto; }
.flex-none { flex: none; }
.flex-grow { flex-grow: 1; }
.flex-grow-0 { flex-grow: 0; }
.flex-shrink { flex-shrink: 1; }
.flex-shrink-0 { flex-shrink: 0; }

/* Justify Content */
.justify-start { justify-content: flex-start; }
.justify-end { justify-content: flex-end; }
.justify-center { justify-content: center; }
.justify-between { justify-content: space-between; }
.justify-around { justify-content: space-around; }
.justify-evenly { justify-content: space-evenly; }

/* Align Items */
.items-start { align-items: flex-start; }
.items-end { align-items: flex-end; }
.items-center { align-items: center; }
.items-baseline { align-items: baseline; }
.items-stretch { align-items: stretch; }

/* Spacing */
.p-0 { padding: 0; }
.p-1 { padding: 0.25rem; }
.p-2 { padding: 0.5rem; }
.p-3 { padding: 0.75rem; }
.p-4 { padding: 1rem; }
.p-5 { padding: 1.25rem; }
.p-6 { padding: 1.5rem; }
.py-1 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
.py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
.py-3 { padding-top: 0.75rem; padding-bottom: 0.75rem; }
.py-4 { padding-top: 1rem; padding-bottom: 1rem; }
.px-1 { padding-left: 0.25rem; padding-right: 0.25rem; }
.px-2 { padding-left: 0.5rem; padding-right: 0.5rem; }
.px-3 { padding-left: 0.75rem; padding-right: 0.75rem; }
.px-4 { padding-left: 1rem; padding-right: 1rem; }
.m-0 { margin: 0; }
.m-1 { margin: 0.25rem; }
.m-2 { margin: 0.5rem; }
.m-3 { margin: 0.75rem; }
.m-4 { margin: 1rem; }
.my-1 { margin-top: 0.25rem; margin-bottom: 0.25rem; }
.my-2 { margin-top: 0.5rem; margin-bottom: 0.5rem; }
.my-3 { margin-top: 0.75rem; margin-bottom: 0.75rem; }
.my-4 { margin-top: 1rem; margin-bottom: 1rem; }
.mx-1 { margin-left: 0.25rem; margin-right: 0.25rem; }
.mx-2 { margin-left: 0.5rem; margin-right: 0.5rem; }
.mx-3 { margin-left: 0.75rem; margin-right: 0.75rem; }
.mx-4 { margin-left: 1rem; margin-right: 1rem; }
.mt-1 { margin-top: 0.25rem; }
.mt-2 { margin-top: 0.5rem; }
.mt-3 { margin-top: 0.75rem; }
.mt-4 { margin-top: 1rem; }
.mr-1 { margin-right: 0.25rem; }
.mr-2 { margin-right: 0.5rem; }
.mr-3 { margin-right: 0.75rem; }
.mr-4 { margin-right: 1rem; }
.mb-1 { margin-bottom: 0.25rem; }
.mb-2 { margin-bottom: 0.5rem; }
.mb-3 { margin-bottom: 0.75rem; }
.mb-4 { margin-bottom: 1rem; }
.ml-1 { margin-left: 0.25rem; }
.ml-2 { margin-left: 0.5rem; }
.ml-3 { margin-left: 0.75rem; }
.ml-4 { margin-left: 1rem; }

/* Colors */
.bg-transparent { background-color: transparent; }
.bg-white { background-color: #ffffff; }
.bg-black { background-color: #000000; }
.bg-gray-100 { background-color: #f3f4f6; }
.bg-gray-200 { background-color: #e5e7eb; }
.bg-gray-300 { background-color: #d1d5db; }
.bg-gray-400 { background-color: #9ca3af; }
.bg-gray-500 { background-color: #6b7280; }
.bg-gray-600 { background-color: #4b5563; }
.bg-gray-700 { background-color: #374151; }
.bg-gray-800 { background-color: #1f2937; }
.bg-gray-900 { background-color: #111827; }
.bg-red-500 { background-color: #ef4444; }
.bg-blue-500 { background-color: #3b82f6; }
.bg-blue-600 { background-color: #2563eb; }
.bg-green-500 { background-color: #22c55e; }

.text-white { color: #ffffff; }
.text-black { color: #000000; }
.text-gray-100 { color: #f3f4f6; }
.text-gray-200 { color: #e5e7eb; }
.text-gray-300 { color: #d1d5db; }
.text-gray-400 { color: #9ca3af; }
.text-gray-500 { color: #6b7280; }
.text-gray-600 { color: #4b5563; }
.text-gray-700 { color: #374151; }
.text-gray-800 { color: #1f2937; }
.text-gray-900 { color: #111827; }
.text-red-500 { color: #ef4444; }
.text-blue-500 { color: #3b82f6; }
.text-green-500 { color: #22c55e; }

/* Border */
.border { border-width: 1px; }
.border-0 { border-width: 0; }
.border-2 { border-width: 2px; }
.border-4 { border-width: 4px; }
.border-t { border-top-width: 1px; }
.border-r { border-right-width: 1px; }
.border-b { border-bottom-width: 1px; }
.border-l { border-left-width: 1px; }
.border-white { border-color: #ffffff; }
.border-gray-200 { border-color: #e5e7eb; }
.border-gray-300 { border-color: #d1d5db; }
.border-gray-400 { border-color: #9ca3af; }
.border-gray-500 { border-color: #6b7280; }
.border-gray-600 { border-color: #4b5563; }

/* Rounded corners */
.rounded-none { border-radius: 0; }
.rounded-sm { border-radius: 0.125rem; }
.rounded { border-radius: 0.25rem; }
.rounded-md { border-radius: 0.375rem; }
.rounded-lg { border-radius: 0.5rem; }
.rounded-xl { border-radius: 0.75rem; }
.rounded-2xl { border-radius: 1rem; }
.rounded-3xl { border-radius: 1.5rem; }
.rounded-full { border-radius: 9999px; }

/* Typography */
.text-xs { font-size: 0.75rem; }
.text-sm { font-size: 0.875rem; }
.text-base { font-size: 1rem; }
.text-lg { font-size: 1.125rem; }
.text-xl { font-size: 1.25rem; }
.text-2xl { font-size: 1.5rem; }
.text-3xl { font-size: 1.875rem; }
.font-thin { font-weight: 100; }
.font-light { font-weight: 300; }
.font-normal { font-weight: 400; }
.font-medium { font-weight: 500; }
.font-semibold { font-weight: 600; }
.font-bold { font-weight: 700; }
.font-extrabold { font-weight: 800; }
.font-black { font-weight: 900; }
.text-left { text-align: left; }
.text-center { text-align: center; }
.text-right { text-align: right; }
.text-justify { text-align: justify; }

/* Display & Position */
.block { display: block; }
.inline-block { display: inline-block; }
.inline { display: inline; }
.hidden { display: none; }
.relative { position: relative; }
.absolute { position: absolute; }
.fixed { position: fixed; }
.sticky { position: sticky; }
.static { position: static; }
.inset-0 { top: 0; right: 0; bottom: 0; left: 0; }
.top-0 { top: 0; }
.right-0 { right: 0; }
.bottom-0 { bottom: 0; }
.left-0 { left: 0; }

/* Width & Height */
.w-full { width: 100%; }
.w-auto { width: auto; }
.w-1\/2 { width: 50%; }
.w-1\/3 { width: 33.333333%; }
.w-2\/3 { width: 66.666667%; }
.w-1\/4 { width: 25%; }
.w-3\/4 { width: 75%; }
.h-full { height: 100%; }
.h-auto { height: auto; }
.h-screen { height: 100vh; }
.min-h-screen { min-height: 100vh; }
.max-w-xs { max-width: 20rem; }
.max-w-sm { max-width: 24rem; }
.max-w-md { max-width: 28rem; }
.max-w-lg { max-width: 32rem; }
.max-w-xl { max-width: 36rem; }
.max-w-2xl { max-width: 42rem; }
.max-w-3xl { max-width: 48rem; }
.max-w-full { max-width: 100%; }

/* Overflow */
.overflow-auto { overflow: auto; }
.overflow-hidden { overflow: hidden; }
.overflow-visible { overflow: visible; }
.overflow-scroll { overflow: scroll; }
.overflow-x-auto { overflow-x: auto; }
.overflow-y-auto { overflow-y: auto; }
.overflow-x-hidden { overflow-x: hidden; }
.overflow-y-hidden { overflow-y: hidden; }
.overflow-x-visible { overflow-x: visible; }
.overflow-y-visible { overflow-y: visible; }
.overflow-x-scroll { overflow-x: scroll; }
.overflow-y-scroll { overflow-y: scroll; }

/* Z-Index */
.z-0 { z-index: 0; }
.z-10 { z-index: 10; }
.z-20 { z-index: 20; }
.z-30 { z-index: 30; }
.z-40 { z-index: 40; }
.z-50 { z-index: 50; }
.z-auto { z-index: auto; }

/* Shadows */
.shadow-sm { box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); }
.shadow { box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06); }
.shadow-md { box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
.shadow-lg { box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); }
</file>

<file path="web/css/base.css">
/* Define CSS Variables for Theme */
:root {
  --color-primary: #3b82f6; /* blue-500 */
  --color-secondary: #6366f1; /* indigo-500 */
  --color-success: #22c55e; /* green-500 */
  --color-warning: #f59e0b; /* amber-500 */
  --color-danger: #ef4444; /* red-500 */

  --color-gray-50: #f9fafb;
  --color-gray-100: #f3f4f6;
  --color-gray-200: #e5e7eb;
  --color-gray-300: #d1d5db;
  --color-gray-400: #9ca3af;
  --color-gray-500: #6b7280;
  --color-gray-600: #4b5563;
  --color-gray-700: #374151;
  --color-gray-800: #1f2937;
  --color-gray-900: #111827;

  --color-amber-50: #fffbeb;
  --color-amber-100: #fef3c7;
  --color-amber-400: #fbbf24; /* Adjusted for warning */
  --color-amber-600: #d97706;
  --color-amber-800: #92400e;
  --color-amber-900: #78350f;

  --color-red-50: #fef2f2;
  --color-red-100: #fee2e2;
  --color-red-200: #fecaca;
  --color-red-800: #991b1b;
  --color-red-900: #7f1d1d;

  --color-purple-100: #f3e8ff;
  --color-purple-400: #c084fc;
  --color-purple-500: #a855f7;
  --color-purple-700: #7e22ce;
  --color-purple-900: #581c87;

  /* Add spacing, radius, shadow variables if desired */
  /* --space-4: 1rem; */
  /* --radius-lg: 0.5rem; */
  /* --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1); */
}

/* Import Tailwind base, components, and utilities */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Define custom components using @apply */
@layer components {
  /* Example: Reusable card style */
  .card {
    @apply overflow-hidden; /* Removed dark:bg-gray-800 */
  }

  /* Example: Button styles */
  .btn {
    @apply rounded-lg transition-colors font-medium focus:outline-none focus:ring-2 focus:ring-offset-2 dark:focus:ring-offset-gray-800; /* Removed px-4 py-2 */
  }
  .btn-primary {
    @apply btn bg-primary hover:bg-primary/90 text-white focus:ring-primary;
  }
  .btn-secondary {
    @apply btn bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-white focus:ring-gray-400;
  }
  .btn-icon {
     @apply p-1.5 rounded-full hover:bg-primary/10 text-primary focus:ring-primary;
  }
  .btn-icon-sm {
     @apply p-1 rounded hover:bg-white/10 text-white focus:ring-white;
  }

  /* Example: Chat bubble styles */
  .chat-bubble {
     @apply px-3 py-2 rounded-lg shadow-sm relative transition-all hover:-translate-y-0.5 max-w-[85%] animate-fadeIn; /* Removed hover:shadow-md */
  }
  .chat-bubble-user {
    @apply chat-bubble bg-primary text-white rounded-br-none;
  }
  .chat-bubble-ai {
    @apply chat-bubble bg-gray-100 dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-bl-none w-full;
  }
   .chat-bubble-tool {
    @apply chat-bubble bg-gray-800 text-gray-100 font-mono text-sm whitespace-pre-wrap py-2 w-full;
  }
   .chat-bubble-system {
    @apply chat-bubble bg-amber-50 text-amber-800 border border-amber-100 text-sm max-w-[90%];
  }
   .chat-bubble-error {
    @apply chat-bubble bg-red-50 text-red-800 border border-red-200 w-full;
  }

  /* Example: Modal styles */
  .modal {
    @apply fixed inset-0 z-50 bg-black/60 backdrop-blur-sm overflow-y-auto p-5 animate-modalFadeIn;
  }
  .modal-content {
    @apply rounded-xl shadow-xl p-6 mx-auto my-8 animate-modalSlideIn max-h-[calc(100vh-4rem)] overflow-y-auto bg-white dark:bg-gray-800; /* Add dark:bg-gray-800 here */
  }
  .modal-close {
    @apply text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 text-2xl cursor-pointer transition-transform hover:rotate-90;
  }

  /* Example: Sidebar panel section */
  .panel-section {
     @apply card rounded-xl shadow-md bg-white dark:bg-gray-800; /* Add dark:bg-gray-800 here */
  }
  .panel-header {
     @apply px-5 py-3 bg-gray-50 dark:bg-gray-700 font-medium flex items-center justify-between cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors;
  }
  .panel-content {
     @apply max-h-0 overflow-hidden transition-all duration-300 ease-out opacity-0 transform -translate-y-2;
  }
  .panel-section.active .panel-content {
     @apply max-h-[500px] /* Adjust as needed */ overflow-y-auto opacity-100 transform translate-y-0;
  }

  /* Example: Toast notification */
  .toast {
    @apply fixed bottom-5 right-5 z-[150] flex items-center gap-3 p-4 rounded-lg shadow-xl border-l-4 transition-all duration-300 ease-out transform translate-x-full opacity-0;
    min-width: 250px;
    max-width: 400px;
  }
  .toast.show {
    @apply translate-x-0 opacity-100;
  }
  .toast.success { @apply bg-green-50 dark:bg-green-900/50 border-success text-green-800 dark:text-green-200; }
  .toast.error { @apply bg-red-50 dark:bg-red-900/50 border-danger text-red-800 dark:text-red-200; }
  .toast.warning { @apply bg-amber-50 dark:bg-amber-900/50 border-warning text-amber-800 dark:text-amber-200; }
  .toast.info { @apply bg-blue-50 dark:bg-blue-900/50 border-primary text-blue-800 dark:text-blue-200; }
  .toast-icon { @apply text-xl; }
  .toast-content { @apply flex-grow; }
  .toast-title { @apply font-bold; }
  .toast-message { @apply text-sm; }
  .toast-close { @apply text-inherit opacity-70 hover:opacity-100; }

  /* Spinner */
  .spinner {
    @apply absolute top-2 right-2 w-5 h-5 border-3 border-black/10 dark:border-white/10 border-l-primary rounded-full animate-spin;
  }
}
</file>

<file path="web/css/chat.css">
/* Enhanced chat styles with better animations */

/* Message animations */
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(12px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Message styling */
.message {
  animation: fadeIn 0.3s ease-out;
  transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
  position: relative;
  padding: 1rem 1.25rem;
  margin-bottom: 1.5rem;
  max-width: 85%;
  border-radius: 1rem;
}

.message:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 15px rgba(0, 0, 0, 0.05);
}

/* User message styles */
.user-message {
  margin-left: auto;
  background-color: var(--primary-color);
  color: white;
  border-bottom-right-radius: 0.25rem;
}

.user-message:after {
  content: '';
  position: absolute;
  bottom: 0;
  right: -0.75rem;
  width: 1.5rem;
  height: 1.5rem;
  background: var(--primary-color);
  border-bottom-left-radius: 1.25rem;
  z-index: -1;
}

/* AI message styles */
.ai-message {
  margin-right: auto;
  background-color: #f1f5f9;
  color: #334155;
  border-bottom-left-radius: 0.25rem;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
}

.ai-message:after {
  content: '';
  position: absolute;
  bottom: 0;
  left: -0.75rem;
  width: 1.5rem;
  height: 1.5rem;
  background: #f1f5f9;
  border-bottom-right-radius: 1.25rem;
  z-index: -1;
}

/* System message styling */
.system-message {
  max-width: 90%;
  margin: 1rem auto;
  background-color: #fffbeb;
  border: 1px solid #fef3c7;
  color: #a16207;
  padding: 0.75rem 1rem;
  font-size: 0.875rem;
  border-radius: 0.5rem;
}

/* Make text in conversation area more readable */
#conversation {
  line-height: 1.6;
  font-size: 1rem;
}
</file>

<file path="web/css/components.css">
/* Minimal component styles - most replaced by Tailwind */

/* Spinner that may be referenced in JS */
.spinner {
  position: absolute;
  top: 0.5rem;
  right: 0.5rem;
  width: 20px;
  height: 20px;
  border: 3px solid rgba(0, 0, 0, 0.1);
  border-left-color: var(--primary-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.spinner.hidden {
  display: none;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* Hide elements with hidden class */
.hidden {
  display: none !important;
}
</file>

<file path="web/css/layout.css">
/* Simplified layout.css - most styles replaced by Tailwind */

/* Core layout styles that might be referenced in JS */
.panel-collapsed .right-panel {
  display: none;
}

/* Remove explicit height restriction for better responsive layout */
</file>

<file path="web/css/modals.css">
/* Enhanced modal styles with improved animations and accessibility */

/* Modal animations */
@keyframes modalFadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes modalSlideIn {
  from { transform: translateY(-50px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

/* Basic modal structure */
.modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.6);
  z-index: 100;
  backdrop-filter: blur(5px);
  animation: modalFadeIn 0.25s ease-out;
  overflow-y: auto;
  padding: 20px 0;
}

.modal-content {
  animation: modalSlideIn 0.35s ease-out;
  margin: 2% auto;
  max-height: calc(100vh - 60px);
  border-radius: 1rem;
  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
  overflow: hidden;
}

/* Modal close button styling */
.modal .close {
  transition: transform 0.2s, color 0.2s;
}

.modal .close:hover {
  transform: rotate(90deg);
}

/* Ensure modals have proper scrolling behavior */
.modal-content {
  overflow-y: auto;
  scrollbar-width: thin;
  scrollbar-color: rgba(156, 163, 175, 0.5) transparent;
}

.modal-content::-webkit-scrollbar {
  width: 6px;
}

.modal-content::-webkit-scrollbar-track {
  background: transparent;
}

.modal-content::-webkit-scrollbar-thumb {
  background-color: rgba(156, 163, 175, 0.5);
  border-radius: 3px;
}

/* Responsive adjustments managed in responsive.css */
</file>

<file path="web/css/README.md">
# CSS Architecture

This project has been simplified to use Tailwind CSS as the primary styling approach, with minimal custom CSS.

## CSS File Organization

- **base.css**: Minimal reset styles and CSS variables
- **components.css**: Essential custom component styles not covered by Tailwind
- **layout.css**: Core layout styles
- **chat.css**: Chat message specific styles
- **sidebar.css**: Panel behavior styles
- **modals.css**: Modal animation and structure
- **responsive.css**: Media queries for responsive behavior

## Build Process

The project uses Tailwind CSS for styling, with two possible build approaches:

1. **Preferred**: Using Tailwind CLI via NPX
   ```bash
   npm run build:css
   ```

2. **Fallback**: Using the built-in JavaScript fallback (if Tailwind CLI fails)
   - Automatically runs when Tailwind CLI command fails
   - Uses pre-defined utility classes from `web/build/tailwind-fallback.css`
   - Combined with `base.css` content

3. **Runtime Fallback**: If all else fails, the web page will load Tailwind from CDN

## Styling Approach

1. **Primary**: Use Tailwind utility classes in HTML
2. **Secondary**: Use minimal custom CSS for complex behaviors
3. **Variables**: Core CSS variables are maintained for JavaScript references

## Benefits of This Approach

- Reduced CSS complexity and file size
- Better maintainability with utility-first approach
- Easier responsive design with Tailwind's responsive utilities
- Simplified debugging with less CSS specificity conflicts
- Robust fallback system for environments without Tailwind CLI access
</file>

<file path="web/css/responsive.css">
/* Enhanced responsive styles */

/* Only include essential responsive behaviors that might be referenced in JS */
@media (max-width: 1024px) {
  main:not(.panel-collapsed) {
    flex-direction: column;
  }
  
  main:not(.panel-collapsed) .right-panel {
    display: block;
    width: 100%;
    margin-top: 1.5rem;
  }
  
  .right-panel {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
  }
}

@media (max-width: 768px) {
  /* Container structure adjustments */
  main {
    padding: 0.75rem;
  }
  
  .message {
    max-width: 95%;
  }
  
  /* Make modals more mobile-friendly */
  .modal-content {
    width: 95%;
    margin: 3% auto;
    padding: 1rem;
  }
  
  /* Improve spacing and readability on small screens */
  .conversation {
    padding: 1rem;
  }
  
  .input-area {
    padding: 1rem;
  }
  
  /* Ensure buttons are large enough for touch targets */
  button {
    min-height: 2.75rem;
  }
}
</file>

<file path="web/css/sidebar.css">
/* Simplified sidebar.css - most styles replaced by Tailwind */

/* Panel animation and interaction styles */
.panel-content {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease-out, opacity 0.3s ease-out, transform 0.3s ease-out;
  opacity: 0;
  transform: translateY(-10px);
}

.panel-section.active .panel-content {
  max-height: 500px; /* Set a reasonable max-height instead of max-content for smoother animation */
  overflow-y: auto;
  opacity: 1;
  transform: translateY(0);
}

/* Removed FontAwesome chevron animation - now handled by Tailwind classes */

/* Pulsing animation for config items */
@keyframes pulse {
  0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4); }
  70% { box-shadow: 0 0 0 5px rgba(59, 130, 246, 0); }
  100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0); }
}

.config-option.highlight {
  animation: pulse 1s infinite;
}
</file>

<file path="web/js/api/apiClient.js">
// Handles fetch requests to the backend API

import { showToast } from '../ui/toast.js'; // Import toast for error handling

const API_BASE = '/api'; // Define base path for API routes

/**
 * Helper function for making fetch requests and handling common errors.
 * @param {string} endpoint The API endpoint (e.g., '/conversations').
 * @param {RequestInit} options Fetch options (method, headers, body, etc.).
 * @returns {Promise<any>} The JSON response data.
 * @throws {Error} If the request fails or returns an error status.
 */
async function fetchApi(endpoint, options = {}) {
    try {
        const response = await fetch(`${API_BASE}${endpoint}`, options);

        if (!response.ok) {
            let errorData;
            try {
                // Try to parse error response from backend
                errorData = await response.json();
            } catch (e) {
                // If parsing fails, use status text
                errorData = { error: response.statusText || `HTTP error ${response.status}` };
            }
            // Throw an error with the message from the backend or status text
            throw new Error(errorData.error || `Request failed with status ${response.status}`);
        }

        // If response is OK, try to parse JSON body
        // Handle cases with no content (e.g., DELETE requests)
        const contentType = response.headers.get("content-type");
        if (contentType && contentType.indexOf("application/json") !== -1) {
            return await response.json();
        } else {
            // Return null or an empty object if no JSON body
            return null;
        }
    } catch (error) {
        console.error(`API call to ${endpoint} failed:`, error);
        // Re-throw the error so the caller can handle it (e.g., show a toast)
        throw error;
    }
}

// --- Conversation API Calls ---

export async function fetchConversationsList() {
    try {
        const data = await fetchApi('/conversations');
        return data.conversations || [];
    } catch (error) {
        showToast('error', 'API Error', `Failed to load conversations: ${error.message}`);
        return []; // Return empty array on error
    }
}

export async function renameConversation(conversationId, newTitle) {
    try {
        await fetchApi(`/conversations/${conversationId}/rename`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ title: newTitle })
        });
        showToast('success', 'Success', 'Conversation renamed');
        return true;
    } catch (error) {
        showToast('error', 'API Error', `Failed to rename conversation: ${error.message}`);
        return false;
    }
}

export async function deleteConversation(conversationId) {
     try {
        await fetchApi(`/conversations/${conversationId}`, { method: 'DELETE' });
        showToast('success', 'Success', 'Conversation deleted');
        return true;
    } catch (error) {
        showToast('error', 'API Error', `Failed to delete conversation: ${error.message}`);
        return false;
    }
}

// --- AI/Model API Calls ---

export async function fetchProviders() {
     try {
        // Corrected endpoint path
        return await fetchApi('/ai/providers');
    } catch (error) {
        showToast('error', 'API Error', `Failed to load AI providers: ${error.message}`);
        // Return a default structure or rethrow based on how critical this is
        return { current: '', providers: {}, models: {} };
    }
}

export async function switchProviderAndModel(provider, model) {
    try {
        const data = await fetchApi('/ai/model', { // Use the combined endpoint
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ provider, model })
        });
        // Success toast/UI update is handled by the socket event listener
        return data; // Return { provider, model }
    } catch (error) {
        showToast('error', 'API Error', `Failed to switch provider/model: ${error.message}`);
        throw error; // Rethrow for caller if needed
    }
}

export async function updateApiKey(provider, apiKey) {
     try {
        const data = await fetchApi('/ai/keys', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ provider, apiKey })
        });
        // Success message might depend on whether the client was reloaded
        showToast('success', 'Success', data.message || `API key updated for ${provider}.`);
        return data; // Return response which might include warning/model info
    } catch (error) {
        showToast('error', 'API Error', `Failed to update API key: ${error.message}`);
        throw error;
    }
}

// --- Server Config API Calls ---

export async function fetchServerConfig() {
    try {
        // This fetches the servers.json content for editing
        return await fetchApi('/servers/config');
    } catch (error) {
        showToast('error', 'API Error', `Failed to load server configuration: ${error.message}`);
        return { mcpServers: {} }; // Return default structure on error
    }
}

export async function saveServerConfigurations(config) {
    try {
        const data = await fetchApi('/servers/config', { // Use the config endpoint
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ config }) // Send the full config object
        });
        showToast('success', 'Success', data.message || 'Server configuration saved.');
        // Remind user about restart if needed
        if (data.message && data.message.includes('Restart')) {
             showToast('warning', 'Restart Required', 'Restart the application to apply server changes.');
        }
        return true;
    } catch (error) {
        showToast('error', 'API Error', `Failed to save server configuration: ${error.message}`);
        return false;
    }
}

// --- General Config File API Calls ---

export async function fetchConfigFile(fileName) {
    try {
        return await fetchApi(`/config/${fileName}`);
    } catch (error) {
        showToast('error', 'API Error', `Failed to load ${fileName}: ${error.message}`);
        throw error; // Rethrow for modal handling
    }
}

export async function saveConfigFile(fileName, content) {
    try {
        const data = await fetchApi(`/config/${fileName}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ content })
        });
        showToast('success', 'Success', data.message || `${fileName} saved successfully.`);
         if (data.needsRestart) {
             showToast('warning', 'Restart Required', 'Restart the application for changes to take effect.');
         }
        return data; // Return { success, message, needsRestart }
    } catch (error) {
        showToast('error', 'API Error', `Failed to save ${fileName}: ${error.message}`);
        throw error; // Rethrow for modal handling
    }
}
</file>

<file path="web/js/socket/socketClient.js">
// Handles Socket.IO connection and events

// Import UI update functions or state setters needed by handlers
import { showToast } from '../ui/toast.js';

let socket = null;
let handlers = {}; // Store handlers passed during init

export function init(eventHandlers) {
    if (socket) {
        console.warn("Socket already initialized.");
        return;
    }

    handlers = eventHandlers || {}; // Store the handlers

    console.log("Initializing Socket.IO connection...");
    socket = io(); // Assumes socket.io client is loaded globally

    // --- Connection Events ---
    socket.on('connect', () => {
        console.log('Socket connected:', socket.id);
        if (handlers.onConnect) handlers.onConnect();
        // Request initial data upon connection/reconnection
        // (Server should ideally send this automatically on connect)
    });

    socket.on('disconnect', (reason) => {
        console.log('Socket disconnected:', reason);
        if (handlers.onDisconnect) handlers.onDisconnect(reason);
        showToast('warning', 'Disconnected', `Lost connection to server: ${reason}`);
    });

    socket.on('connect_error', (error) => {
        console.error('Socket connection error:', error);
        if (handlers.onError) handlers.onError(`Connection error: ${error.message}`);
        showToast('error', 'Connection Error', `Could not connect to server: ${error.message}`);
    });

    // --- Application Specific Event Handlers ---
    // These handlers call the functions passed in via `eventHandlers` during init

    socket.on('servers-info', (data) => {
        // console.log('Received servers-info:', data);
        if (handlers.onServersInfo) handlers.onServersInfo(data.servers);
    });

    socket.on('history', (data) => {
        // console.log('Received history:', data);
        if (handlers.onHistory) handlers.onHistory(data.history);
    });

    socket.on('history-update', (data) => {
        // console.log('Received history-update:', data);
        if (handlers.onHistoryUpdate) handlers.onHistoryUpdate(data.history);
    });

    // 'ai-response' event is removed from backend, no listener needed.

    socket.on('thinking', (data) => {
        // console.log('Received thinking:', data);
        if (handlers.onThinking) handlers.onThinking(data.status, data.message);
    });

    socket.on('tools-info', (data) => {
        // console.log('Received tools-info:', data);
        // Pass the data object directly, as the server emits the toolsByServer object itself
        if (handlers.onToolsInfo) handlers.onToolsInfo(data);
    });

    // Removed 'status-update' listener as it's not emitted by the server

    socket.on('error', (data) => {
        console.error('Received error event:', data.message);
        if (handlers.onError) handlers.onError(data.message);
        // Show important errors as toasts
        showToast('error', 'Server Error', data.message);
    });

    socket.on('conversation-cleared', () => {
        // console.log('Received conversation-cleared');
        if (handlers.onConversationCleared) handlers.onConversationCleared();
        // Toast handled by the action initiator in chatUI.js
    });

    socket.on('model-changed', (data) => {
        // console.log('Received model-changed:', data);
        if (handlers.onModelChanged) handlers.onModelChanged(data);
        // Toast/UI updates handled by the callback passed in init
    });

    socket.on('conversations-list', (data) => {
        // console.log('Received conversations-list:', data);
        if (handlers.onConversationsList) handlers.onConversationsList(data.conversations);
    });

    socket.on('conversation-loaded', (data) => {
        // console.log('Received conversation-loaded:', data);
        if (handlers.onConversationLoaded) handlers.onConversationLoaded(data);
    });

    socket.on('conversation-saved', (data) => {
        // console.log('Received conversation-saved:', data);
        if (handlers.onConversationSaved) handlers.onConversationSaved(data);
        // Toast handled by the callback
    });
}

// --- Emit Functions ---

export function emitUserMessage(message) {
    if (!socket) {
        console.error("Socket not initialized. Cannot send message.");
        showToast('error', 'Error', 'Not connected to server.');
        return;
    }
    socket.emit('user-message', { message });
}

export function emitClearConversation() {
     if (!socket) return;
     socket.emit('clear-conversation');
}

export function emitNewConversation() {
     if (!socket) return;
     socket.emit('new-conversation');
}

export function emitLoadConversation(conversationId) {
     if (!socket) return;
     socket.emit('load-conversation', { id: conversationId });
}

// Add other emit functions as needed
</file>

<file path="web/js/state/appState.js">
// Holds shared application state

let state = {
    isThinking: false,
    currentProvider: '',
    providers: {}, // { providerName: { config } }
    providerModels: {}, // { providerName: { models: [] } }
    serverConfig: { mcpServers: {} }, // For server modal editing
    selectedServerName: null, // For server modal editing
    conversations: [], // [{ id, title, ... }]
    currentConversationId: null,
    allToolsData: {}, // { serverName: [tools] }
    statusMessage: 'Initializing...',
    currentConfigFile: null, // For config editor modal
};

export function initState() {
    // Perform any initial setup if needed
    console.log("App state initialized");
}

// --- Getters ---
export function isThinking() { return state.isThinking; }
export function getCurrentProvider() { return state.currentProvider; }
export function getProviders() { return state.providers; }
export function getProviderModels() { return state.providerModels; }
export function getServerConfig() { return state.serverConfig; }
export function getSelectedServerName() { return state.selectedServerName; }
export function getConversations() { return state.conversations; }
export function getCurrentConversationId() { return state.currentConversationId; }
export function getAllToolsData() { return state.allToolsData; }
export function getStatusMessage() { return state.statusMessage; }
export function getCurrentConfigFile() { return state.currentConfigFile; }

// --- Setters ---
export function setThinking(thinking) {
    state.isThinking = thinking;
    // Optionally trigger UI updates here or let callers handle it
}
export function setCurrentProvider(provider) { state.currentProvider = provider; }
export function setProviders(providersData) { state.providers = providersData || {}; }
export function setProviderModels(modelsData) { state.providerModels = modelsData || {}; }
export function setServerConfig(config) { state.serverConfig = config || { mcpServers: {} }; }
export function setSelectedServerName(name) { state.selectedServerName = name; }
export function setConversations(convos) { state.conversations = convos || []; }
export function setCurrentConversationId(id) { state.currentConversationId = id; }
export function setAllToolsData(tools) { state.allToolsData = tools || {}; }
export function setStatus(message) {
    state.statusMessage = message;
    // Update the status UI element directly (example)
    const statusElement = document.getElementById('status');
    if (statusElement) {
        statusElement.textContent = message;
    }
}
export function setCurrentConfigFile(fileName) { state.currentConfigFile = fileName; }

// --- Updaters ---
export function updateConversationInList(updatedConversation) {
    const index = state.conversations.findIndex(c => c.id === updatedConversation.id);
    if (index >= 0) {
        state.conversations[index] = updatedConversation;
    } else {
        state.conversations.push(updatedConversation);
    }
    // Sort again after update/add
    state.conversations.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
}

export function removeConversationFromList(conversationId) {
     state.conversations = state.conversations.filter(c => c.id !== conversationId);
}
</file>

<file path="web/js/ui/chatUI.js">
// Handles rendering and interactions for the chat/conversation area

import { escapeHtml, formatToolCalls } from '../utils/helpers.js';
import { emitUserMessage } from '../socket/socketClient.js';
import * as appState from '../state/appState.js'; // To check thinking state

// DOM Elements
let conversationElement;
let userInputElement;
let sendButton;
let clearButton;
let thinkingSpinner; // Use the spinner element

// Function to adjust textarea height based on content
function adjustTextareaHeight() {
    if (!userInputElement) return;
    
    // Reset height to auto to get accurate scrollHeight
    userInputElement.style.height = 'auto';
    
    // Set new height based on content (with min/max values)
    const newHeight = Math.max(Math.min(userInputElement.scrollHeight, 300), 40);
    userInputElement.style.height = `${newHeight}px`;
}

export function init() {
    conversationElement = document.getElementById('conversation');
    userInputElement = document.getElementById('user-input');
    sendButton = document.getElementById('send-button');
    clearButton = document.getElementById('clear-button');
    thinkingSpinner = document.getElementById('thinking-spinner'); // Get spinner

    if (!conversationElement || !userInputElement || !sendButton || !clearButton || !thinkingSpinner) {
        console.error("Chat UI elements not found!");
        return;
    }

    // Event Listeners
    sendButton.addEventListener('click', sendMessage);
    clearButton.addEventListener('click', handleClearConversation); // Use specific handler
    userInputElement.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });
    
    // Auto-expand textarea as user types
    userInputElement.addEventListener('input', adjustTextareaHeight);
    
    // Initial adjustment
    adjustTextareaHeight();

    console.log("Chat UI initialized.");
}

function sendMessage() {
    const message = userInputElement.value.trim();
    // Check state before sending
    if (message && !appState.isThinking()) {
        // Add user message optimistically
        addMessageToConversation('human', message); // Use 'human' role
        scrollToBottom(); // Scroll after adding user message

        // Send the message via socket
        emitUserMessage(message);

        // Clear the input field
        userInputElement.value = '';
        // Reset textarea height
        adjustTextareaHeight();

        // Update thinking indicator immediately (handled by socket 'thinking' event)
        // updateThinkingIndicator(true, 'Sending message...');
    } else if (appState.isThinking()) {
        console.log("Cannot send message while AI is thinking.");
        // Optionally show a toast or visual feedback
    }
}

function handleClearConversation() {
    // Confirmation could be added here if desired
    // if (confirm('Are you sure you want to clear the conversation?')) {
        // Emit clear event via socket
        emitClearConversation();
        // Toast notification is handled in sidebarUI where the button lives now?
        // Or handle it here based on socket 'conversation-cleared' event?
        // For now, assume socket handler triggers necessary UI updates/toasts.
    // }
}

export function renderConversationHistory(history) {
    if (!conversationElement) return;

    // Clear the conversation display
    conversationElement.innerHTML = '';

    // Render each message from the received history
    if (history && Array.isArray(history)) {
        history.forEach((message) => {
            // Skip system messages if they somehow get included
            if (message.role === 'system') return;

            addMessageToConversation(
                message.role,
                message.content,
                message.hasToolCalls,
                message.pendingToolCalls
            );
        });
    } else {
        console.warn("Received invalid history data:", history);
    }

    // Scroll to the bottom after rendering
    scrollToBottom();
}

function addMessageToConversation(role, content, hasToolCalls = false, isPending = false) {
    if (!conversationElement) return;

    // Create a wrapper div for alignment
    const wrapperElement = document.createElement('div');
    wrapperElement.className = role === 'human' ? 'flex justify-end mb-4' : 'flex justify-start mb-4'; // Increased margin

    const messageElement = document.createElement('div');
    // Apply base chat bubble styles and role-specific styles using @apply classes
    let bubbleClass = 'chat-bubble'; // Base class defined in base.css @layer components
    switch (role) {
        case 'human': bubbleClass += ' chat-bubble-user'; break;
        case 'ai': bubbleClass += ' chat-bubble-ai'; break;
        case 'tool': bubbleClass += ' chat-bubble-tool'; break;
        case 'system': bubbleClass += ' chat-bubble-system'; wrapperElement.className = 'flex justify-center mb-4'; break; // Center system messages
        case 'error': bubbleClass += ' chat-bubble-error'; break;
        default: bubbleClass += ' chat-bubble-ai'; // Default to AI style
    }
    // Add base bubble class and hover effect class directly
    messageElement.className = `${bubbleClass} hover:shadow-md`;

    if (isPending) {
        messageElement.classList.add('opacity-70'); // Use Tailwind opacity for pending
    }

    const now = new Date();
    const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

    let roleLabel = role.charAt(0).toUpperCase() + role.slice(1);
    if (role === 'human') roleLabel = 'User';
    if (role === 'tool') roleLabel = 'Tool Result';
    if (role === 'error') roleLabel = 'Error'; // Use specific label for errors

    // Format content: escape HTML and format tool calls if necessary
    let contentHtml = '';
    // Check if it's an AI message AND has tool calls flag OR if it's a tool message itself
    if (role === 'ai' && hasToolCalls) {
        // If it's an AI message that *contains* tool calls (MCP style), format them
        contentHtml = formatToolCalls(content); // Use helper to format embedded calls
    } else if (role === 'tool') {
         // If it's a ToolMessage result, display as preformatted text
         contentHtml = `<pre class="tool-result-content text-xs font-mono whitespace-pre-wrap overflow-x-auto bg-gray-800/80 dark:bg-black/50 p-2 rounded">${escapeHtml(content)}</pre>`;
    }
     else {
        // For regular human/ai/system/error messages without tool calls
        contentHtml = escapeHtml(content); // Use helper
    }

    messageElement.innerHTML = `
        <div class="flex justify-between items-center mb-1 text-xs font-medium opacity-80">
            <span>${escapeHtml(roleLabel)}</span>
            <span class="message-time">${timeString}</span>
        </div>
        <div class="message-content whitespace-pre-wrap break-words text-sm leading-relaxed">${contentHtml}</div>
    `;

    // Add message to wrapper, then add wrapper to conversation
    wrapperElement.appendChild(messageElement);
    conversationElement.appendChild(wrapperElement);
    // Don't scroll here, let renderConversationHistory handle it once at the end
}

// Function to display errors in the chat area
export function displayError(message) {
     addMessageToConversation('error', message);
     scrollToBottom(); // Scroll after adding error
}


// Function to clear the display (called on 'conversation-cleared' event)
export function clearConversationDisplay() {
    if (conversationElement) {
        conversationElement.innerHTML = '';
        // Optionally add a system message like "Conversation cleared."
        // addSystemMessage("Conversation cleared.");
    }
}

// Function to update the thinking indicator UI
export function updateThinkingIndicator(thinking, statusMessage = 'AI is thinking...') {
    if (!thinkingSpinner || !sendButton || !userInputElement) return;

    appState.setThinking(thinking); // Update shared state

    if (thinking) {
        thinkingSpinner.classList.remove('hidden'); // Use Tailwind's hidden utility
        sendButton.disabled = true;
        userInputElement.disabled = true;
        appState.setStatus(statusMessage);
    } else {
        thinkingSpinner.classList.add('hidden'); // Use Tailwind's hidden utility
        sendButton.disabled = false;
        userInputElement.disabled = false;
        appState.setStatus('Ready');
    }
}

function scrollToBottom() {
    if (conversationElement) {
        conversationElement.scrollTop = conversationElement.scrollHeight;
        // Ensure the last message is fully visible
        const lastMessage = conversationElement.lastElementChild;
        if (lastMessage) {
            lastMessage.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }
    }
}

// Helper to add system messages (if needed for UI feedback, though generally hidden)
function addSystemMessage(message) {
    addMessageToConversation('system', message);
    scrollToBottom();
}
</file>

<file path="web/js/ui/headerUI.js">
// Handles updates to the header elements (server count, model name)

import { openModelModal } from './modalUI.js'; // To open modals
import { openServersModal } from './modalUI.js';

// DOM Elements
// DOM Elements
let connectedServersElement;
let aiModelElement;
let changeModelBtn;
let manageServersBtn;
// No need for toggle button reference here, handled in sidebarUI

export function init() {
    connectedServersElement = document.getElementById('connected-servers');
    aiModelElement = document.getElementById('ai-model');
    changeModelBtn = document.getElementById('change-model-btn');
    manageServersBtn = document.getElementById('manage-servers-btn');

    if (!connectedServersElement || !aiModelElement || !changeModelBtn || !manageServersBtn) {
        console.error("Header UI elements not found!");
        return;
    }

    // Event Listeners
    changeModelBtn.addEventListener('click', openModelModal);
    manageServersBtn.addEventListener('click', openServersModal);
    // Toggle button listener moved to sidebarUI

    console.log("Header UI initialized.");
}

// Update server connection info display
export function updateServerInfo(serversData) { // Expects array like [{ name, status }] or just names
    if (!connectedServersElement) return;

    let count = 0;
    let statusText = 'No servers connected';

    if (Array.isArray(serversData)) {
        // If just names are passed (backward compatibility or simple status)
        if (serversData.length > 0 && typeof serversData[0] === 'string') {
            count = serversData.length;
            statusText = `${count} server${count !== 1 ? 's' : ''} connected`;
        }
        // If status objects are passed (preferred)
        else if (serversData.length > 0 && typeof serversData[0] === 'object') {
            const connectedCount = serversData.filter(s => s.status === 'connected').length;
            const errorCount = serversData.filter(s => s.status === 'error').length;
            count = connectedCount; // Display connected count primarily

            statusText = `${connectedCount} server${connectedCount !== 1 ? 's' : ''} connected`;
            if (errorCount > 0) {
                statusText += ` (${errorCount} error${errorCount !== 1 ? 's' : ''})`;
            } else if (connectedCount === 0 && serversData.length > 0) {
                statusText = 'No servers connected';
            } else if (serversData.length === 0) {
                statusText = 'No servers configured';
            }
        }
    }

    connectedServersElement.textContent = statusText;
}

// Update AI model display in header
export function updateModelInfo(provider, model) {
    if (!aiModelElement) return;
    if (provider && model) {
        aiModelElement.textContent = `${model} (${provider})`;
        aiModelElement.title = `Provider: ${provider}, Model: ${model}`;
    } else if (model) {
         aiModelElement.textContent = model;
         aiModelElement.title = `Model: ${model}`;
    }
     else {
        aiModelElement.textContent = 'N/A';
        aiModelElement.title = 'No AI model selected or available';
    }
}
</file>

<file path="web/js/ui/modalUI.js">
// Handles logic for all modals (Model, Servers, Config Editor)

import * as appState from '../state/appState.js';
import { escapeHtml } from '../utils/helpers.js';
import { showToast } from './toast.js';
import * as apiClient from '../api/apiClient.js'; // Import API client
import { renderProvidersList } from './sidebarUI.js'; // To update sidebar on provider change

// --- DOM Elements ---
// Model Modal
let modelModal, modelCloseBtn, providerSelect, modelSelect, apiKeyInput, toggleApiKeyVisibilityBtn, cancelModelChangeBtn, applyModelChangeBtn;
// Servers Modal
let serversModal, serversCloseBtn, serverListItems, addServerBtn, serverForm, noServerSelected, serverNameInput, serverCommandInput, serverArgsList, serverEnvList, addArgBtn, addEnvBtn, cancelServersChangeBtn, applyServersChangeBtn;
// Config Modal
let configModal, configCloseBtn, configFileNameElement, configEditor, cancelConfigChangeBtn, applyConfigChangeBtn;

export function init() {
    // Model Modal Elements
    modelModal = document.getElementById('model-modal');
    modelCloseBtn = modelModal?.querySelector('.close');
    providerSelect = document.getElementById('provider-select');
    modelSelect = document.getElementById('model-select');
    apiKeyInput = document.getElementById('api-key-input');
    toggleApiKeyVisibilityBtn = document.getElementById('toggle-api-key-visibility');
    cancelModelChangeBtn = document.getElementById('cancel-model-change');
    applyModelChangeBtn = document.getElementById('apply-model-change');

    // Servers Modal Elements
    serversModal = document.getElementById('servers-modal');
    serversCloseBtn = serversModal?.querySelector('.close');
    serverListItems = document.getElementById('server-list-items');
    addServerBtn = document.getElementById('add-server-btn');
    serverForm = document.getElementById('server-form');
    noServerSelected = document.getElementById('no-server-selected');
    serverNameInput = document.getElementById('server-name');
    serverCommandInput = document.getElementById('server-command');
    serverArgsList = document.getElementById('server-args');
    serverEnvList = document.getElementById('server-env');
    addArgBtn = document.getElementById('add-arg-btn');
    addEnvBtn = document.getElementById('add-env-btn');
    cancelServersChangeBtn = document.getElementById('cancel-servers-change');
    applyServersChangeBtn = document.getElementById('apply-servers-change');

    // Config Modal Elements
    configModal = document.getElementById('config-modal');
    configCloseBtn = configModal?.querySelector('.close');
    configFileNameElement = document.getElementById('config-file-name');
    configEditor = document.getElementById('config-editor');
    cancelConfigChangeBtn = document.getElementById('cancel-config-change');
    applyConfigChangeBtn = document.getElementById('apply-config-change');

    // Add common modal listeners
    [modelModal, serversModal, configModal].forEach(modal => {
        if (modal) {
            // Close on clicking outside content
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeModal(modal);
                }
            });
            // Close button listener
            const closeBtn = modal.querySelector('.close');
            if (closeBtn) {
                closeBtn.addEventListener('click', () => closeModal(modal));
            }
        }
    });

    // --- Model Modal Specific Listeners ---
    if (cancelModelChangeBtn) cancelModelChangeBtn.addEventListener('click', () => closeModal(modelModal));
    if (applyModelChangeBtn) applyModelChangeBtn.addEventListener('click', applyModelChange);
    if (providerSelect) providerSelect.addEventListener('change', updateModelSelectOptions);
    if (toggleApiKeyVisibilityBtn) toggleApiKeyVisibilityBtn.addEventListener('click', toggleApiKeyVisibility);

    // --- Servers Modal Specific Listeners ---
    if (cancelServersChangeBtn) cancelServersChangeBtn.addEventListener('click', () => closeModal(serversModal));
    if (applyServersChangeBtn) applyServersChangeBtn.addEventListener('click', saveServerConfigurations);
    if (addServerBtn) addServerBtn.addEventListener('click', addNewServer);
    if (addArgBtn) addArgBtn.addEventListener('click', () => addArgItem(''));
    if (addEnvBtn) addEnvBtn.addEventListener('click', () => addEnvItem('', ''));

    // --- Config Modal Specific Listeners ---
    if (cancelConfigChangeBtn) cancelConfigChangeBtn.addEventListener('click', () => closeModal(configModal));
    if (applyConfigChangeBtn) applyConfigChangeBtn.addEventListener('click', saveConfigFile);

    console.log("Modal UI initialized.");
}

// --- Common Modal Functions ---
function openModal(modalElement) {
    if (modalElement) {
        modalElement.classList.remove('hidden'); // Use Tailwind hidden class
        // Add class to body to prevent scrolling behind modal?
        // document.body.classList.add('overflow-hidden');
    }
}

function closeModal(modalElement) {
    if (modalElement) {
        modalElement.classList.add('hidden'); // Use Tailwind hidden class
        // Remove body class
        // document.body.classList.remove('overflow-hidden');
    }
}

// --- Model Change Modal Functions ---
export function openModelModal() {
    appState.setStatus('Loading provider data...');
    apiClient.fetchProviders().then(data => {
        // Update state first
        appState.setProviders(data.providers);
        appState.setProviderModels(data.models);
        appState.setCurrentProvider(data.current); // Ensure state has latest current provider

        populateProviderSelect();
        if (apiKeyInput) apiKeyInput.value = ''; // Clear API key field
        openModal(modelModal);
        appState.setStatus('Ready');
    }).catch(err => {
        appState.setStatus('Error loading providers');
        // Toast is shown by apiClient
    });
}

export function closeModelModal() {
    if (apiKeyInput) apiKeyInput.value = ''; // Clear API key for security
    closeModal(modelModal);
}

function populateProviderSelect() {
    if (!providerSelect) return;
    providerSelect.innerHTML = '';
    const providers = appState.getProviders();
    const currentProvider = appState.getCurrentProvider();
    const sortedNames = Object.keys(providers).sort();

    for (const name of sortedNames) {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        if (name === currentProvider) {
            option.selected = true;
        }
        providerSelect.appendChild(option);
    }
    updateModelSelectOptions(); // Update models for the initially selected provider
}

function updateModelSelectOptions() {
    if (!providerSelect || !modelSelect) return;
    const selectedProviderName = providerSelect.value;
    const providerKey = selectedProviderName.toLowerCase();
    const providerModels = appState.getProviderModels();
    const providers = appState.getProviders();
    const currentModelForProvider = providers[selectedProviderName]?.model;

    modelSelect.innerHTML = '';
    const models = providerModels[providerKey]?.models || [];

    if (models.length === 0) {
        // If no suggestions, check if a model is set in the config
        if (currentModelForProvider) {
             const option = document.createElement('option');
             option.value = currentModelForProvider;
             option.textContent = `${currentModelForProvider} (from config)`;
             option.selected = true;
             modelSelect.appendChild(option);
        } else {
            const option = document.createElement('option');
            option.value = '';
            option.textContent = 'No models available/suggested';
            option.disabled = true;
            modelSelect.appendChild(option);
        }
        return;
    }

    // Add suggested models
    models.forEach(model => {
        const option = document.createElement('option');
        option.value = model;
        option.textContent = model;
        if (model === currentModelForProvider) {
            option.selected = true;
        }
        modelSelect.appendChild(option);
    });

     // If the configured model wasn't in the suggestions, add it as an option
     if (currentModelForProvider && !models.includes(currentModelForProvider)) {
         const configOption = document.createElement('option');
         configOption.value = currentModelForProvider;
         configOption.textContent = `${currentModelForProvider} (from config)`;
         // Prepend it and select it
         modelSelect.prepend(configOption);
         configOption.selected = true;
     }
}


function toggleApiKeyVisibility() {
    if (!apiKeyInput || !toggleApiKeyVisibilityBtn) return;
    const icon = toggleApiKeyVisibilityBtn.querySelector('i');
    if (apiKeyInput.type === 'password') {
        apiKeyInput.type = 'text';
        if (icon) icon.className = 'fas fa-eye-slash';
    } else {
        apiKeyInput.type = 'password';
        if (icon) icon.className = 'fas fa-eye';
    }
}

function applyModelChange() {
    if (!providerSelect || !modelSelect || !apiKeyInput) return;

    const provider = providerSelect.value;
    const model = modelSelect.value;
    const apiKey = apiKeyInput.value.trim();
    const currentProvider = appState.getCurrentProvider();
    const providers = appState.getProviders();
    const currentModel = providers[currentProvider]?.model;

    if (!provider) {
        showToast('warning', 'Warning', 'Please select a provider.');
        return;
    }
     if (!model) {
        showToast('warning', 'Warning', 'Please select a model.');
        return;
    }


    const providerChanged = provider !== currentProvider;
    const modelChanged = model !== currentModel;
    const apiKeyProvided = apiKey !== '';

    if (!providerChanged && !modelChanged && !apiKeyProvided) {
        showToast('info', 'Info', 'No changes to apply.');
        closeModelModal();
        return;
    }

    appState.setStatus('Applying changes...');

    const applyChanges = async () => {
        try {
            // 1. Update API Key if provided
            if (apiKeyProvided) {
                await apiClient.updateApiKey(provider, apiKey);
                // API key update might trigger client switch via socket event if it's the current provider
            }

            // 2. Switch provider/model if changed (and API key update didn't already trigger it)
            const currentProviderAfterKeyUpdate = appState.getCurrentProvider(); // Get potentially updated provider
            if (provider !== currentProviderAfterKeyUpdate || model !== appState.getProviders()[provider]?.model) {
                 await apiClient.switchProviderAndModel(provider, model);
                 // Success toast/UI updates handled by socket event
            }

            closeModelModal(); // Close modal on success
            // Don't reset status here, let socket events handle final state

        } catch (error) {
            // Error toasts are shown by apiClient
            appState.setStatus('Error applying changes');
        }
    };

    applyChanges();
}


// --- Server Configuration Modal Functions ---
export function openServersModal() {
    appState.setStatus('Loading server configurations...');
    apiClient.fetchServerConfig().then(config => {
        appState.setServerConfig(config); // Store the full config for editing
        // Fetch current server status separately if needed, or assume config is enough for now
        // For simplicity, we'll render based on config keys, status display needs separate fetch/socket update
        const serverNames = Object.keys(config.mcpServers || {});
        // Create dummy status data for rendering list
        const serversData = serverNames.map(name => ({ name, status: 'unknown' }));
        renderServerList(serversData); // Render list
        hideServerForm(); // Ensure form is hidden initially
        openModal(serversModal);
        appState.setStatus('Ready');
    }).catch(err => {
        appState.setStatus('Error loading server config');
        // Toast shown by apiClient
    });
}

export function closeServersModal() {
    appState.setSelectedServerName(null); // Clear selection on close
    closeModal(serversModal);
}

function renderServerList(serversData) { // Expects [{ name, status }]
    if (!serverListItems) return;
    serverListItems.innerHTML = '';
    const selectedName = appState.getSelectedServerName();

    if (!serversData || serversData.length === 0) {
        serverListItems.innerHTML = '<li class="server-list-item empty">No servers configured</li>';
        return;
    }

    // Sort by name
    serversData.sort((a, b) => a.name.localeCompare(b.name));

    serversData.forEach(serverInfo => {
        const serverName = serverInfo.name;
        // Status might be unknown if just loaded from config
        const status = serverInfo.status || 'unknown';
        const statusTitle = status.charAt(0).toUpperCase() + status.slice(1);

        const item = document.createElement('li');
        item.className = `server-list-item ${selectedName === serverName ? 'active' : ''}`;
        item.dataset.serverName = serverName;

        // Status indicator (use grey for unknown)
        const statusIndicator = document.createElement('span');
        statusIndicator.className = `server-status-indicator server-status-${status === 'unknown' ? 'disconnected' : status}`; // Map unknown to disconnected style
        statusIndicator.title = statusTitle;

        const nameSpan = document.createElement('span');
        nameSpan.textContent = serverName;

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'server-delete-btn';
        deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
        deleteBtn.title = 'Delete server configuration';

        const leftSide = document.createElement('div');
        leftSide.style.display = 'flex';
        leftSide.style.alignItems = 'center';
        leftSide.appendChild(statusIndicator);
        leftSide.appendChild(nameSpan);

        item.appendChild(leftSide);
        item.appendChild(deleteBtn);

        // Select server on click (excluding delete button)
        item.addEventListener('click', (e) => {
            if (!e.target.closest('.server-delete-btn')) {
                selectServer(serverName);
            }
        });

        // Delete button listener
        deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (confirm(`Delete server "${serverName}" configuration? Restart required after saving.`)) {
                deleteServer(serverName);
            }
        });

        serverListItems.appendChild(item);
    });
}


function selectServer(serverName) {
    appState.setSelectedServerName(serverName);

    // Update UI list selection
    document.querySelectorAll('.server-list-item').forEach(item => {
        item.classList.toggle('active', item.dataset.serverName === serverName);
    });

    // Populate and show form
    populateServerForm(serverName);
    showServerForm();
}

function populateServerForm(serverName) {
     if (!serverNameInput || !serverCommandInput || !serverArgsList || !serverEnvList) return;

     const config = appState.getServerConfig();
     const serverData = config?.mcpServers?.[serverName];

     if (serverData) {
        serverNameInput.value = serverName;
        serverCommandInput.value = serverData.command || '';

        // Populate args
        serverArgsList.innerHTML = ''; // Clear previous
        (serverData.args || []).forEach(arg => addArgItem(arg));

        // Populate env vars
        serverEnvList.innerHTML = ''; // Clear previous
        Object.entries(serverData.env || {}).forEach(([key, value]) => addEnvItem(key, value));
     } else {
         // Should not happen if selecting from list, but handle defensively
         console.warn(`Config data not found for selected server: ${serverName}`);
         hideServerForm();
     }
}

function showServerForm() {
    if (serverForm) serverForm.classList.remove('hidden'); // Use Tailwind hidden
    if (noServerSelected) noServerSelected.classList.add('hidden'); // Use Tailwind hidden
}

function hideServerForm() {
    if (serverForm) serverForm.classList.add('hidden'); // Use Tailwind hidden
    if (noServerSelected) noServerSelected.classList.remove('hidden'); // Use Tailwind hidden
    // Optionally clear form fields
    if (serverNameInput) serverNameInput.value = '';
    if (serverCommandInput) serverCommandInput.value = '';
    if (serverArgsList) serverArgsList.innerHTML = '';
    if (serverEnvList) serverEnvList.innerHTML = '';
}

function addNewServer() {
    let config = appState.getServerConfig();
    if (!config.mcpServers) config.mcpServers = {}; // Ensure object exists

    let newName = 'new-server';
    let i = 1;
    while (config.mcpServers[newName]) {
        newName = `new-server-${i++}`;
    }

    // Add basic config
    config.mcpServers[newName] = { command: '', args: [], env: {} };
    appState.setServerConfig(config); // Update state

    // Re-render list and select the new server
    const serverNames = Object.keys(config.mcpServers);
    const serversData = serverNames.map(name => ({ name, status: 'unknown' }));
    renderServerList(serversData);
    selectServer(newName);
}

function deleteServer(serverName) {
    let config = appState.getServerConfig();
    if (config?.mcpServers?.[serverName]) {
        delete config.mcpServers[serverName];
        appState.setServerConfig(config); // Update state

        // Re-render list
        const serverNames = Object.keys(config.mcpServers);
        const serversData = serverNames.map(name => ({ name, status: 'unknown' }));
        renderServerList(serversData);

        // If the deleted server was selected, hide form
        if (appState.getSelectedServerName() === serverName) {
            appState.setSelectedServerName(null);
            hideServerForm();
        }
    }
}

function addArgItem(value = '') {
    if (!serverArgsList) return;
    const item = document.createElement('div');
    // Use Tailwind classes for layout and styling
    item.className = 'flex items-center gap-2';
    item.innerHTML = `
        <input type="text" class="form-input flex-grow rounded-md text-sm" value="${escapeHtml(value)}" placeholder="Argument value">
        <button class="remove-btn btn-icon text-danger hover:bg-danger/10 p-1" title="Remove argument"><i class="fas fa-times"></i></button>
    `;
    item.querySelector('.remove-btn').addEventListener('click', () => item.remove());
    serverArgsList.appendChild(item);
}

function addEnvItem(key = '', value = '') {
     if (!serverEnvList) return;
    const item = document.createElement('div');
    // Use Tailwind classes for layout and styling
    item.className = 'flex items-center gap-2';
    item.innerHTML = `
        <input type="text" class="form-input w-1/3 rounded-md text-sm" value="${escapeHtml(key)}" placeholder="Key">
        <input type="text" class="form-input flex-grow rounded-md text-sm" value="${escapeHtml(value)}" placeholder="Value">
        <button class="remove-btn btn-icon text-danger hover:bg-danger/10 p-1" title="Remove variable"><i class="fas fa-times"></i></button>
    `;
    item.querySelector('.remove-btn').addEventListener('click', () => item.remove());
    serverEnvList.appendChild(item);
}

function updateSelectedServerConfigFromForm() {
    const oldServerName = appState.getSelectedServerName();
    if (!oldServerName || !serverNameInput || !serverCommandInput || !serverArgsList || !serverEnvList) return false;

    const newServerName = serverNameInput.value.trim();
    const command = serverCommandInput.value.trim();

    if (!newServerName || !command) {
        showToast('error', 'Error', 'Server name and command are required.');
        return false;
    }

    const args = Array.from(serverArgsList.querySelectorAll('.arg-input'))
                      .map(input => input.value.trim())
                      .filter(Boolean); // Remove empty args

    const env = {};
    serverEnvList.querySelectorAll('.env-item').forEach(item => {
        const key = item.querySelector('.key-input')?.value.trim();
        const value = item.querySelector('.value-input')?.value.trim();
        if (key) env[key] = value || ''; // Allow empty values
    });

    let config = appState.getServerConfig();
    const serverData = { command, args, env };

    // Handle rename: remove old, add new
    if (oldServerName !== newServerName) {
        delete config.mcpServers[oldServerName];
    }
    config.mcpServers[newServerName] = serverData;

    appState.setServerConfig(config); // Update state
    appState.setSelectedServerName(newServerName); // Update selected name if renamed

    return true; // Indicate success
}


function saveServerConfigurations() {
    // Update the currently selected server's data from the form first
    if (appState.getSelectedServerName()) {
        if (!updateSelectedServerConfigFromForm()) {
            return; // Validation failed in update function
        }
    }

    // Get the potentially updated config from state
    const configToSave = appState.getServerConfig();

    appState.setStatus('Saving server configurations...');
    apiClient.saveServerConfigurations(configToSave).then(success => {
        if (success) {
            closeServersModal();
            // Toast shown by apiClient
        }
        appState.setStatus('Ready'); // Reset status eventually
    });
}


// --- Config Editor Modal Functions ---
export function openConfigEditor(fileName) {
    if (!fileName || !configFileNameElement || !configEditor) return;

    appState.setCurrentConfigFile(fileName);
    configFileNameElement.textContent = fileName;
    configEditor.value = 'Loading...';
    configEditor.disabled = true;
    appState.setStatus(`Loading ${fileName}...`);
    openModal(configModal);

    apiClient.fetchConfigFile(fileName).then(data => {
        let content = data.content;
        // Pretty print JSON
        if (fileName.endsWith('.json')) {
            try {
                content = JSON.stringify(JSON.parse(content), null, 2);
            } catch { /* Ignore parse error, show raw */ }
        }
        configEditor.value = content;
        configEditor.disabled = false;
        appState.setStatus('Ready');
    }).catch(err => {
        configEditor.value = `Error loading ${fileName}:\n${err.message}`;
        appState.setStatus('Error loading config');
        // Optionally close modal on error, or let user close manually
        // closeModal(configModal);
    });
}

export function closeConfigModal() {
    appState.setCurrentConfigFile(null);
    if (configEditor) configEditor.value = ''; // Clear editor
    closeModal(configModal);
}

function saveConfigFile() {
    const fileName = appState.getCurrentConfigFile();
    if (!fileName || !configEditor) return;

    const content = configEditor.value;

    // Basic validation (more specific validation in API client)
    if (fileName.endsWith('.json')) {
        try { JSON.parse(content); } catch (e) {
            showToast('error', 'Invalid JSON', e.message); return;
        }
    }
     if (fileName.endsWith('.toml')) {
        try {
            // Basic TOML validation might be complex client-side, rely on server/API validation
        } catch (e) {
             showToast('error', 'Invalid TOML', e.message); return;
        }
    }


    appState.setStatus(`Saving ${fileName}...`);
    apiClient.saveConfigFile(fileName, content).then(data => {
        if (data.success) {
            closeConfigModal();
            // Toast shown by apiClient
            // If servers.json was saved, maybe refresh server list/status?
            if (fileName === 'servers.json') {
                // Potentially trigger a refresh of server data/status display
                console.log("servers.json saved, consider refreshing server status display.");
            }
             if (fileName === 'ai_config.json') {
                 // Refresh provider data
                 apiClient.fetchProviders().then(data => {
                     appState.setProviders(data.providers);
                     appState.setProviderModels(data.models);
                     appState.setCurrentProvider(data.current);
                     renderProvidersList(); // Re-render sidebar
                 });
             }
        }
        appState.setStatus('Ready');
    }).catch(err => {
        // Error toast shown by apiClient
        appState.setStatus('Error saving config');
    });
}
</file>

<file path="web/js/ui/sidebarUI.js">
// Handles rendering and interactions for the right sidebar panels

import { escapeHtml, formatRelativeTime } from '../utils/helpers.js';
import * as appState from '../state/appState.js';
import { emitNewConversation, emitLoadConversation } from '../socket/socketClient.js';
import * as apiClient from '../api/apiClient.js'; // Import the whole module
import { openConfigEditor } from './modalUI.js'; // Import modal function
import { showToast } from './toast.js'; // Import toast for errors

// DOM Elements
// DOM Elements
let rightPanel; // The actual panel element
let toggleRightPanelBtn; // Button in header
let closeRightPanelBtn; // Button inside panel (for mobile)
let conversationsListElement;
let newConversationBtn;
let providersListElement;
let toolsListElement;
let toolFilterInput;
let editConfigsBtn;
let configOptionButtons;
let panelSections; // To store all panel sections

export function init() {
    mainElement = document.querySelector('main');
    toggleRightPanelBtn = document.getElementById('toggle-right-panel');
    conversationsListElement = document.getElementById('conversations-list');
    newConversationBtn = document.getElementById('new-conversation-btn');
    providersListElement = document.getElementById('providers-list');
    toolsListElement = document.getElementById('tools-list');
    toolFilterInput = document.getElementById('tool-filter-input');
    editConfigsBtn = document.getElementById('edit-configs-btn');
    configOptionButtons = document.querySelectorAll('.config-option');
    panelSections = document.querySelectorAll('.right-panel .panel-section'); // Get all sections

    if (!mainElement || !toggleRightPanelBtn || !conversationsListElement || !newConversationBtn || !providersListElement || !toolsListElement || !toolFilterInput || !editConfigsBtn || !panelSections) {
        console.error("Sidebar UI elements not found!");
        return;
    }

    // Event Listeners
    toggleRightPanelBtn.addEventListener('click', toggleRightPanel);
    newConversationBtn.addEventListener('click', handleNewConversation);
    toolFilterInput.addEventListener('input', handleToolFilterChange);
    editConfigsBtn.addEventListener('click', showConfigOptions);

    configOptionButtons.forEach(button => {
        button.addEventListener('click', () => {
            const fileName = button.dataset.file;
            if (fileName) {
                openConfigEditor(fileName); // Call function from modalUI
            }
        });
    });

    // Accordion listeners
    panelSections.forEach(section => {
        const header = section.querySelector('h3');
        if (header) {
            header.addEventListener('click', () => {
                toggleAccordionSection(section);
            });
        }
    });

    // Set initial state (e.g., open Conversations by default)
    const initialSection = document.querySelector('.conversations-panel');
    if (initialSection) {
        initialSection.classList.add('active');
    }

    console.log("Sidebar UI initialized.");
}

function toggleAccordionSection(sectionToToggle) {
    panelSections.forEach(section => {
        if (section === sectionToToggle) {
            section.classList.toggle('active'); // Toggle the clicked section
        } else {
            section.classList.remove('active'); // Close all other sections
        }
    });
    rightPanel = document.getElementById('right-panel');
    closeRightPanelBtn = document.getElementById('close-right-panel-btn');

    if (!rightPanel || !toggleRightPanelBtn || !closeRightPanelBtn || !conversationsListElement || !newConversationBtn || !providersListElement || !toolsListElement || !toolFilterInput || !editConfigsBtn || !panelSections) {
        console.error("Sidebar UI elements not found!");
        return;
    }

    // Event Listeners
    toggleRightPanelBtn.addEventListener('click', toggleRightPanel);
    closeRightPanelBtn.addEventListener('click', toggleRightPanel); // Close button also toggles
    newConversationBtn.addEventListener('click', handleNewConversation);
    toolFilterInput.addEventListener('input', handleToolFilterChange);
    editConfigsBtn.addEventListener('click', showConfigOptions);

function handleNewConversation() {
    emitNewConversation();
    // UI updates (clearing chat, selecting new item) are handled by socket event listeners
}

function handleToolFilterChange() {
    renderToolsList(appState.getAllToolsData()); // Re-render with filter applied
}

function showConfigOptions() {
    // Highlight buttons briefly
    configOptionButtons.forEach(btn => btn.classList.add('highlight'));
    setTimeout(() => {
        configOptionButtons.forEach(btn => btn.classList.remove('highlight'));
    }, 3000);
    // Toast handled in main.js or here if preferred
}

// --- Rendering Functions ---

export function renderConversationsList() {
    if (!conversationsListElement) return;

    const conversations = appState.getConversations(); // Get data from state
    const currentConversationId = appState.getCurrentConversationId();

    if (!conversations || conversations.length === 0) {
        conversationsListElement.innerHTML = '<div class="empty-list">No saved conversations</div>';
        return;
    }

    // Sorting is handled in appState now
    let html = '';
    for (const conversation of conversations) {
        const isActive = conversation.id === currentConversationId;
        // Safely parse date, provide fallback
        let updatedDate = new Date(conversation.updatedAt);
        let formattedDate = 'Invalid date';
        let relativeTime = 'unknown';

        if (!isNaN(updatedDate.getTime())) {
            formattedDate = updatedDate.toLocaleDateString() + ' ' + updatedDate.toLocaleTimeString();
            relativeTime = formatRelativeTime(updatedDate);
        } else {
            // Handle cases where updatedAt might be missing or invalid
            console.warn(`Invalid updatedAt date for conversation ${conversation.id}:`, conversation.updatedAt);
            // Optionally try createdAt or provide a default
            updatedDate = new Date(conversation.createdAt); // Try createdAt
             if (!isNaN(updatedDate.getTime())) {
                 formattedDate = updatedDate.toLocaleDateString() + ' ' + updatedDate.toLocaleTimeString();
                 relativeTime = formatRelativeTime(updatedDate);
             } else {
                 formattedDate = 'Date unavailable';
                 relativeTime = 'unknown time';
             }
        }


        const activeClasses = isActive ? 'bg-primary/10 dark:bg-primary/20 border-primary' : 'border-transparent hover:bg-gray-100 dark:hover:bg-gray-700';
        html += `
            <div class="conversation-item p-3 rounded-lg border ${activeClasses} cursor-pointer transition-colors group relative" data-id="${escapeHtml(conversation.id)}">
                <div class="font-medium text-sm truncate mb-1">${escapeHtml(conversation.title || 'Untitled Conversation')}</div>
                <div class="text-xs text-gray-500 dark:text-gray-400 flex justify-between items-center">
                    <span class="truncate" title="${escapeHtml(conversation.provider || '')} - ${escapeHtml(conversation.modelName || '')}">
                        ${escapeHtml(conversation.provider?.substring(0, 8) || 'N/A')} - ${escapeHtml(conversation.modelName?.substring(0, 12) || 'N/A')}
                    </span>
                    <span class="conversation-date flex-shrink-0 ml-2" title="${formattedDate}">${relativeTime}</span>
                </div>
                <div class="conversation-actions absolute top-1 right-1 opacity-0 group-hover:opacity-100 transition-opacity flex gap-1">
                    <button class="conversation-rename-btn btn-icon p-1 text-xs" title="Rename"><i class="fas fa-edit"></i></button>
                    <button class="conversation-delete-btn btn-icon p-1 text-xs text-danger hover:bg-danger/10" title="Delete"><i class="fas fa-trash"></i></button>
                </div>
            </div>
        `;
    }

    conversationsListElement.innerHTML = html;
    addConversationItemListeners(); // Add listeners after rendering
}

function addConversationItemListeners() {
    document.querySelectorAll('.conversation-item').forEach(item => {
        // Load conversation on click (if not clicking actions)
        item.addEventListener('click', (e) => {
            if (!e.target.closest('.conversation-actions')) {
                const conversationId = item.dataset.id;
                if (conversationId !== appState.getCurrentConversationId()) {
                    emitLoadConversation(conversationId);
                }
            }
        });

        // Rename button
        const renameBtn = item.querySelector('.conversation-rename-btn');
        if (renameBtn) {
            renameBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent triggering load
                const conversationId = item.dataset.id;
                const conversation = appState.getConversations().find(c => c.id === conversationId);
                // Removed duplicate declaration of 'conversation'
                if (conversation) {
                    const newTitle = prompt('Enter new title:', conversation.title || '');
                    if (newTitle !== null && newTitle.trim() !== (conversation.title || '')) { // Compare with potentially empty title
                        apiClient.renameConversation(conversationId, newTitle.trim()).then(success => { // Use apiClient namespace
                            if (success) {
                                // Update state and re-render (or wait for socket event)
                                appState.updateConversationInList({ ...conversation, title: newTitle.trim(), updatedAt: new Date().toISOString() }); // Update timestamp
                                renderConversationsList();
                            }
                        });
                    }
                }
            });
        }

        // Delete button
        const deleteBtn = item.querySelector('.conversation-delete-btn');
        if (deleteBtn) {
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent triggering load
                const conversationId = item.dataset.id;
                if (confirm('Are you sure you want to delete this conversation?')) {
                    apiClient.deleteConversation(conversationId).then(success => { // Use apiClient namespace
                        if (success) {
                            // Update state and re-render (or wait for socket event)
                            const wasCurrent = appState.getCurrentConversationId() === conversationId;
                            appState.removeConversationFromList(conversationId);
                            renderConversationsList();
                            if (wasCurrent) {
                                // If current was deleted, emit new conversation event
                                emitNewConversation();
                            }
                        }
                    });
                }
            });
        }
    });
}


export function updateConversationSelection() {
    const currentConversationId = appState.getCurrentConversationId();
    document.querySelectorAll('.conversation-item').forEach(item => {
        item.classList.toggle('active', item.dataset.id === currentConversationId);
    });
}

export function renderProvidersList() {
    if (!providersListElement) return;

    const providers = appState.getProviders();
    const currentProvider = appState.getCurrentProvider();

    if (!providers || Object.keys(providers).length === 0) {
        providersListElement.innerHTML = '<div class="empty-list">No AI providers configured</div>';
        return;
    }

    let html = '';
    // Sort providers alphabetically for consistent order
    const sortedProviderNames = Object.keys(providers).sort();

    for (const name of sortedProviderNames) {
        const config = providers[name];
        const isActive = name === currentProvider;
        const activeClasses = isActive ? 'bg-primary/10 dark:bg-primary/20 border-primary' : 'border-transparent hover:bg-gray-100 dark:hover:bg-gray-700';
        html += `
            <div class="provider-item p-3 rounded-lg border ${activeClasses} cursor-pointer transition-colors" data-provider="${escapeHtml(name)}">
                <div class="flex justify-between items-center mb-1">
                    <span class="font-medium text-sm">${escapeHtml(name)}</span>
                    ${isActive ? '<i class="fas fa-check-circle text-success" title="Active Provider"></i>' : ''}
                </div>
                <div class="text-xs text-gray-500 dark:text-gray-400 truncate" title="${escapeHtml(config.model || '')}">
                    Model: ${escapeHtml(config.model || 'Default')}
                </div>
            </div>
        `;
    }

    providersListElement.innerHTML = html;
    addProviderItemListeners(); // Add listeners after rendering
}

function addProviderItemListeners() {
     document.querySelectorAll('.provider-item').forEach(item => {
        item.addEventListener('click', () => {
            const providerName = item.dataset.provider;
            if (providerName && providerName !== appState.getCurrentProvider()) {
                // Find the default/first model for this provider to switch
                const providerModels = appState.getProviderModels();
                const models = providerModels[providerName.toLowerCase()]?.models || [];
                const targetModel = appState.getProviders()[providerName]?.model || models[0] || ''; // Use configured or first suggested

                if (targetModel) {
                         appState.setStatus(`Switching to ${providerName}...`);
                         // Use API client to switch
                         apiClient.switchProviderAndModel(providerName, targetModel)
                            .catch(err => appState.setStatus('Ready')); // Reset status on error
                         // UI updates are handled by the 'model-changed' socket event
                    } else {
                        showToast('error', 'Error', `No model configured or suggested for provider ${providerName}. Cannot switch.`);
                }
            }
        });
    });
}


export function renderToolsList(toolsByServer) { // Expects { serverName: [tools] }
    if (!toolsListElement || !toolFilterInput) return;

    const filterText = toolFilterInput.value.toLowerCase().trim();
    let html = '';
    let foundTools = false;
    const serverNames = Object.keys(toolsByServer || {}).sort(); // Sort server names

    for (const serverName of serverNames) {
        const tools = toolsByServer[serverName] || [];
        const filteredTools = tools.filter(tool =>
            tool.name.toLowerCase().includes(filterText) ||
            (tool.description && tool.description.toLowerCase().includes(filterText))
        ).sort((a, b) => a.name.localeCompare(b.name)); // Sort tools alphabetically

        if (filteredTools.length > 0) {
            foundTools = true;
            html += `<div class="tool-server-group mb-4 last:mb-0">
                        <h4 class="text-sm font-semibold mb-2 text-gray-600 dark:text-gray-400 border-b border-gray-200 dark:border-gray-700 pb-1">${escapeHtml(serverName)}</h4>
                        <div class="space-y-2">`;
            filteredTools.forEach(tool => {
                html += `
                    <div class="tool-item p-2 rounded bg-gray-50 dark:bg-gray-700/50">
                        <h5 class="text-sm font-medium">${escapeHtml(tool.name)}</h5>
                        <p class="text-xs text-gray-600 dark:text-gray-400">${escapeHtml(tool.description || 'No description')}</p>
                    </div>
                `;
            });
            html += `   </div>
                     </div>`;
        }
    }

    const emptyListClasses = "text-center text-sm text-gray-500 dark:text-gray-400 py-4";
    if (!foundTools) {
        if (Object.keys(toolsByServer || {}).length === 0) {
            html = `<div class="${emptyListClasses}">No tools available from connected servers.</div>`;
        } else if (filterText) {
            html = `<div class="${emptyListClasses}">No tools match filter "${escapeHtml(filterText)}".</div>`;
        } else {
             html = `<div class="${emptyListClasses}">No tools found.</div>`;
        }
    }

    toolsListElement.innerHTML = html;
}
</file>

<file path="web/js/ui/toast.js">
// Function to display toast notifications

import { escapeHtml } from '../utils/helpers.js';

let toastTimeout = null;

/**
 * Displays a toast notification.
 * @param {'success' | 'error' | 'warning' | 'info'} type The type of toast.
 * @param {string} title The title of the toast.
 * @param {string} message The main message content.
 */
export function showToast(type, title, message) {
    // Remove existing toast if any
    const existingToast = document.querySelector('.toast');
    if (existingToast) {
        // Allow fade-out animation to complete before removing
        existingToast.classList.remove('show');
        setTimeout(() => {
            if (existingToast.parentNode) {
                existingToast.remove();
            }
        }, 500); // Match transition duration
    }

    // Clear existing timeout
    if (toastTimeout) {
        clearTimeout(toastTimeout);
    }

    // Create toast element using Tailwind classes defined in base.css @layer components
    const toast = document.createElement('div');
    toast.className = `toast ${type}`; // Base class + type for styling

    // Set icon based on type using FontAwesome classes
    let iconClass = '';
    switch (type) {
        case 'success': iconClass = 'fas fa-check-circle'; break;
        case 'error': iconClass = 'fas fa-exclamation-circle'; break;
        case 'warning': iconClass = 'fas fa-exclamation-triangle'; break;
        case 'info': iconClass = 'fas fa-info-circle'; break;
        default: iconClass = 'fas fa-bell'; // Default icon
    }

    // Create toast content using Tailwind structure
    toast.innerHTML = `
        <div class="toast-icon"><i class="${iconClass}"></i></div>
        <div class="toast-content">
            <div class="toast-title">${escapeHtml(title)}</div>
            <div class="toast-message">${escapeHtml(message)}</div>
        </div>
        <button class="toast-close ml-auto p-1"><i class="fas fa-times"></i></button>
    `;

    // Add close functionality
    toast.querySelector('.toast-close').addEventListener('click', () => {
        toast.classList.remove('show');
        // Ensure removal even if transition fails or timeout cleared
        setTimeout(() => {
             if (toast.parentNode) toast.remove();
        }, 500);
        if (toastTimeout) clearTimeout(toastTimeout); // Clear timeout if closed manually
    });

    // Add to document
    document.body.appendChild(toast);

    // Show the toast (force reflow before adding class)
    requestAnimationFrame(() => {
        requestAnimationFrame(() => {
             toast.classList.add('show');
        });
    });


    // Auto-hide after 4 seconds
    toastTimeout = setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
            if (toast.parentNode) toast.remove();
        }, 500); // Allow fade out
    }, 4000);
}
</file>

<file path="web/js/utils/helpers.js">
// Utility functions

/**
 * Escapes HTML special characters in a string.
 * @param {string | number | null | undefined} unsafe The string to escape.
 * @returns {string} The escaped string.
 */
export function escapeHtml(unsafe) {
    if (unsafe === undefined || unsafe === null) {
        return '';
    }
    if (typeof unsafe !== 'string') {
        // Attempt to convert non-strings before escaping
        try {
            unsafe = String(unsafe);
        } catch (e) {
            console.error("Failed to convert value to string for escaping:", unsafe, e);
            return ''; // Return empty string on conversion failure
        }
    }
    return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}


/**
 * Formats a date object, string, or timestamp into a relative time string (e.g., "2 hours ago").
 * @param {Date | string | number | null | undefined} dateInput The date object, string, or timestamp to format.
 * @returns {string} The relative time string or an error message.
 */
export function formatRelativeTime(dateInput) {
    let date;
    if (dateInput instanceof Date) {
        date = dateInput;
    } else if (typeof dateInput === 'string' || typeof dateInput === 'number') {
        date = new Date(dateInput);
    } else {
        return 'Invalid date input';
    }

    if (isNaN(date.getTime())) {
        return 'Invalid date'; // Handle invalid date after parsing
    }

    const now = new Date();
    const diffMs = now.getTime() - date.getTime(); // Use getTime() for reliable comparison

    // Handle future dates or very recent times
    if (diffMs < 0) return 'In the future';
    if (diffMs < 1000) return 'Just now'; // Less than a second

    const diffSec = Math.floor(diffMs / 1000);
    const diffMin = Math.floor(diffSec / 60);
    const diffHour = Math.floor(diffMin / 60);
    const diffDay = Math.floor(diffHour / 24);
    const diffWeek = Math.floor(diffDay / 7);
    const diffMonth = Math.floor(diffDay / 30); // Approximate
    const diffYear = Math.floor(diffDay / 365); // Approximate

    if (diffSec < 60) {
        return `${diffSec} sec${diffSec !== 1 ? 's' : ''} ago`;
    } else if (diffMin < 60) {
        return `${diffMin} min${diffMin !== 1 ? 's' : ''} ago`;
    } else if (diffHour < 24) {
        return `${diffHour} hour${diffHour !== 1 ? 's' : ''} ago`;
    } else if (diffDay < 7) {
        return `${diffDay} day${diffDay !== 1 ? 's' : ''} ago`;
    } else if (diffWeek < 5) { // Show weeks up to about a month
        return `${diffWeek} week${diffWeek !== 1 ? 's' : ''} ago`;
    } else {
        // For older dates, show the actual date
        return date.toLocaleDateString(undefined, {
            year: 'numeric', month: 'short', day: 'numeric'
        });
    }
}

/**
 * Formats tool calls within AI response content.
 * @param {string} content The raw AI response content.
 * @returns {string} HTML formatted content with tool calls visualized.
 */
export function formatToolCalls(content) {
    // Basic regex, assumes JSON is well-formed between delimiters
    const toolCallRegex = /<<<TOOL_CALL>>>([\s\S]*?)<<<END_TOOL_CALL>>>/g;

    return content.replace(toolCallRegex, (match, toolCallContent) => {
        try {
            const toolCall = JSON.parse(toolCallContent.trim());
            const toolName = toolCall.name || 'unknown_tool';
            const argsString = JSON.stringify(toolCall.arguments || {}, null, 2);

            return `
                <div class="tool-call bg-purple-100 dark:bg-purple-900/30 p-1 my-1 rounded border-l-2 border-purple-500 w-full">
                    <div class="tool-call-header text-xs font-semibold text-purple-700 dark:text-purple-400 inline-block mr-2">Tool Call: ${escapeHtml(toolName)}</div>
                    <pre class="tool-call-content text-xs font-mono whitespace-pre-wrap overflow-x-auto bg-white/50 dark:bg-gray-800/50 p-1 rounded text-gray-800 dark:text-gray-200">${escapeHtml(argsString)}</pre>
                </div>
            `;
        } catch (error) {
            console.warn('Failed to parse tool call JSON:', error);
            // Fallback: display the raw content escaped
            return `<pre class="tool-call error inline-block bg-red-100 dark:bg-red-900/30 p-2 border-l-2 border-red-500 text-xs max-w-full">${escapeHtml(match)}</pre>`;
        }
    });
}
</file>

<file path="web/js/main.js">
// Main entry point for the frontend application

import * as appState from './state/appState.js';
import * as apiClient from './api/apiClient.js';
import * as socketClient from './socket/socketClient.js';
import * as chatUI from './ui/chatUI.js';
import * as sidebarUI from './ui/sidebarUI.js';
import * as modalUI from './ui/modalUI.js';
import * as headerUI from './ui/headerUI.js';
import { showToast } from './ui/toast.js';

// --- Initialization ---
function initializeApp() {
    console.log("Initializing application modules...");
    appState.setStatus('Initializing...');

    // Initialize state
    appState.initState();

    // Initialize UI components (add event listeners etc.)
    headerUI.init();
    chatUI.init();
    sidebarUI.init();
    modalUI.init();

    // Initialize Socket.IO connection and listeners
    socketClient.init({
        onConnect: () => appState.setStatus('Connected'),
        onDisconnect: (reason) => appState.setStatus(`Disconnected: ${reason}`),
        // Pass UI update functions or state setters to socket handlers
        onServersInfo: headerUI.updateServerInfo,
        onHistory: chatUI.renderConversationHistory,
        onHistoryUpdate: chatUI.renderConversationHistory,
        onThinking: chatUI.updateThinkingIndicator,
        onToolsInfo: (tools) => {
            // Assuming tools is { serverName: [tool] }
            console.log('[main.js] Received tools-info via socket:', Object.keys(tools)); // Log server names
            appState.setAllToolsData(tools); // Set state once
            sidebarUI.renderToolsList(tools); // Pass data directly to UI
        },
        // onStatusUpdate removed as per previous fix
        onError: (message) => {
            // Error toast is shown by socketClient, just update status maybe
            appState.setStatus('Error');
            chatUI.displayError(message); // Also display in chat
        },
        onConversationCleared: () => {
            chatUI.clearConversationDisplay();
            showToast('info', 'Conversation Cleared', 'Started a new chat session.');
        },
        onModelChanged: (data) => {
            // Update state first
            appState.setCurrentProvider(data.provider);
            // Fetch providers again to get potentially updated model in config
            apiClient.fetchProviders().then(pData => {
                appState.setProviders(pData.providers);
                appState.setProviderModels(pData.models);
                // Update header and sidebar
                headerUI.updateModelInfo(data.provider, data.model);
                sidebarUI.renderProvidersList();
            });
            modalUI.closeModelModal(); // Close modal if open
            showToast('success', 'Model Changed', `Switched to ${data.model} (${data.provider})`);
        },
        onConversationsList: (conversations) => {
            appState.setConversations(conversations);
            sidebarUI.renderConversationsList();
        },
        onConversationLoaded: (data) => {
            appState.setCurrentConversationId(data.id);
            sidebarUI.updateConversationSelection();
            chatUI.renderConversationHistory(data.messages);
            appState.setStatus('Ready'); // Set status to ready after loading
        },
        onConversationSaved: (data) => {
            // Toast handled by the action initiator (e.g., after sending message)
            // Update state and UI list
            appState.updateConversationInList(data);
            sidebarUI.renderConversationsList();
            appState.setCurrentConversationId(data.id); // Ensure current ID is set
        },
    });

    // --- Initial Data Fetching ---
    // Fetch conversations first
    appState.setStatus('Loading conversations...');
    apiClient.fetchConversationsList().then(convos => {
        appState.setConversations(convos);
        sidebarUI.renderConversationsList(); // Render initial list

        // Load initial conversation if needed
        const currentId = appState.getCurrentConversationId(); // Check if already loaded via socket
        if (!currentId && convos.length > 0) {
            const sortedConversations = [...convos].sort((a, b) => {
                return new Date(b.updatedAt) - new Date(a.updatedAt);
            });
            if (sortedConversations[0]) {
                console.log(`Loading most recent conversation: ${sortedConversations[0].id}`);
                socketClient.emitLoadConversation(sortedConversations[0].id);
            } else {
                 appState.setStatus('Ready'); // No conversation to load
            }
        } else if (!currentId) {
             appState.setStatus('Ready'); // No conversations exist
        }
        // If currentId exists, assume socket 'conversation-loaded' handled it

        // Fetch providers after conversations (or in parallel)
        appState.setStatus('Loading AI providers...');
        return apiClient.fetchProviders();
    }).then(data => {
        appState.setProviders(data.providers);
        appState.setProviderModels(data.models);
        appState.setCurrentProvider(data.current);
        sidebarUI.renderProvidersList(); // Initial render
        // Update header model info based on fetched current provider/model
        const currentProviderData = data.providers[data.current];
        headerUI.updateModelInfo(data.current, currentProviderData?.model);
        // Don't set status to Ready here if a conversation is still loading
        if (!appState.getCurrentConversationId() && appState.getConversations().length === 0) {
             appState.setStatus('Ready');
        }
    }).catch(err => {
        console.error("Error during initial data fetch:", err);
        appState.setStatus('Initialization Error');
        // Toasts are shown by apiClient calls
    });

    console.log("Application initialization sequence started.");
}

// --- Run Initialization ---
// Ensure DOM is ready before running initialization
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeApp);
} else {
    initializeApp(); // DOMContentLoaded has already fired
}
</file>

<file path="web/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCP Multi-Client</title>
    <!-- Single Tailwind CSS build -->
    <link rel="stylesheet" href="build/tailwind.css">
    <!-- FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
</head>
<body class="bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-gray-100">
    <div class="min-h-screen flex flex-col">
        <header class="bg-gradient-to-r from-secondary to-primary text-white py-4 px-6 shadow-md sticky top-0 z-40">
            <div class="container mx-auto flex flex-col md:flex-row items-center justify-between gap-4">
                <div class="flex items-center">
                    <h1 class="text-2xl font-bold">MCP Multi-Client</h1>
                </div>
                <div class="info-controls flex items-center gap-4">
                    <button id="toggle-right-panel" class="bg-white/10 hover:bg-white/20 p-2 rounded-lg transition-colors" title="Toggle Sidebar">
                        <i class="fas fa-columns"></i>
                    </button>
                    <div class="server-info flex flex-col md:flex-row gap-4 bg-white/10 rounded-lg px-4 py-2">
                        <div class="info-item flex items-center gap-2">
                            <i class="fas fa-server text-white/80"></i>
                            <span id="connected-servers" class="text-sm font-medium">Loading...</span>
                            <button id="manage-servers-btn" class="hover:bg-white/10 p-1 rounded" title="Manage servers">
                                <i class="fas fa-cog"></i>
                            </button>
                        </div>
                        <div class="info-item model-info flex items-center gap-2">
                            <i class="fas fa-robot text-white/80"></i>
                            <span id="ai-model" class="text-sm font-medium">Loading...</span>
                            <button id="change-model-btn" class="hover:bg-white/10 p-1 rounded" title="Change AI model">
                                <i class="fas fa-cog"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </header>

        <!-- Main content area with sidebar -->
        <main class="flex-grow flex container mx-auto px-4 py-6 gap-6 relative">
            <!-- Conversation Area -->
            <div class="flex-grow flex flex-col gap-5">
                <div id="conversation" class="flex-grow rounded-xl shadow-lg bg-white dark:bg-gray-800 p-6 overflow-y-auto max-h-[calc(100vh-240px)]">
                    <!-- Messages will be added here dynamically -->
                    <div class="flex items-center justify-center h-full text-gray-400 dark:text-gray-500">
                        <p class="text-center">Start a new conversation or select an existing one</p>
                    </div>
                </div>

                <div class="input-area bg-white dark:bg-gray-800 rounded-xl shadow-lg p-5 relative">
                    <div id="thinking-spinner" class="spinner hidden"></div>
                    <textarea id="user-input" class="w-full p-4 border border-gray-200 dark:border-gray-700 rounded-lg focus:ring-2 focus:ring-primary focus:border-primary resize-none dark:bg-gray-700 dark:text-white" placeholder="Type your message here..."></textarea>
                    <div class="button-group flex justify-between mt-4">
                        <button id="send-button" class="bg-primary hover:bg-primary/90 text-white py-2.5 px-5 rounded-lg transition-colors font-medium">
                            <i class="fas fa-paper-plane mr-2"></i> Send
                        </button>
                        <button id="clear-button" class="bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-200 py-2.5 px-5 rounded-lg transition-colors font-medium">
                            <i class="fas fa-trash mr-2"></i> Clear
                        </button>
                    </div>
                </div>

                <!-- Input Area -->
                <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-5 relative">
                    <div id="thinking-spinner" class="spinner hidden"></div>
                    <textarea id="user-input" class="form-textarea block w-full p-4 border border-gray-200 dark:border-gray-700 rounded-lg focus:ring-2 focus:ring-primary focus:border-primary resize-none dark:bg-gray-700 dark:text-white" placeholder="Type your message here..."></textarea>
                    <div class="flex justify-between mt-4">
                        <button id="send-button" class="btn btn-primary">
                            <i class="fas fa-paper-plane mr-2"></i> Send
                        </button>
                        <button id="clear-button" class="btn btn-secondary">
                            <i class="fas fa-trash mr-2"></i> Clear
                        </button>
                    </div>
                </div>
            </div>

            <!-- Right Sidebar -->
            <div id="right-panel" class="right-panel w-80 space-y-6 absolute lg:relative top-0 right-0 h-full bg-gray-50 dark:bg-gray-900 p-4 lg:p-0 lg:bg-transparent lg:dark:bg-transparent transform translate-x-full lg:translate-x-0 transition-transform duration-300 ease-in-out z-30 lg:z-auto shadow-lg lg:shadow-none overflow-y-auto">
                 <!-- Close button for mobile -->
                 <button id="close-right-panel-btn" class="absolute top-2 right-2 lg:hidden btn-icon text-gray-500 dark:text-gray-400" title="Close Sidebar">
                     <i class="fas fa-times"></i>
                 </button>

                <!-- Conversations Panel -->
                <div class="panel-section active"> <!-- Start with conversations open -->
                    <h3 class="panel-header">
                        <span class="flex items-center gap-2">
                            <i class="fas fa-comments text-primary"></i> Conversations
                        </span>
                        <button id="new-conversation-btn" class="hover:bg-primary/10 p-1.5 rounded-full" title="New conversation">
                            <i class="fas fa-plus text-primary"></i>
                        </button>
                    </h3>
                    <div class="panel-content">
                        <div id="conversations-list" class="conversations-list p-4">Loading...</div>
                    </div>
                </div>
                
                <div class="panel-section rounded-xl shadow-md bg-white dark:bg-gray-800 overflow-hidden" id="providers-panel">
                    <h3 class="px-5 py-3 bg-gray-50 dark:bg-gray-700 font-medium flex items-center gap-2 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors">
                        <i class="fas fa-plug text-primary"></i> AI Providers
                    </h3>
                    <div class="panel-content">
                        <div id="providers-list" class="providers-list p-4">Loading...</div>
                    </div>
                </div>
                
                <div class="panel-section rounded-xl shadow-md bg-white dark:bg-gray-800 overflow-hidden">
                    <h3 class="px-5 py-3 bg-gray-50 dark:bg-gray-700 font-medium flex items-center gap-2 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors">
                        <i class="fas fa-tools text-primary"></i> Available Tools
                    </h3>
                    <div class="panel-content">
                        <div class="p-4">
                            <input type="text" id="tool-filter-input" placeholder="Filter tools..." class="w-full mb-3 p-2 border border-gray-200 dark:border-gray-700 rounded-lg dark:bg-gray-700 dark:text-white">
                            <div id="tools-list" class="tools-list max-h-60 overflow-y-auto">Loading...</div>
                        </div>
                    </div>
                </div>
                
                <div class="panel-section rounded-xl shadow-md bg-white dark:bg-gray-800 overflow-hidden">
                    <h3 class="px-5 py-3 bg-gray-50 dark:bg-gray-700 font-medium flex items-center justify-between cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors">
                        <span class="flex items-center gap-2">
                            <i class="fas fa-cog text-primary"></i> Configuration
                        </span>
                        <button id="edit-configs-btn" class="hover:bg-primary/10 p-1.5 rounded-full" title="Edit configuration files">
                            <i class="fas fa-edit text-primary"></i>
                        </button>
                    </h3>
                    <div class="panel-content">
                        <div class="p-4">
                            <div class="config-options grid grid-cols-2 gap-3">
                                <button class="config-option flex flex-col items-center justify-center p-3 bg-gray-50 dark:bg-gray-700 hover:bg-gray-100 dark:hover:bg-gray-600 rounded-lg transition-colors" data-file="ai_config.json">
                                    <i class="fas fa-robot text-xl text-primary mb-2"></i>
                                    <span class="text-sm">AI Config</span>
                                </button>
                                <button class="config-option flex flex-col items-center justify-center p-3 bg-gray-50 dark:bg-gray-700 hover:bg-gray-100 dark:hover:bg-gray-600 rounded-lg transition-colors" data-file="servers.json">
                                    <i class="fas fa-server text-xl text-primary mb-2"></i>
                                    <span class="text-sm">Servers</span>
                                </button>
                                <button class="config-option flex flex-col items-center justify-center p-3 bg-gray-50 dark:bg-gray-700 hover:bg-gray-100 dark:hover:bg-gray-600 rounded-lg transition-colors" data-file="provider_models.toml">
                                    <i class="fas fa-list text-xl text-primary mb-2"></i>
                                    <span class="text-sm">Models</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <footer class="bg-white dark:bg-gray-800 py-4 px-6 shadow-inner border-t border-gray-200 dark:border-gray-700">
            <div class="container mx-auto text-center text-gray-500 dark:text-gray-400">
                <div id="status" class="font-medium">Ready</div>
            </div>
        </footer>
    </div>

    <!-- Model Change Modal -->
    <div id="model-modal" class="modal">
        <div class="modal-content max-w-md mx-auto bg-white dark:bg-gray-800 rounded-xl shadow-xl p-6">
            <div class="flex justify-between items-center mb-5">
                <h2 class="text-xl font-bold text-gray-800 dark:text-white">Change AI Provider/Model</h2>
                <span class="close text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 text-2xl cursor-pointer">&times;</span>
            </div>
            
            <div class="space-y-6">
                <div class="space-y-2">
                    <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300">Select Provider</h3>
                    <select id="provider-select" class="w-full p-2.5 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-primary">
                        <!-- Options will be added dynamically -->
                    </select>
                </div>
                
                <div class="space-y-2">
                    <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300">Select Model</h3>
                    <select id="model-select" class="w-full p-2.5 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-primary">
                        <!-- Options will be added dynamically -->
                    </select>
                </div>
                
                <div class="space-y-2">
                    <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300">API Key</h3>
                    <div class="relative">
                        <input type="password" id="api-key-input" placeholder="Enter API key for this provider" class="w-full p-2.5 pr-10 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-primary">
                        <button id="toggle-api-key-visibility" class="absolute right-3 top-1/2 -translate-y-1/2 text-gray-500 hover:text-gray-700 dark:hover:text-gray-300" title="Toggle visibility">
                            <i class="fas fa-eye"></i>
                        </button>
                    </div>
                    <div class="text-xs text-gray-500 dark:text-gray-400 italic mt-1">
                        API keys are saved directly in the configuration file.
                    </div>
                </div>
                
                <div class="flex justify-end gap-3 pt-4 border-t border-gray-200 dark:border-gray-700">
                    <button id="cancel-model-change" class="px-4 py-2 bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-white rounded-lg transition-colors">Cancel</button>
                    <button id="apply-model-change" class="px-4 py-2 bg-primary hover:bg-primary/90 text-white rounded-lg transition-colors">Apply</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Server Configuration Modal -->
    <div id="servers-modal" class="modal">
        <div class="modal-content max-w-4xl mx-auto bg-white dark:bg-gray-800 rounded-xl shadow-xl p-6">
            <div class="flex justify-between items-center mb-5">
                <h2 class="text-xl font-bold text-gray-800 dark:text-white">Manage MCP Servers</h2>
                <span class="close text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 text-2xl cursor-pointer">&times;</span>
            </div>
            
            <div class="space-y-6">
                <div class="space-y-4">
                    <h3 class="text-base font-medium text-gray-700 dark:text-gray-300">Server Configurations</h3>
                    <div class="server-editor border border-gray-200 dark:border-gray-700 rounded-xl overflow-hidden grid grid-cols-1 lg:grid-cols-3">
                        <div class="server-list bg-gray-50 dark:bg-gray-700 border-b lg:border-b-0 lg:border-r border-gray-200 dark:border-gray-600">
                            <div class="server-list-header flex items-center justify-between p-3 border-b border-gray-200 dark:border-gray-600">
                                <h4 class="font-medium text-gray-800 dark:text-white">Servers</h4>
                                <button id="add-server-btn" class="p-1 hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full" title="Add new server">
                                    <i class="fas fa-plus text-primary"></i>
                                </button>
                            </div>
                            <ul id="server-list-items" class="max-h-80 overflow-y-auto p-2">
                                <!-- Server items will be added dynamically -->
                            </ul>
                        </div>
                        <div class="server-details col-span-2 p-5 bg-white dark:bg-gray-800">
                            <div id="server-form" class="hidden space-y-5">
                                <div class="space-y-2">
                                    <label for="server-name" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Server Name</label>
                                    <input type="text" id="server-name" placeholder="e.g., bash, search" class="w-full p-2.5 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-primary">
                                </div>
                                <div class="space-y-2">
                                    <label for="server-command" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Command</label>
                                    <input type="text" id="server-command" placeholder="e.g., npx" class="w-full p-2.5 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-primary">
                                </div>
                                <div class="space-y-2">
                                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">Arguments</label>
                                    <div id="server-args" class="args-list space-y-2">
                                        <!-- Args will be added dynamically -->
                                    </div>
                                    <button id="add-arg-btn" class="mt-2 px-3 py-1.5 bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 text-gray-800 dark:text-white text-sm rounded-lg transition-colors">
                                        <i class="fas fa-plus mr-1.5"></i> Add Argument
                                    </button>
                                </div>
                                <div class="space-y-2">
                                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">Environment Variables</label>
                                    <div id="server-env" class="env-list space-y-3">
                                        <!-- Env vars will be added dynamically -->
                                    </div>
                                    <button id="add-env-btn" class="mt-2 px-3 py-1.5 bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 text-gray-800 dark:text-white text-sm rounded-lg transition-colors">
                                        <i class="fas fa-plus mr-1.5"></i> Add Environment Variable
                                    </button>
                                </div>
                            </div>
                            <div id="no-server-selected" class="centered-message flex items-center justify-center h-64 text-gray-500 dark:text-gray-400">
                                <p>Select a server from the list or add a new one</p>
                            </div>
                        </div>
                    </div>
                    <div class="text-xs text-gray-500 dark:text-gray-400 italic">
                        <b>Note:</b> Changes to server configurations require restarting the application to take effect.
                    </div>
                </div>
                
                <div class="flex justify-end gap-3 pt-4 border-t border-gray-200 dark:border-gray-700">
                    <button id="cancel-servers-change" class="px-4 py-2 bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-white rounded-lg transition-colors">Cancel</button>
                    <button id="apply-servers-change" class="px-4 py-2 bg-primary hover:bg-primary/90 text-white rounded-lg transition-colors">Save Changes</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Config Editor Modal -->
    <div id="config-modal" class="modal">
        <div class="modal-content max-w-4xl mx-auto bg-white dark:bg-gray-800 rounded-xl shadow-xl p-6">
            <div class="flex justify-between items-center mb-5">
                <h2 class="text-xl font-bold text-gray-800 dark:text-white">Edit Configuration File</h2>
                <span class="close text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 text-2xl cursor-pointer">&times;</span>
            </div>
            
            <div class="space-y-4">
                <h3 id="config-file-name" class="text-lg font-medium text-gray-700 dark:text-gray-300">Configuration File</h3>
                <div class="code-editor-wrapper border border-gray-300 dark:border-gray-600 rounded-lg overflow-hidden bg-gray-50 dark:bg-gray-900 h-96">
                    <textarea id="config-editor" class="w-full h-full p-4 font-mono text-sm bg-gray-50 dark:bg-gray-900 text-gray-800 dark:text-gray-100 focus:outline-none" placeholder="Loading configuration..."></textarea>
                </div>
                <div class="text-xs text-amber-600 dark:text-amber-400 bg-amber-50 dark:bg-amber-900/30 p-3 rounded-lg">
                    <b>Warning:</b> Be careful when editing configuration files. Invalid JSON or TOML syntax may cause the application to malfunction.
                </div>
                
                <div class="flex justify-end gap-3 pt-4 border-t border-gray-200 dark:border-gray-700">
                    <button id="cancel-config-change" class="px-4 py-2 bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-white rounded-lg transition-colors">Cancel</button>
                    <button id="apply-config-change" class="px-4 py-2 bg-primary hover:bg-primary/90 text-white rounded-lg transition-colors">Save Changes</button>
                </div>
            </div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <!-- Remove old script tag -->
    <!-- <script src="app.js"></script> -->
    <!-- Add new module script tag -->
    <script type="module" src="js/main.js"></script>
</body>
</html>
</file>

<file path="web/styles-additional.css">
/* This file intentionally left empty */
/* All styles have been consolidated into the main CSS files and Tailwind utility classes */
</file>

<file path="ai_config.json">
{
  "defaultProvider": "anthropic",
  "providers": {
    "anthropic": {
      "provider": "anthropic",
      "model": "claude-3-7-sonnet-latest",
      "apiKeyEnvVar": "ANTHROPIC_API_KEY",
      "temperature": 0.7
    },
    "openai": {
      "provider": "openai",
      "model": "o3",
      "temperature": 1,
      "apiKeyEnvVar": "OPENAI_API_KEY"
    },
    "google-genai": {
      "provider": "google-genai",
      "model": "gemini-2.5-pro-preview-03-25",
      "apiKeyEnvVar": "GEMINI_API_KEY"
    },
    "openrouter": {
      "provider": "openrouter",
      "model": "openai/gpt-4.1",
      "apiKeyEnvVar": "OPENROUTER_API_KEY",
      "temperature": 0.7
    }
  }
}
</file>

<file path="index.ts">
import * as fs from 'node:fs';
import * as path from 'node:path';
import { fileURLToPath } from 'node:url';
import TOML from '@ltd/j-toml';
import { ServerManager } from './src/ServerManager.js';
import { Repl } from './src/Repl.js';
import * as readline from 'node:readline'; // Import readline for prompting
// Re-add AiProviderConfig import
import type { ConfigFileStructure, AiConfigFileStructure, ProviderModelsStructure, AiProviderConfig } from './src/types.js';
import { AiClientFactory, MissingApiKeyError } from './src/ai/AiClientFactory.js'; // Import Factory and Error
import type { IAiClient } from './src/ai/IAiClient.js';
import { ConversationManager } from './src/conversation/ConversationManager.js';
import { WebServer } from './src/web/WebServer.js';
// Import new services
import { ConversationPersistenceService } from './src/conversation/persistence/ConversationPersistenceService.js';
import { ToolExecutor } from './src/conversation/execution/ToolExecutor.js';
import { VerificationService } from './src/conversation/verification/VerificationService.js'; // Import VerificationService
// PromptFactory is used statically, no instance needed usually

// Helper to get the directory name in ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const baseDir = path.join(__dirname); // Define baseDir here for persistence service

/**
 * Main entry point for the MCP Multi-Client
 */
async function main() {
  console.log('Starting MCP Multi-Client...');

  // --- Configuration Loading ---
  // baseDir defined above
  const serversConfigPath = path.join(baseDir, 'servers.json');
  const aiConfigPath = path.join(baseDir, 'ai_config.json');
  const providerModelsPath = path.join(baseDir, 'provider_models.toml');

  let serversConfigData: ConfigFileStructure;
  let aiConfigData: AiConfigFileStructure;
  let providerModels: ProviderModelsStructure = {};

  // --- Load Server Configuration (servers.json) ---
  try {
    const serversConfigFile = fs.readFileSync(serversConfigPath, 'utf-8');
    serversConfigData = JSON.parse(serversConfigFile) as ConfigFileStructure;

    // Basic validation
    if (!serversConfigData || typeof serversConfigData.mcpServers !== 'object') {
      throw new Error("Invalid servers.json format: 'mcpServers' object not found.");
    }

    // Ensure only 'mcpServers' key exists
    const allowedKeys = ['mcpServers'];
    const actualKeys = Object.keys(serversConfigData);
    if (actualKeys.length !== 1 || actualKeys[0] !== 'mcpServers') {
         const invalidKeys = actualKeys.filter(k => !allowedKeys.includes(k));
         throw new Error(`Invalid keys found in servers.json: ${invalidKeys.join(', ')}. Only 'mcpServers' is allowed.`);
    }

    const serverNames = Object.keys(serversConfigData.mcpServers);
    console.log(`Loaded ${serverNames.length} server configurations from servers.json: ${serverNames.join(', ')}`);
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
      // Create example servers.json
      const exampleServersConfig: ConfigFileStructure = {
        mcpServers: {
          example: {
            command: 'npx',
            args: ['-y', '@example/mcp-server@latest'],
            env: {}
          }
        }
        // timeouts removed
      };
      fs.writeFileSync(serversConfigPath, JSON.stringify(exampleServersConfig, null, 2), 'utf-8');
      console.error(`Server configuration file not found. An example has been created at ${serversConfigPath}.`);
      console.error('Please edit this file and restart the application.');
      process.exit(1);
    } else {
      console.error('Error loading server configuration (servers.json):', error instanceof Error ? error.message : String(error));
      process.exit(1);
    }
  }

  // --- Load AI Configuration (ai_config.json) ---
  try {
    const aiConfigFile = fs.readFileSync(aiConfigPath, 'utf-8');
    aiConfigData = JSON.parse(aiConfigFile) as AiConfigFileStructure;

    // Basic validation
    if (!aiConfigData || typeof aiConfigData.providers !== 'object') {
      throw new Error("Invalid ai_config.json format: 'providers' object not found.");
    }
    if (aiConfigData.defaultProvider && typeof aiConfigData.defaultProvider !== 'string') {
        throw new Error("Invalid ai_config.json format: 'defaultProvider' must be a string if present.");
    }
     // Ensure no other top-level keys exist
    const allowedAiKeys = ['defaultProvider', 'providers'];
    for (const key in aiConfigData) {
        if (!allowedAiKeys.includes(key)) {
            console.warn(`Warning: Unexpected key "${key}" found in ai_config.json. It will be ignored.`);
        }
    }

    console.log(`Loaded AI configuration from ai_config.json for providers: ${Object.keys(aiConfigData.providers).join(', ')}`);
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
      // Create example ai_config.json
      const exampleAiConfig: AiConfigFileStructure = {
        defaultProvider: "anthropic", // Example default
        providers: {
          anthropic: {
            provider: "anthropic",
            model: "claude-3-5-sonnet-20240620",
            apiKeyEnvVar: "ANTHROPIC_API_KEY",
            temperature: 0.7
          },
          openai: {
            provider: "openai",
            model: "gpt-4o-mini",
            apiKeyEnvVar: "OPENAI_API_KEY",
            temperature: 1.0
          }
        }
      };
      fs.writeFileSync(aiConfigPath, JSON.stringify(exampleAiConfig, null, 2), 'utf-8');
      console.error(`AI configuration file not found. An example has been created at ${aiConfigPath}.`);
      console.error('Please edit this file (especially API keys/models) and restart.');
      process.exit(1);
    } else {
      console.error('Error loading AI configuration (ai_config.json):', error instanceof Error ? error.message : String(error));
      process.exit(1);
    }
  }


  // --- Load Provider Model Suggestions (provider_models.toml) ---
  try {
    if (fs.existsSync(providerModelsPath)) {
      const providerModelsFile = fs.readFileSync(providerModelsPath, 'utf-8');
      // Use TOML.parse, ensuring it handles the structure correctly
      // The library might return a Table object, convert if necessary
      const parsedToml = TOML.parse(providerModelsFile, { joiner: '\n', bigint: false });

      // Assuming the TOML structure is { provider: { models: [...] } }
      // We need to ensure the parsed structure matches ProviderModelsStructure
      if (typeof parsedToml === 'object' && parsedToml !== null) {
          providerModels = Object.entries(parsedToml).reduce((acc, [key, value]) => {
              // Ensure value is an object and has a 'models' array property
              if (typeof value === 'object' && value !== null && Array.isArray((value as any).models)) {
                  // Ensure models in the array are strings
                  const modelsArray = (value as any).models;
                  if (modelsArray.every((m: unknown) => typeof m === 'string')) {
                     acc[key.toLowerCase()] = { models: modelsArray as string[] };
                  } else {
                     console.warn(`Invalid model list for provider "${key}" in ${providerModelsPath}. Contains non-string elements. Skipping.`);
                  }
              } else {
                  console.warn(`Invalid structure for provider "${key}" in ${providerModelsPath}. Expected object with 'models' array. Skipping.`);
              }
              return acc;
          }, {} as ProviderModelsStructure);
          console.log(`Loaded model suggestions from ${providerModelsPath} for providers: ${Object.keys(providerModels).join(', ')}`);
      } else {
          console.warn(`Could not parse ${providerModelsPath} into a valid object.`);
      }

    } else {
      console.warn(`Provider models file not found at ${providerModelsPath}. Model suggestions will not be used.`);
    }
  } catch (error) {
    console.error(`Error loading or parsing ${providerModelsPath}:`, error instanceof Error ? error.message : String(error));
    // Continue without model suggestions
  }


  // --- Server Manager Initialization ---
  const serverManager = new ServerManager(serversConfigData);

  // --- Connect to Servers & Fetch Tools ---
  try {
    console.log('Connecting to configured servers...');
    const connectedServers = await serverManager.connectAll();
    console.log(`Successfully connected to ${connectedServers.length} servers.`);
    
    if (connectedServers.length === 0) {
      console.warn('Warning: No servers connected. Check your configuration and server status.');
    }
  } catch (error) {
    console.error('Error connecting to servers:', error instanceof Error ? error.message : String(error));
    // Continue even if some servers failed to connect
  }

  // --- Fetch All Available Tools ---
  let availableTools: Tool[] = [];
  try {
      console.log('Fetching available tools from connected servers...');
      availableTools = await serverManager.getAllTools();
      console.log(`Found ${availableTools.length} tools across all connected servers.`);
  } catch (error) {
      console.error('Error fetching tools:', error instanceof Error ? error.message : String(error));
      // Continue, but AI might not have tool access
  }


  // --- AI Client Initialization ---
  // Pass the fetched tools to the initialization function
  const aiClient = await initializeAiClientWithPrompting(
      aiConfigData,
      providerModels,
      aiConfigPath,
      availableTools // Pass tools here
  );
  let conversationManager: ConversationManager | null = null;

  // --- Instantiate Services ---
  const persistenceService = new ConversationPersistenceService(baseDir);
  const toolExecutor = new ToolExecutor(serverManager);
  let verificationService: VerificationService | null = null;
  if (aiClient) { // VerificationService needs an AI client
      verificationService = new VerificationService(aiClient);
  }
  // PromptFactory is used statically

  // --- Conversation Manager Initialization (if AI client and verification service are available) ---
  if (aiClient && verificationService) {
      conversationManager = new ConversationManager(
          aiClient,
          serverManager,
          persistenceService,
          toolExecutor,
          verificationService // Inject VerificationService
      );
  } else {
      console.log("ConversationManager not created due to missing AI client or VerificationService.");
  }

  // --- REPL Setup ---
  if (!conversationManager) {
      console.error("Cannot start REPL or Web UI without a configured AI provider and Conversation Manager. Exiting.");
      await serverManager.closeAll(); // Clean up connected servers
      process.exit(1);
  }

  // Pass providerModels to REPL as it needs it for the 'providers' command
  const repl = new Repl(serverManager, conversationManager, providerModels);

  // --- Initialize Web Server (if enabled in command line args) ---
  let webServer: WebServer | null = null;
  const useWeb = process.argv.includes('--web') || process.argv.includes('-w');
  const webPort = 3000; // Default port for web server
  
  if (useWeb && conversationManager) {
    webServer = new WebServer(conversationManager, serverManager, webPort);
    await webServer.init(); // Initialize asynchronously
    webServer.start(); // Start after initialization
    console.log(`Web interface available at http://localhost:${webPort}`);
  }

  // --- Graceful Shutdown ---
  const shutdown = async (signal: string) => {
    console.log(`\nReceived ${signal}. Shutting down...`);
    
    // Set a timeout for force exit in case shutdown hangs
    const exitTimer = setTimeout(() => forceExit(signal), forceExitTimeout);
    
    try {
      // Stop REPL
      repl.stop();
      
      // Stop web server if running
      if (webServer) {
        await webServer.stop();
      }
      
      // Close server connections
      await serverManager.closeAll();
      
      // Clear force exit timer since shutdown completed successfully
      clearTimeout(exitTimer);
      
      console.log('All server connections closed.');
      process.exit(0);
    } catch (error) {
      console.error('Error during shutdown:', error);
      
      // Clear force exit timer since we're exiting now
      clearTimeout(exitTimer);
      
      // Exit with error code
      process.exit(1);
    }
  };
  
  // Handle termination signals
  process.on('SIGINT', () => shutdown('SIGINT'));
  process.on('SIGTERM', () => shutdown('SIGTERM'));
  process.on('SIGTSTP', () => shutdown('SIGTSTP')); // Handle Ctrl+Z
  
  // Ensure we exit even if shutdown doesn't complete cleanly
  const forceExitTimeout = 5000; // 5 seconds
  const forceExit = (signal: string) => {
    console.log(`\nForcing exit after ${forceExitTimeout/1000} seconds (signal: ${signal}).`);
    process.exit(1);
  };
  
  // Start REPL if web interface is not enabled or if explicitly requested
  const useRepl = !useWeb || process.argv.includes('--repl') || process.argv.includes('-r');
  if (useRepl) {
    repl.start();
    if (useWeb) {
      console.log('Running in both REPL and web mode. Press Ctrl+C in this terminal to stop both.');
    }
  } else if (useWeb) {
    console.log('Running in web-only mode. Press Ctrl+C to stop.');
  }
}

// Run the main function
main().catch(error => {
  console.error('Unhandled error in main function:', error instanceof Error ? error.message : String(error));
  process.exit(1);
});

// --- Helper Functions ---

/**
 * Prompts the user for input, optionally hiding the input (for passwords/keys).
 */
async function promptForInput(promptText: string, hideInput: boolean = false): Promise<string> {
  return new Promise((resolve) => {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      terminal: true // Ensure terminal features are enabled
    });

    // Hacky way to hide input in standard readline
    const outputStream = process.stdout;
    const originalWrite = outputStream.write;
    let hiddenWriteActive = false;

    if (hideInput) {
      hiddenWriteActive = true;
      // Define the overriding function matching one of the stdout.write signatures
      const hiddenWrite = (
        chunk: Uint8Array | string,
        encodingOrCb?: BufferEncoding | ((err?: Error) => void), // Adjusted callback type
        cb?: (err?: Error) => void // Adjusted callback type
      ): boolean => {
        let encoding: BufferEncoding | undefined;
        let callback: ((err?: Error) => void) | undefined; // Adjusted callback type

        if (typeof encodingOrCb === 'function') {
          callback = encodingOrCb;
          encoding = undefined;
        } else {
          encoding = encodingOrCb;
          callback = cb;
        }

        // Only intercept string chunks
        if (typeof chunk === 'string') {
          // Allow newlines and carriage returns through
          if (chunk === '\n' || chunk === '\r' || chunk === '\r\n') {
            return originalWrite.call(outputStream, chunk, encoding, callback);
          }
          // Replace other characters with '*'
          const maskedChunk = '*'.repeat(chunk.length);
          return originalWrite.call(outputStream, maskedChunk, encoding, callback);
        }

        // Pass through non-string chunks (like Buffers) directly
        return originalWrite.call(outputStream, chunk, encoding, callback);
      };

      // Assign the correctly typed function - Use 'any' to bypass strict signature check here as it's complex
      (outputStream as any).write = hiddenWrite;
    }

    rl.question(promptText, (answer) => {
      if (hiddenWriteActive) {
        outputStream.write = originalWrite; // Restore original write method ONLY if it was overridden
        process.stdout.write('\n'); // Ensure newline after hidden input
      }
      rl.close();
      resolve(answer.trim());
    });
  }); // End of Promise constructor
}


/**
 * Initializes the AI client, prompting for missing API keys if necessary.
 */
import type { Tool } from '@modelcontextprotocol/sdk/types.js'; // Import Tool type

/**
 * Initializes the AI client, prompting for missing API keys if necessary.
 */
async function initializeAiClientWithPrompting(
  aiConfigData: AiConfigFileStructure,
  providerModels: ProviderModelsStructure,
  aiConfigPath: string,
  tools: Tool[] // Accept the list of tools
): Promise<IAiClient | null> {
  const providerNames = Object.keys(aiConfigData.providers || {});
  const defaultProviderName = aiConfigData.defaultProvider;
  const aiProviders = aiConfigData.providers;

  if (!defaultProviderName || !aiProviders || !aiProviders[defaultProviderName]) {
    if (providerNames.length > 0) {
      console.warn("No default AI provider specified or the specified default is invalid in ai_config.json. Chat will be disabled.");
    } else {
      console.warn("No AI providers configured in ai_config.json. Chat functionality is disabled.");
    }
    return null;
  }

  let defaultProviderConfig: AiProviderConfig = { ...aiProviders[defaultProviderName] }; // Clone to allow modification
  let aiClient: IAiClient | null = null;
  let retries = 3; // Limit retries for prompting

  while (retries > 0 && aiClient === null) {
    try {
      // Pass the tools to the factory
      aiClient = AiClientFactory.createClient(defaultProviderConfig, providerModels, tools);
      console.log(`Initialized default AI client: ${defaultProviderName} (${aiClient.getModelName()})`);
    } catch (error) {
      if (error instanceof MissingApiKeyError) {
        console.warn(`Configuration requires environment variable "${error.apiKeyEnvVar}" for provider "${error.providerName}", but it's not set.`);
        const apiKey = await promptForInput(`Enter API Key for ${error.providerName} (or press Enter to skip): `, true);

        if (!apiKey) {
          console.error(`API Key not provided for ${error.providerName}. Cannot initialize this provider.`);
          return null; // Stop trying for this provider
        }

        // Key provided: Update environment for this session
        process.env[error.apiKeyEnvVar] = apiKey;
        console.log(`API Key for ${error.providerName} set for this session.`);

        // Update the config file
        try {
          // Read the current config file again to avoid overwriting concurrent changes (less likely here, but good practice)
          const currentAiConfigFile = fs.readFileSync(aiConfigPath, 'utf-8');
          const currentAiConfigData = JSON.parse(currentAiConfigFile) as AiConfigFileStructure;

          // Find the provider and update it
          if (currentAiConfigData.providers && currentAiConfigData.providers[error.providerName]) {
            console.log(`Saving API key directly to ${aiConfigPath} for provider "${error.providerName}".`);
            console.warn("SECURITY WARNING: Storing API keys directly in configuration files is not recommended.");

            // Add apiKey, remove apiKeyEnvVar
            currentAiConfigData.providers[error.providerName].apiKey = apiKey;
            delete currentAiConfigData.providers[error.providerName].apiKeyEnvVar;

            // Write back to the file
            fs.writeFileSync(aiConfigPath, JSON.stringify(currentAiConfigData, null, 2), 'utf-8');
            console.log(`Configuration updated in ${aiConfigPath}.`);

            // Update the in-memory config for the retry
            defaultProviderConfig = { ...currentAiConfigData.providers[error.providerName] };

          } else {
            console.error(`Could not find provider "${error.providerName}" in ${aiConfigPath} to save the key.`);
            // Continue retry with the key set in process.env for this session
          }
        } catch (writeError) {
          console.error(`Error writing updated configuration to ${aiConfigPath}:`, writeError);
          // Continue retry with the key set in process.env for this session
        }

        // Decrement retries and loop to try creating the client again
        retries--;

      } else {
        // Different error, rethrow
        console.error(`Failed to initialize default AI provider "${defaultProviderName}" from ai_config.json:`, error instanceof Error ? error.message : String(error));
        console.error("Chat functionality will be disabled. Check your AI configuration.");
        return null; // Stop trying
      }
    }
  } // End while loop

  if (!aiClient) {
     console.error(`Failed to initialize AI client for ${defaultProviderName} after multiple attempts.`);
  }

  return aiClient;
}
</file>

<file path="package.json">
{
  "name": "mcp-multi-client",
  "version": "1.0.0",
  "description": "An improved MCP client that connects to multiple servers defined in a config file.",
  "main": "dist/index.js",
  "type": "module",
  "scripts": {
    "build:css": "tailwindcss -i ./web/css/base.css -o ./web/build/tailwind.css --minify",
    "build:ts": "tsc",
    "build": "npm run build:css && npm run build:ts",
    "start": "node dist/index.js",
    "dev": "npm run build && node dist/index.js",
    "web": "npm run build && node --unhandled-rejections=strict dist/index.js --web",
    "both": "npm run build && node --unhandled-rejections=strict dist/index.js --web --repl",
    "watch:css": "tailwindcss -i ./web/css/base.css -o ./web/build/tailwind.css --watch",
    "watch:ts": "tsc --watch",
    "lint": "tsc --noEmit"
  },
  "keywords": [
    "mcp",
    "client",
    "model context protocol"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "@langchain/anthropic": "^0.1.0",
    "@langchain/community": "^0.0.16",
    "@langchain/core": "^0.1.33",
    "@langchain/google-genai": "^0.0.9",
    "@langchain/mistralai": "^0.0.4",
    "@langchain/openai": "^0.0.13",
    "@ltd/j-toml": "^1.38.0",
    "@modelcontextprotocol/sdk": "^1.9.0",
    "@tailwindcss/cli": "^4.1.4",
    "cors": "^2.8.5",
    "express": "^5.1.0",
    "socket.io": "^4.8.1",
    "tailwindcss": "^4.1.4",
    "typescript": "^5.3.3",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "@tailwindcss/forms": "^0.5.7",
    "@types/cors": "^2.8.17",
    "@types/express": "^5.0.1",
    "@types/uuid": "^9.0.8",
    "tailwindcss-animate": "^1.0.7"
  }
}
</file>

<file path="provider_models.toml">
# Model suggestions for AI providers
# These are used as fallbacks when no specific model is provided in the server configuration

[anthropic]
models = [
  "claude-3-opus-20240229",
  "claude-3-sonnet-20240229",
  "claude-3-haiku-20240307",
  "claude-3-5-sonnet-20240620",
  "claude-2.1",
  "claude-2.0",
  "claude-instant-1.2"
]

[openai]
models = [
  "gpt-4-1106-preview",
  "gpt-4-vision-preview",
  "gpt-4o",
  "gpt-4o-mini",
  "gpt-4-turbo",
  "gpt-4",
  "gpt-3.5-turbo"
]

[google-genai]
models = [
  "gemini-1.5-pro",
  "gemini-1.5-flash",
  "gemini-1.0-pro",
  "gemini-1.0-ultra"
]

[mistralai]
models = [
  "mistral-large-latest",
  "mistral-medium-latest",
  "mistral-small-latest",
  "open-mistral-7b"
]

[fireworks]
models = [
  "accounts/fireworks/models/llama-v3-70b",
  "accounts/fireworks/models/llama-v3-8b",
  "accounts/fireworks/models/mixtral-8x7b-instruct"
]

[together]
models = [
  "mistralai/Mixtral-8x7B-Instruct-v0.1",
  "meta-llama/Llama-2-70b-chat-hf",
  "togethercomputer/llama-2-70b-chat"
]
[openrouter]
models = [
  "openai/gpt-4o",
  "anthropic/claude-3-opus-20240229",
  "anthropic/claude-3-5-sonnet-20240620",
  "meta-llama/llama-3-70b-instruct",
  "mistral/mistral-large-latest",
  "google/gemini-pro"
]
</file>

<file path="README.md">
# MCP Multi-Client

An improved MCP (Model Context Protocol) client that connects to multiple servers defined in a configuration file and provides both a command-line REPL and a web interface for interaction.

## Features

- Connect to multiple MCP tool servers simultaneously
- Support for multiple AI providers (Anthropic, OpenAI, Google, Mistral, Fireworks)
- Tool execution with proper parsing and handling
- Chat functionality with tool usage
- Response verification against auto-generated criteria
- Interactive REPL interface for command-line usage
- Web interface for browser-based interaction
- Conversation history management and compaction

## Setup

1. Install dependencies:

```bash
npm install
```

2. Configure your MCP servers in `servers.json`:

```json
{
  "mcpServers": {
    "bash": {
      "command": "npx",
      "args": ["-y", "@anthropic/cli-mcp-server-tools", "bash"],
      "env": {}
    },
    "search": {
      "command": "npx",
      "args": ["-y", "@mcp/server-search@latest"],
      "env": {}
    }
    // Add more servers here
  }
  // timeouts removed
}
```

3. Configure your AI providers in `ai_config.json`:

```json
{
  "defaultProvider": "anthropic",
  "providers": {
    "anthropic": {
      "provider": "anthropic",
      "model": "claude-3-5-sonnet-20240620",
      "apiKeyEnvVar": "ANTHROPIC_API_KEY",
      "temperature": 0.7
    },
    "openai": {
      "provider": "openai",
      "model": "gpt-4o-mini",
      "apiKeyEnvVar": "OPENAI_API_KEY"
    }
    // Add more providers here
  }
}
```

4. Set up your API keys as environment variables (e.g., `ANTHROPIC_API_KEY`, `OPENAI_API_KEY`, etc., corresponding to the `apiKeyEnvVar` values in `ai_config.json`).

5. Configure model suggestions in `provider_models.toml` (Optional, used as fallback if `model` is not specified in `ai_config.json`).

## Usage

### Building the Project

```bash
npm run build
```

### REPL Mode (Command Line)

```bash
npm start
# or
npm run dev  # Build and start
```

### Web Interface

```bash
npm run web
```

### Both Modes Simultaneously

```bash
npm run both
```

## REPL Commands

- `chat` - Enter interactive chat mode with the AI agent
- `exit` - Exit chat mode or the REPL
- `quit` - Alias for exit
- `servers` - List all connected servers
- `use <server>` - Select a server for direct tool calls
- `tools [server]` - List tools on current or specified server
- `call <tool> [json]` - Call tool on current/auto-detected server
- `history` - Show conversation history (in chat mode)
- `clear` - Clear conversation history (in chat mode)

## Web Interface

The web interface is available at `http://localhost:3000` when running in web mode. It provides:

- Chat interface for interacting with the AI
- Real-time responses using WebSocket
- Display of available tools
- Connected server information
- Conversation history
- Tool call visualization
- Thinking indicators
- Responsive design with Tailwind CSS

## Architecture

The multi-client implementation follows a modular architecture:

- **ServerManager**: Manages connections to multiple tool servers
- **ConversationManager**: Handles chat logic, tool calls, and verification
- **AI Client Layer**: Provides a unified interface to different AI providers
- **REPL**: Command-line interface for user interaction
- **WebServer**: Web interface with REST API and WebSocket for real-time updates
- **UI Layer**: Responsive web interface using Tailwind CSS

## Custom AI Providers

To add a new AI provider:

1. Add the provider's LangChain integration to `package.json`
2. Update `AiClientFactory.ts` with a new case for the provider
3. Add model suggestions to `provider_models.toml`

## License

MIT
</file>

<file path="servers.json">
{
  "mcpServers": {
    "bash": {
      "command": "npx",
      "args": [
        "-y",
        "@anthropic/cli-mcp-server-tools",
        "bash"
      ],
      "env": {}
    },
    "search": {
      "command": "npx",
      "args": [
        "-y",
        "@mcp/server-search@latest"
      ],
      "env": {}
    },
    "supabase": {
      "command": "npx",
      "args": [
        "-y",
        "@supabase/mcp-server-supabase@latest",
        "--access-token",
        "YOUR_SUPABASE_ACCESS_TOKEN"
      ],
      "env": {
        "SUPABASE_ACCESS_TOKEN": "YOUR_SUPABASE_ACCESS_TOKEN"
      }
    }
  }
}
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./web/**/*.{html,js}",
  ],
  darkMode: 'class',
  theme: {
    extend: {
      colors: {
        primary: '#3b82f6',
        secondary: '#6366f1',
        success: '#22c55e',
        warning: '#f59e0b',
        danger: '#ef4444',
      },
    },
  },
  plugins: [],
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "outDir": "./dist",
    "rootDir": "./",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true,
    "sourceMap": true
  },
  "include": ["index.ts", "src/**/*.ts"],
  "exclude": ["node_modules", "dist"]
}
</file>

</files>
